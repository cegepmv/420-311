var relearn_searchindex = [
  {
    "breadcrumb": "Structures de donnée",
    "content": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "tags": [],
    "title": "Préalables",
    "uri": "/420-311/intro/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "Dans ce chapitre nous allons découvrir quelques structures de données et apprendre à choisir la bonne structure selon le problème.\nⓂ️ Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util).\nⓂ️ On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nⓂ️ Nous commencerons par examiner les concepts communs qu’elles (structures de données) exploitent ainsi : généricité, itérateur, ordonnancement et relation d’ordre.\nⓂ️ Nous verrons également quelles sont les opérations qui leur sont communes : ajout ou suppression d’éléments, construction à partir des éléments d’une autre collection…\nⓂ️ Nous étudierons ensuite en détail chacune de ces structures, à savoir :\n🌱 Les listes, implémentées par la classe LinkedList;\r🌱 Les vecteurs dynamiques, implémentés par les classes ArrayList et Vector;\r🌱 Les ensembles, implémentés par les classes HashSet et TreeSet;\r🌱 Les queues avec priorité, implémentées par la classe PriorityQueue (introduite par le JDK 5.0) ;\r🌱 Les queues à double entrée, implémentées par la classe ArrayDeque (introduite par Java6).",
    "description": "Dans ce chapitre nous allons découvrir quelques structures de données et apprendre à choisir la bonne structure selon le problème.\nⓂ️ Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util).\nⓂ️ On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nⓂ️ Nous commencerons par examiner les concepts communs qu’elles (structures de données) exploitent ainsi : généricité, itérateur, ordonnancement et relation d’ordre.",
    "tags": [],
    "title": "Structure de données",
    "uri": "/420-311/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "Dans ce chapitre, nous allons voir ce que signifie la notation Big-O et analyser la complexité d’un algorithme simple, ainsi que comparer plusieurs approches pour résoudre un même problème. En fin, nous allons voir comment mesurer expérimentalement la performance d’un programme en Java.",
    "description": "Dans ce chapitre, nous allons voir ce que signifie la notation Big-O et analyser la complexité d’un algorithme simple, ainsi que comparer plusieurs approches pour résoudre un même problème. En fin, nous allons voir comment mesurer expérimentalement la performance d’un programme en Java.",
    "tags": [],
    "title": "Complexité algorithmique",
    "uri": "/420-311/complexalgo/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "Les entrées/sorties (IO) en Java regroupent l’ensemble des mécanismes permettant de lire et d’écrire des données, que ce soit dans un fichier, sur la console, à travers le réseau ou en mémoire. Le langage propose une riche bibliothèque (java.io et java.nio) avec des classes spécialisées pour traiter les flux de caractères (texte) et les flux binaires (octets). Comprendre ces outils est essentiel pour manipuler efficacement les données.",
    "description": "Les entrées/sorties (IO) en Java regroupent l’ensemble des mécanismes permettant de lire et d’écrire des données, que ce soit dans un fichier, sur la console, à travers le réseau ou en mémoire. Le langage propose une riche bibliothèque (java.io et java.nio) avec des classes spécialisées pour traiter les flux de caractères (texte) et les flux binaires (octets). Comprendre ces outils est essentiel pour manipuler efficacement les données.",
    "tags": [],
    "title": "IO",
    "uri": "/420-311/io/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "La généricité est un mécanisme qui permet d’écrire du code flexible et réutilisable en définissant des classes, interfaces ou méthodes paramétrées par des types. Dans ce chapitre nous allons voir comment la généricité renforce la sécurité de typage et son utilisation avec les collections (List, Map, Set).",
    "description": "La généricité est un mécanisme qui permet d’écrire du code flexible et réutilisable en définissant des classes, interfaces ou méthodes paramétrées par des types. Dans ce chapitre nous allons voir comment la généricité renforce la sécurité de typage et son utilisation avec les collections (List, Map, Set).",
    "tags": [],
    "title": "Genericity",
    "uri": "/420-311/genericity/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Rappel : Concepts de base Classe : Modèle définissant les attributs (variables) et comportements (méthodes).\nObjet : Instance concrète d’une classe.\nEncapsulation : Protéger les données via des modificateurs d’accès (private, public, protected) et exposer des méthodes d’accès (getters/setters).\nAbstraction : Masquer les détails d’implémentation et ne montrer que les fonctionnalités essentielles (via classes abstraites et interfaces).\nHéritage : Une classe peut hériter des attributs et méthodes d’une autre (mot-clé extends).\nPolymorphisme :\nSurcharge (overloading) : même nom de méthode, signatures différentes. Redéfinition (overriding) : une sous-classe redéfinit le comportement d’une méthode héritée. Constructeur : Méthode spéciale exécutée lors de la création d’un objet (new).\nModificateurs d’accès Modificateur Même classe Même package Sous-classe Partout public ✅ ✅ ✅ ✅ protected ✅ ✅ ✅ ❌ (default) ✅ ✅ ❌ ❌ private ✅ ❌ ❌ ❌ Syntaxe essentielle Définir une classe public class Voiture { private String marque; private int annee; public Voiture(String marque, int annee) { this.marque = marque; this.annee = annee; } public void demarrer() { System.out.println(marque + \" démarre !\"); } }\rCréer un objet Voiture v1 = new Voiture(\"Toyota\", 2022); v1.demarrer();\rHéritage et polymorphisme class Animal { public void parler() { System.out.println(\"??\"); } } class Chien extends Animal { @Override public void parler() { System.out.println(\"Woof\"); } } Animal a = new Chien(); // polymorphisme a.parler(); // \"Woof\"\rAbstraction et interfaces abstract class Forme { abstract double aire(); } class Cercle extends Forme { private double r; Cercle(double r) { this.r = r; } @Override double aire() { return Math.PI * r * r; } } interface Volant { void voler(); } class Avion implements Volant { public void voler() { System.out.println(\"En vol ✈️\"); } }\rClasses utiles Object : classe racine de toutes les classes Java. Méthodes importantes : toString(), equals(), hashCode(), clone().\nfinal :\nfinal class : non-héritée. final method : non-redéfinissable. final variable : constante. Gestion mémoire Les objets sont créés sur le tas (heap) via new. Le garbage collector libère automatiquement la mémoire des objets non référencés. Bonnes pratiques Utiliser private pour protéger les données. Toujours redéfinir toString() pour représenter un objet. Respecter la cohérence equals() / hashCode(). Favoriser la composition plutôt que l’héritage trop profond. Documenter avec JavaDoc (/** … */). Exemple : package s01; class Etudiant { private String nom; private int age; public Etudiant(String nom, int age) { this.nom = nom; this.age = age; } public void afficherInfos() { System.out.println(\"Nom : \" + nom + \", Âge : \" + age); } } class EtudiantRegulier extends Etudiant { private String programme; public EtudiantRegulier(String nom, int age, String programme) { super(nom, age); this.programme = programme; } @Override public void afficherInfos() { super.afficherInfos(); System.out.println(\"Programme : \" + programme); } } public class RappelPOO { public static void main(String[] args) { EtudiantRegulier e = new EtudiantRegulier(\"Alice\", 20, \"Informatique\"); e.afficherInfos(); } }\r📘 Résumé de révision – POO 🔹 1. Classes Une classe public est accessible depuis n’importe quel package. Une classe abstract sert de modèle, ne peut pas être instanciée et peut contenir des méthodes abstraites. Une classe final ne peut pas être héritée. Une classe private n’est possible qu’en classe interne (nested class). Toute classe hérite implicitement de Object → possède donc les méthodes toString(), equals(), hashCode(), etc. 🔹 2. Constructeurs Si aucune déclaration → le compilateur génère un constructeur par défaut (sans paramètres). Un constructeur peut être private (utilisé dans le pattern Singleton ou classes utilitaires). 🔹 3. Méthodes Les méthodes peuvent être surchargées (overloading) → même nom, paramètres différents. Les méthodes peuvent être surdéfinies (overriding) → même signature, dans une sous-classe. Une méthode final ne peut pas être redéfinie dans une sous-classe. Une méthode abstract est déclarée sans corps et doit être implémentée dans une sous-classe. abstract et final sont incompatibles (contradiction). 🔹 4. Attributs Un attribut final est une constante : doit être initialisé une seule fois (déclaration ou constructeur). 🔹 5. Interfaces Une interface ne peut pas être instanciée.\nUne interface n’est pas un objet, c’est un contrat.\nUne interface n’hérite pas d’Object, mais les classes qui l’implémentent héritent d’Object.\nUne interface peut hériter d’une ou plusieurs autres interfaces avec extends.\nUne interface ne peut pas hériter d’une classe.\nMéthodes dans une interface :\nAvant Java 8 → uniquement public abstract. Depuis Java 8 → méthodes default et static avec implémentation. Depuis Java 9 → méthodes private pour factoriser du code interne. 🔹 6. Comparable vs Comparator Comparable : définit l’ordre naturel d’une classe (méthode compareTo). Comparator : définit un ordre externe, peut être multiple et personnalisé (méthode compare). 🔹 7. Mots-clés spéciaux null → valeur littérale spéciale, pas un mot-clé. this → référence à l’instance courante. super → référence à la classe parente. Résumé Élément Description Exemple Classe abstract Non instanciable, modèle pour héritage abstract class Forme { abstract double aire(); } Classe final Ne peut pas être héritée final class Utilitaire {} Méthode final Ne peut pas être redéfinie public final void calcul() {} Méthode abstract Sans corps, à implémenter abstract void afficher(); Attribut final Constante, valeur fixée une seule fois final double PI = 3.14; Interface Contrat, non instanciable interface Vehicule { void rouler(); } Comparable Ordre naturel, compareTo class Etudiant implements Comparable\u003cEtudiant\u003e Comparator Ordre externe, compare Comparator\u003cEtudiant\u003e parNom = ...;",
    "description": "Rappel : Concepts de base Classe : Modèle définissant les attributs (variables) et comportements (méthodes).\nObjet : Instance concrète d’une classe.\nEncapsulation : Protéger les données via des modificateurs d’accès (private, public, protected) et exposer des méthodes d’accès (getters/setters).\nAbstraction : Masquer les détails d’implémentation et ne montrer que les fonctionnalités essentielles (via classes abstraites et interfaces).\nHéritage : Une classe peut hériter des attributs et méthodes d’une autre (mot-clé extends).",
    "tags": [],
    "title": "Révision",
    "uri": "/420-311/intro/revisionpoo/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Questions théoriques Question 1 : Quel est le résultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le résultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le résultat du code suivant:\npublic class Question3 { public static void main(String[]args) { int val1 = 9; int val2 = 9; String str = \"9\"; System.out.println(val1 + val2 + str);\t} }\rQuestion 4 : Quel est le résultat du code suivant:\npublic class Question4 { public static void main(String[]args) { try { int a, b; b = 0; a = 5 / b; System.out.print(\"A\"); } catch (Exception e) { System.out.print(\"B\"); } finally { System.out.print(\"C\"); }\t} }\rQuestion 5 : Quel est le résultat du code suivant:\npublic class Question5 { public static void main(String[]args) { String obj = \"Bonjour\"; String obj1 = \"Bonsoir\"; String obj2 = \"Bonjour\"; System.out.println(obj.equals(obj1) + \" \" + obj.equals(obj2)); } }\rQuestion 6 : Quel est le résultat du code suivant:\npublic class ClasseA { public int i; public int j; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.j = 3; System.out.println(i + \" \" + j); } } public class Question6 { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 7 : Quel est le résultat du code suivant:\npublic class ClasseA { public int i; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.i = j + 1; System.out.println ( j + \" \" + i); } } public class Main { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 8 : Quel est le résultat du code suivant:\npublic class Question8{ public static void main(String[] args) { String s = \"Hello World\"; int A = s.indexOf('o'); int B = s.lastIndexOf('l'); System.out.println(A + \" \" + B); } }\rQuestion 9 : Quel est le résultat du code suivant:\npublic class Question9{ public static void main(String[] args) { char ch; ch = \"hello\".charAt(1); System.out.println(ch); } }\rQuestion 10 : Quel est le résultat du code suivant:\npublic class Question10{ public static void main(String[] args) { String chars[] = {\"a\", \"b\", \"c\", \"a\", \"c\"}; for (int i = 0; i \u003c chars.length; ++i) for (int j = i + 1; j \u003c chars.length; ++j) if(chars[i].compareTo(chars[j]) == 0) System.out.print(chars[j]); } }\rQuestion 11 : Quel est le résultat du code suivant:\npublic class Question11{ public static void main(String[] args) { int a1[] = new int[10]; int a2[] = { 1, 2, 3, 4, 5 }; System.out.println(a1.length + \" \" + a2.length); } }\rQuestion 12 : Quel est le résultat du code suivant:\npublic class Question12{ public static void main(String[] args) { int arr[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i \u003c arr.length - 2; ++i) System.out.print(arr[i] + \" \"); } }\rQuestion 13 : Quel est le résultat du code suivant:\npublic class Question13{ public static int param1; public static int param2; public void add(int a, int b) { param1 = a + b; param2 = param1 + b; } public static void main(String args[]) { Question13 obj1 = new Question13(); Question13 obj2 = new Question13(); int a = 2; obj1.add(a, a + 1); obj2.add(5, a); System.out.println(obj1.param1 + \" \" + obj2.param2); } }\rQuestion 14 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question14{ public static void main(String[] args) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 15 : Quel est le résultat du code suivant:\npublic class Question15{ public static int param1; public void increment() { param1++; } public static void main(String args[]) { Question15 obj1 = new Question15(); Question15 obj2 = new Question15(); obj1.param1 = 0; obj1.increment(); obj2.increment(); System.out.println(obj1.param1 + \" \" + obj2.param1); } }\rQuestion 16 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question16 { public static void main(String args[]) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 17 : Quel est le résultat du code suivant:\npublic class Question17 { public static void main(String[] args) { ClasseB classeB = new ClasseB(); System.out.println(\"Valeur = \" + classeB.calculer(3, 6)); } } class ClassA { final public int calculer(int a, int b) { return 0; } } class ClasseB extends ClasseA { public int calculer(int a, int b) { return 1; } }\rQuestion 18 : Quel est le résultat du code suivant:\npublic class Question18 { public static void main (String args[]) { int param1, param2= 1; param1= 10; if (param1!= 10 \u0026\u0026 param1/ 0 == 0) { System.out.println(param2); } else { System.out.println(++param2); } } }\rQuestion 19 : Quel est le résultat du code suivant:\npublic class Question19 { public static int param1; public static int param2; public void add(int val1, int val2) { param1 = val1 + val2; param2 = param1 + val2; } public static void main(String[] args) { Question19 instance1 = new Question19 (); Question19 instance2 = new Question19 (); Question19 instance3 = new Question19 (); int abc = 2;\tinstance1.add(abc, abc-1); instance3.add(6, 6/abc); instance2.add(5, abc/2); System.out.println(instance1.param1); System.out.println(instance2.param2); } }\rQuestion 20 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question20 { public static void main(String args[]) { int array[] = new int [5]; for (int i = 5; i \u003e 0; i--) { array[5 - i] = i; } Arrays.sort(array); System.out.print(Arrays.toString(array)); } }\rQuestion 21 : Quel est le résultat du code suivant:\npublic class Question21 { public static void main(String [] args) { Question21 instance = new Question21(); instance.myMethod(); } public void myMethod(){ long [] tab1 = {6,8,9}; long []tab2 = affectation(tab1); System.out.print(tab1[0] + tab1[1] + tab1[2] + \" \"); System.out.println(tab2[0] + tab2[1] + tab2[2]); } public long[] affectation(long[] tab3){ tab3[1] = 7; return tab3; } }\rExercices pratiques Exercice 1 : Soit la String suivante: A-b-C-d-E-f-1234-***///-\u003e , écrire un programme en Java qui:\n👍 convertit chaque caractère alphabétique majuscule de la String en un caractère minuscule; 👍 Convertis chaque caractère alphabétique minuscule de la String en un caractère majuscule; 👍 Supprime tous les caractères spéciaux de la String; Exercice 2 : Soit le tableau suivant: String [] days = { \"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\", \"Dimanche\"}; Écrire un programme en Java qui:\n👍 choisi aléatoirement une journée du tableau et l’affiche; 👍 Tri le tableau; Exercice 3 : Soit le code Java suivant:\nString str1 = \"Bonjour\"; String str2 = new String (\"Bonjour\"); str1 == str2; //3 str1.equals(str2); //4\rExpliquez la différence entre les 02 lignes de code (ligne 3 et ligne 4)?\nExercice 4 : Soit la classe Compte bancaire avec les attributs suivants:\nidCpte (numéro unique: donc 2 comptes ne peuvent pas avoir le même ID); firstName; lastName; solde; En utilisant les collections Java (List, Set et Map) et en vous utilisant l’API Java, vous devez coder les méthodes suivantes:\n👍 addCompteToCollection (List | Set | Map)\r👍 serachCompteInCollection (List | Set | Map)\r👍 sortCollection (List | Set | Map)\r👍 removeCompteFromCollection (List | Set | Map)\r👍 emptyCollectionComptes (List | Set | Map)\rExercice 5 : Écrire un code Java qui convertit un tableau d’entiers (tableau à crochets) en une collection de type List.\nÉcrire un code Java qui convertit une collection de type List en un tableau à crochets.\nÉcrire un code Java qui convertit une collection de type List en une collection de Type Set.\nÉcrire un code Java qui convertit une collection de type Set en une collection de Type List.\nÉcrire un code Java qui convertit une collection de type List en une collection de Type Map.\nÉcrire un code Java qui convertit une collection de type Map en une collection de Type List.\nExercice 6 : Soit le tableau de conversion des devises suivant :\nDe Vers Taux Dollar canadien (CAD) Euro 1 CAD = 0.74 EURO Dollar canadien (CAD) Dollar américain (USD) 1 CAD = 0.69 USD Euro Dollar canadien (CAD) 1 EURO = 1.45 CAD Dollar américain (USD) Dollar canadien (CAD) 1 USD = 1.36 CAD Écrire un programme Java qui demande à un utilisateur de choisir un type conversion et saisir un montant à convertir. Le programme traitera la conversion et affichera le montant converti.\nCondition:\nLe programme n’acceptera que les montants entre 90 et 6500, cela dans chaque sorte de devises. Le programme ne doit pas s’arrêter tant que l’utilisateur n’aura pas choisi de quitter. Exercice 7 : Soit le système de notation universitaire :\nNote numérique Note littérale 90 et + A De 80 à 89 B De 70 à 79 C De 60 à 69 D De 50 à 59 E \u003c 50 F Écrire un programme Java qui demande à un utilisateur de saisir 4 notes numériques. Ensuite le programme calculera la moyenne et affichera la note littérale correspondante.\nCondition:\nLe programme n’acceptera que les notes entre 0 et 100.\nExemple\nLe programme demande les notes à l’utilisateur : Veuillez saisir vos notes Svp : L’utilisateur saisit les notes suivantes : 59, 72.5, 83.73, 45.5\nLe programme calculera la moyenne et affichera :\nVotre moyenne numérique est : 65,18 ce qui donnera en littérale la note de D.\nExercice 8 : Soit la liste des villes suivantes : Ottawa, Paris, Berne, Washington, Berlin, Madrid, Mexico.\n🌼 Écrire un programme Java qui génère aléatoirement 2 villes parmi la liste des villes et demandera à un utilisateur de deviner les 2 villes au bout de 3 tentatives.\nSi l’utilisateur arrive à deviner les 2 villes aléatoires, le programme affichera un message et quittera. Si l’utilisateur n’arrive pas à deviner les 2 villes aléatoires au bout de 3 tentatives, le programme affichera le résultat et quittera. Clarification\nModèle de message en cas de succès de devinette Bravo! Vous avez deviné les 2 villes : Ottawa et Paris. Modèle de message en cas d’échec de devinette Oups! En 3 tentatives, vous n’êtes pas arrivé à deviner les 2 villes : Ottawa et Paris. Exercice 9 : On souhaite gérer une liste de prénoms d’étudiants dans un cours. Réalise un programme Java qui :\nCrée une liste de type ArrayList. Ajoute les prénoms suivants : “Alice”, “Bob”, “Charlie”, “Diane”. Affiche la taille de la liste et son contenu. Demande à l’utilisateur d’entrer un prénom, puis : Vérifie s’il est présent dans la liste (affiche un message approprié). Si présent, affiche sa position dans la liste. Supprime un prénom donné par l’utilisateur et réaffiche la liste. Trie la liste par ordre alphabétique et affiche le résultat. Exercice 10 : Soit le diagramme de classes suivant :\nCréer les classes Java correspondant aux classes du diagramme. Il vous faudra respecter les attributs et les relations entre les différentes classes. Écrire une méthode de service qui permet de calculer le prix réel d’un produit suivant la règle suivante : a.\tSi le produit est biologique, « indiceBio » et le produit appartiennent à un fournisseur habitant la province du « Québec », alors le prix réel est :\ni.\tPrix réel = prix du produit + prix du produit*tps + prix du produit * tvq. b.\tSi le produit est biologique, « indiceBio » et le produit appartiennent à un fournisseur habitant le Canada (sauf la province du Québec) alors le prix réel est :\ni.\tPrix réel = prix du produit + prix du produit*tps. c.\tSi le produit est biologique « indiceBio » et le produit appartient à un fournisseur habitant les USA alors le prix réel est :\ni.\tPrix réel = prix du produit + prix du produit*usTax. Écrire une méthode de service qui permet de calculer le total prix (la somme totale) des produits de tous les fournisseurs américains. Exercice 11 : Soit la String suivante: String chaineDepart = “$_%4*1;-0er2bo%t?c(o(id\u003eer7dn1ev” écrire le programme qui traite l’algorithme suivant:\nLire la String « chaineDepart » Parcourir la String et appliquer le traitement suivant: Mettre les 04 premiers caractères dans une Stack (appelée stack01); Mettre les 04 caractères suivants dans une liste (appelée liste01); Mettre les 04 caractères suivants dans un vecteur (appelée vecteur01); Mettre le reste de la chaine dans une Queue (appelée queue01); Déclarer un String vide appelé resultat01; Déclarer un String vide appelé resultat02; Dépilez le premier élément de la stack01 et ajoutez-le à la String resultat01; Ajouter à la String resultat01, le 2e qui se trouve dans liste01; Parcourez le vecteur01, si l’élément est un chiffre, mettez-le dans la String resultat01, sinon mettez-le dans la String resultat02; Défiler la queue01, mettez seulement les lettres alphabétiques dans la String resultat02. Inversez les 02 Strings; Déclarer un String vide appelé resultatFinal; Copiez les 08 premiers caractères de la String resultat02 dans la String resultatFinal; Ajoutez un espace à la String resultatFinal; Copiez les 02 premiers éléments de la String resultat01 dans la String resultatFinal; Ajoutez un espace à la String resultatFinal; Copiez le reste des caractères de la String resultat02 dans la String resultatFinal; Ajoutez un espace à la String resultatFinal; Copiez le reste des caractères de la String resultat01 dans la String resultatFinal; Afficher le résultat;",
    "description": "Questions théoriques Question 1 : Quel est le résultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le résultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le résultat du code suivant:",
    "tags": [],
    "title": "Questions et exercices",
    "uri": "/420-311/intro/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code d’événement dans le bandeau supérieur Quiz 2 : méthodes et interfaces Quiz Wooclap sur les méthodes et les interfaces",
    "description": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code d’événement dans le bandeau supérieur Quiz 2 : méthodes et interfaces Quiz Wooclap sur les méthodes et les interfaces",
    "tags": [],
    "title": "Quiz",
    "uri": "/420-311/intro/quiz/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "Tout au long du cours nous allons utiliser différents outils de développement logiciel largement employés dans l’industrie. Ces outils permettent de travailler de manière plus efficace, professionnelle et collaborative.\nGit : pour gérer les versions du code et collaborer en équipe.\nMaven : pour automatiser la gestion des dépendances et la compilation des projets Java.\nAutres outils : environnements de développement (IDE), plateformes de test, documentation et suivi de projet.\nCette section vous trouver des ressources qui vous aident à se familiariser avec ces outils.",
    "description": "Tout au long du cours nous allons utiliser différents outils de développement logiciel largement employés dans l’industrie. Ces outils permettent de travailler de manière plus efficace, professionnelle et collaborative.\nGit : pour gérer les versions du code et collaborer en équipe.\nMaven : pour automatiser la gestion des dépendances et la compilation des projets Java.\nAutres outils : environnements de développement (IDE), plateformes de test, documentation et suivi de projet.",
    "tags": [],
    "title": "Ressources utiles",
    "uri": "/420-311/ressourcesutiles/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "Notion de structure de données Ⓜ️ Le principe de base d’une structure de données, c’est de stocker des éléments auxquels le programmeur veut pouvoir accéder plus tard. On appelle les différentes utilisations possibles de la structure de données des opérations.\nClassification des structures de données 🔹 Structures de base Tableau (array) : Une collection d’éléments de même type stockés en mémoire de façon contiguë. Chaque élément est accessible par son index.\nSchéma Index : 0 1 2 3\rValeur: [10] [20] [30] [40]\rComplexité Accès direct : O(1) Recherche d’une valeur : O(n) Insertion/suppression : O(n) (décalage nécessaire) Avantages Accès rapide par index. Simple à utiliser. Inconvénients Taille fixe (souvent). Insertion/suppression coûteuses. Exemple réel Les sièges d’un avion numérotés → on sait directement où est le siège 25B.\nListe chaînée (linked list) : Une séquence de nœuds où chaque nœud contient une valeur et une référence vers le suivant (et parfois vers le précédent → liste doublement chaînée).\n* Liste simplement chaînée 🌼 Les listes simplement chaînées sont des structures de données semblables aux tableaux. Les éléments de la liste sont souvent appelés Liens ou Nœuds. 🌼 Un élément de la liste se compose : \tUn autre pointeur qui pointe vers l’élément suivant, \tLe pointeur suivant du dernier élément doit pointer vers NULL (la fin de la liste). \tEn plus un élément se compose d’une valeur 🌼 Pour accéder à un élément, la liste peut être parcourue dans les deux sens : 🌼 En commençant en tête de liste, le pointeur suivant permettra le déplacement vers le prochain élément. 🌼 En bref, le déplacement se fait dans une seule direction, du premier vers le dernier élément.\n* Liste doublement chaînée 🌼 Les listes doublement chaînées sont des structures de données semblables aux listes simplement chaînées. Les éléments de la liste sont souvent appelés Liens ou Nœuds. La classe LinkedList permet de manipuler des listes dites “doublement chaînées”. À chaque élément de la collection, on associe (de façon totalement transparente pour le programmeur) deux informations supplémentaires qui ne sont autres que les références à l’élément précédent et au suivant. Une telle collection peut ainsi être parcourue à l’aide d’un itérateur bidirectionnel de type ListIterator.\nLe grand avantage d’une telle structure est de permettre des ajouts ou des suppressions à une position donnée avec une efficacité en O (1) (ceci grâce à un simple jeu de modification de références).\nEn revanche, l’accès à un élément en fonction de sa valeur ou de sa position dans la liste sera peu efficace puisqu’il nécessitera obligatoirement de parcourir une partie de la liste. L’efficacité sera donc en moyenne en O (N).\nSchéma Tête → [10|•] → [20|•] → [30|null]\rListe simplement chaînée et liste doublement chaînée\nListe simplement chaînée circulaire\nComplexité Insertion/suppression en tête : O(1)\nInsertion :\nà la fin O(1) au début O(1) au milieu O(n) suppression :\nau début O(1) à la fin O(n) / O(1) dans les Listes doublement chaînées. au milieu O(n) Accès à un élément : O(n)\nAvantages Taille dynamique. Insertion/suppression rapides en tête/fin. Inconvénients Accès séquentiel (lent). Plus de mémoire (pointeurs). Exemple réel Un collier de perles où chaque perle est attachée à la suivante.\n🔹 Structures linéaires spécialisées Pile (Stack) Structure LIFO (Last In, First Out). Le dernier élément inséré est le premier retiré.\nSchéma Push(10) → Push(20) → Push(30)\rPile: [30] [20] [10]\rPop() → 30\rstack\nOpérations push(x) : ajouter en haut. pop() : retirer le dernier. peek() : lire le dernier sans le retirer. Complexité Insertion/retrait : O(1) Exemple réel Pile d’assiettes à laver à la main.\nFile (Queue) Structure FIFO (First In, First Out). Le premier élément inséré est le premier retiré.\nSchéma Enqueue(10) → Enqueue(20) → Enqueue(30)\rFile: [10] [20] [30]\rDequeue() → 10\rFile\nOpérations enqueue(x) : ajouter à la fin. dequeue() : retirer au début. peek() : lire le premier sans le retirer. Complexité Insertion/retrait : O(1) Exemple réel File d’attente à la caisse d’un magasin.\nFile de priorité (Priority Queue / Tas / Heap) Une file où chaque élément a une priorité. L’élément avec la plus haute priorité sort en premier. Souvent implémentée avec un tas binaire (heap).\nSchéma (tas min) 10\r/ \\\r20 15\r/ \\\r30 25\rExplication simple\nComplexité Insertion : O(log n) Extraction du min/max : O(log n) Exemple réel Service d’urgence à l’hôpital → les cas graves passent avant.\n🔹 Structures hiérarchiques Arbre (Tree) Une structure hiérarchique composée de nœuds reliés par des arêtes. Chaque nœud a :\nune valeur, des enfants. Schéma (arbre binaire) 10\r/ \\\r5 20\r/ \\ \\\r2 8 30\rTypes Arbre binaire : max 2 enfants. Arbre binaire de recherche (BST) : gauche \u003c racine \u003c droite. Arbres équilibrés (AVL, Red-Black). Complexité (BST équilibré) Recherche, insertion, suppression : O(log n) Exemple réel Arborescence des dossiers/fichiers dans un ordinateur.\nGraphe (Graph) Un ensemble de sommets (nœuds) reliés par des arêtes (liens). Peut être orienté ou non, pondéré ou non.\nSchéma A —— B —— C\r| \\\rD E\rReprésentations Liste d’adjacence. Matrice d’adjacence. Complexité Parcours BFS/DFS : O(V + E) (V = sommets, E = arêtes). Exemple réel Un réseau social (Facebook : personnes = sommets, amitiés = arêtes).\n🔹 Structures de recherche Table de hachage (Hash Table / HashMap) Associe une clé à une valeur via une fonction de hachage.\nSchéma Clé → Hachage → Index → Valeur\r\"Bob\" → h(\"Bob\")=2 → table[2] = 90\rComplexité Insertion/recherche/suppression : O(1) en moyenne. Avantages Accès très rapide. Inconvénients Collisions possibles (deux clés pour le même index). Consomme plus de mémoire. Exemple réel Annuaire téléphonique (nom → numéro).\n📌 Tableau récapitulatif Structure Accès Insertion Suppression Exemple concret Tableau O(1) (index) / O(n) (valeur) O(n) O(n) Sièges d’avion Liste chaînée O(n) O(1) en tête ou fin O(1) en tête Collier de perles Pile (Stack) O(n) O(1) O(1) Pile d’assiettes File (Queue) O(n) O(1) O(1) File d’attente Tas (Heap) O(n) O(log n) O(log n) Urgences hôpital Arbre (BST) O(log n) O(log n) O(log n) Arborescence fichiers Graphe O(V+E) O(1) O(1) Réseau social Hash Table O(1) O(1) O(1) Dictionnaire Dictionnaire et table associative (l’interface Map) 🌼 Une table associative permet de conserver une information associant deux parties nommées clé et valeur. 🌼 Elle est principalement destinée à retrouver la valeur associée à une clé donnée. Les exemples les plus caractéristiques de telles tables sont :\n\t👍 Le dictionnaire : à un mot (clé), on associe une valeur qui est sa définition,\n\t👍 L’annuaire usuel : à un nom (clé), on associe une valeur comportant le numéro de téléphone et, éventuellement, une adresse, \t👍 L’annuaire inversé : à un numéro de téléphone (qui devient la clé), on associe une valeur comportant le nom et, éventuellement, une adresse.",
    "description": "Notion de structure de données Ⓜ️ Le principe de base d’une structure de données, c’est de stocker des éléments auxquels le programmeur veut pouvoir accéder plus tard. On appelle les différentes utilisations possibles de la structure de données des opérations.\nClassification des structures de données 🔹 Structures de base Tableau (array) : Une collection d’éléments de même type stockés en mémoire de façon contiguë. Chaque élément est accessible par son index.",
    "tags": [],
    "title": "Les structures de données",
    "uri": "/420-311/sdd/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util). On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nStructure générale des collections en Java Une collection représente un groupe d’objets, connu par ses éléments. Certaines collections acceptent les doublons, d’autres pas. Certaines sont ordonnées, d’autres pas.\nInterface Collection Depuis la version 1.6 de Java, il y a un changement dans la structure des collections. Il y a eu l’ajout du package java.util.concurrent\nExemples : Besoin d’accès rapide par clé ? → HashMap. Besoin de garder l’ordre trié ? → Arbre. Besoin d’un traitement dans l’ordre d’arrivée ? → File. Vous pourrez généralement vous contenter de connaître les fonctionnalités supplémentaires qu’offre chacune des classes LinkedList, ArrayList, Vector, HashSet, TreeSet, PriorityQueue et ArrayDeque. Mais, dans certains cas, vous devrez avoir quelques notions sur l’architecture d’interfaces employée par les concepteurs de la librairie. Elle se présente comme suit :\nCollection\nList implémentée par LinkedList, ArrayList et Vector Set implémentée par HashSet SortedSet implémentée par TreeSet NavigableSet implémentée par TreeSet (Java 6) Queue (JDK 5.0) implémentée par LinkedList, PriorityQueue Deque (Java 6) implémentée par ArrayDeque, LinkedList L’interface Iterable public interface \u003cE\u003e Collection extends Iterable \u003cE\u003e\rCollection est l’interface racine dans la hiérarchie des collections. Une collection représente un groupe d’objets, connu sous le nom de ses éléments. Certaines collections :\nPermettent de dupliquer les éléments et d’autres pas. Elles sont ordonnées et d’autres pas. Le JDK ne fournit pas directement les implémentations de cette interface : il fournit des implémentations de sous-interfaces plus spécifiques telles que Set et List.\nL’interface List public interface List\u003cE\u003e extends Collection\u003cE\u003e\rUne liste est une collection ordonnée (également connu sous le nom de séquence).\nL’utilisateur de cette interface à un contrôle précis sur l’endroit où est inséré chaque élément dans la liste. L’utilisateur peut accéder aux éléments par leur index (position dans la liste), et rechercher des éléments dans la liste. Les listes permettent généralement les éléments dupliqués. Les listes permettent de multiples éléments nuls. Il n’est pas inconcevable que quelqu’un puisse vouloir mettre en place une liste qui interdit les doublons, par exemple : en lançant des exceptions d’exécution lorsque l’utilisateur tente de les insérer, cet usage est rare.\n🔹 Les listes chaînées - classe LinkedList Exemple\nLinkedList nombres = new LinkedList\u003c\u003e(); // =\u003e // LinkedList\u003cInteger\u003e nombres = new LinkedList\u003c\u003e(); nombres.addFirst(10); nombres.addLast(20); nombres.addLast(30); nombres.addLast(40); nombres.addFirst(50); nombres.removeLast(); nombres.removeFirst(); System.out.println(nombres); System.out.println(nombres.size()); System.out.println(nombres.contains(20)); System.out.println(nombres.indexOf(20)); var tab = nombres.toArray(); System.out.println(Arrays.toString(tab)); //Iterating LinkedList Iterator\u003cInteger\u003e iterator = nombres.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); }\r🔹 ArrayDeque File à deux extrémités (FIFO ou LIFO).\nExemple : File d’impression. import java.util.ArrayDeque; public class ExempleArrayDeque { public static void main(String[] args) { ArrayDeque\u003cString\u003e file = new ArrayDeque\u003c\u003e(); file.add(\"Doc1\"); file.add(\"Doc2\"); file.add(\"Doc3\"); System.out.println(\"Déqueue : \" + file.poll()); } }\rComplexité :\nInsertion/suppression en tête ou fin : O(1). Accès index : O(n). Mémoire : O(n). 🔹 Vector Est un tableau dynamique comme ArrayList, mais synchronisé (donc plus sûr en environnement multithread).\nExemple : Une liste partagée entre plusieurs threads où la sécurité des accès est importante.\nComplexité :\nAccès par index : O(1). Insertion fin : O(1) amorti (redimensionnement si plein). Insertion/suppression au milieu : O(n). Mémoire : O(n) (+ espace supplémentaire pour redimensionnement). import java.util.Vector; public class ExempleVector { public static void main(String[] args) { Vector\u003cString\u003e vecteur = new Vector\u003c\u003e(); vecteur.add(\"Alice\"); vecteur.add(\"Bob\"); vecteur.add(\"Charlie\"); System.out.println(\"Élément à l’index 1 : \" + vecteur.get(1)); vecteur.remove(\"Alice\"); System.out.println(\"Après suppression : \" + vecteur); } }\rComplexité :\nAccès par index : O(1). Insertion fin : O(1) amorti (redimensionnement si plein). Insertion/suppression au milieu : O(n). Mémoire : O(n) (+ espace supplémentaire pour redimensionnement). 🔹 Stack Structure LIFO (dernier entré, premier sorti).\nExemple : Pile d’assiettes. import java.util.Stack; public class ExempleStack { public static void main(String[] args) { Stack\u003cString\u003e pile = new Stack\u003c\u003e(); pile.push(\"A\"); pile.push(\"B\"); pile.push(\"C\"); System.out.println(\"Pop : \" + pile.pop()); System.out.println(\"Sommet : \" + pile.peek()); } }\rComplexité :\nAjout : O(1). Suppression : O(1). lecture sommet : O(1). Mémoire : O(n). Les ensembles (Interface Set) Deux classes principales permettent d’implémenter la notion d’ensemble en Java : HashSet et TreeSet.\nQu’est-ce qu’un ensemble ? Théoriquement, un ensemble est une collection d’éléments uniques, où :\naucun élément ne peut apparaître plusieurs fois, l’ordre des éléments n’a pas d’importance. Ainsi, à chaque fois qu’on insère un nouvel élément dans un HashSet ou un TreeSet, Java vérifie automatiquement que l’élément n’existe pas déjà.\nL’importance de equals, hashCode et compareTo Pour des types simples comme String, File ou les types numériques (Integer, Double…), tout fonctionne naturellement : l’égalité est déjà bien définie.\nEn revanche, pour des objets définis par l’utilisateur, il est souvent nécessaire de redéfinir correctement :\nla méthode equals() (et hashCode()) → pour les ensembles basés sur le hachage, la méthode compareTo() (ou fournir un Comparator) → pour les ensembles basés sur les arbres. 👉 Sans cette redéfinition, deux objets représentant la même valeur mais ayant des références différentes seront considérés comme distincts.\nPourquoi un ordre interne ? Même si, en théorie, un ensemble est “non ordonné”, les concepteurs des collections Java ont dû organiser les données pour rendre les tests d’appartenance (ex. set.contains(x)) efficaces. Sinon, il faudrait parcourir tous les éléments un par un, ce qui coûterait O(n).\nDeux stratégies ont donc été retenues :\n🔹 HashSet Définition : Ensemble non ordonné, sans doublons. Utilise une fonction de hachage pour répartir les éléments dans des cases. Avantage : test d’appartenance, insertion et suppression très rapides → O(1) en moyenne. Inconvénient : les éléments n’ont aucun ordre visible. Exemple : Liste d’étudiants inscrits (pas de doublons). import java.util.HashSet; public class ExempleHashSet { public static void main(String[] args) { HashSet\u003cString\u003e etudiants = new HashSet\u003c\u003e(); etudiants.add(\"Alice\"); etudiants.add(\"Bob\"); etudiants.add(\"Alice\"); // ignoré System.out.println(\"Étudiants : \" + etudiants); } }\rComplexité :\nRecherche : O(1). Insertion : O(1). Suppression : O(1). Mémoire : O(n). 🔹 TreeSet 🌼 La classe TreeSet propose une autre organisation utilisant un “arbre binaire” (arbre binaire de recherche équilibré), lequel permet d’ordonner totalement les éléments. On y utilise, cette fois, la relation d’ordre naturel induite par la méthode compareTo des objets ou par un comparateur (qu’on peut fournir à la construction de l’ensemble).\n🌼 Dans ces conditions, la recherche dans cet arbre d’un élément de valeur donnée est généralement moins rapide que dans une table de hachage, mais plus rapide qu’une recherche séquentielle. On peut montrer que son efficacité est en O(log n). Il est légèrement plus lent qu’un HashSet.\n🌼 Par ailleurs, l’utilisation d’un arbre binaire permet de disposer en permanence d’un ensemble totalement ordonné (trié). On notera d’ailleurs que la classe TreeSet dispose de deux méthodes spécifiques first et last fournissant respectivement le premier et le dernier élément de l’ensemble.\nExemple : Classement des notes. import java.util.TreeSet; public class ExempleTreeSet { public static void main(String[] args) { TreeSet\u003cInteger\u003e notes = new TreeSet\u003c\u003e(); notes.add(85); notes.add(90); notes.add(70); System.out.println(\"Notes triées : \" + notes); } }\rComplexité :\nRecherche : O(log n). Insertion : O(log n). Suppression : O(log n). Mémoire : O(n). Comparaison HashSet : rapide, sans ordre → parfait pour vérifier l’appartenance rapidement. TreeSet : plus lent, mais les éléments sont triés → utile si on veut parcourir l’ensemble dans un ordre précis. Dictionnaire et table associative (l’interface Map) 🌼 Depuis le JDK 5.0, les tables associatives sont génériques, au même titre que les collections, mais elles sont définies par deux paramètres de type (celui des clés, noté généralement K, celui des valeurs, noté généralement V) au lieu d’un.\nImplémentation des Map 🌼 Comme pour les ensembles, l’intérêt des tables associatives est de pouvoir y retrouver rapidement une clé donnée pour en obtenir l’information associée. On va donc tout naturellement retrouver les deux types d’organisation rencontrés pour les ensembles :\n👍 Table de hachage : classe HashMap, 👍 Arbre binaire : classe TreeMap. 🌼 Dans les deux cas, seule la clé sera utilisée pour ordonnancer les informations. 🌼 Dans le premier cas, on se servira du code de hachage des objets formant les clés ; dans le second cas, on se servira de la relation d’ordre induite par compareTo ou par un comparateur fixé à la construction. 🌼 L’accès à un élément d’un HashMap sera en O (1) tandis que celle à un élément d’un TreeMap sera en O (Log N).\n🌼 En contrepartie de leur accès moins rapide, les TreeMap seront (comme les TreeSet) ordonnés en permanence suivant leurs clés.\nPrésentation générale des classes HashMap et TreeMap 🌼 Comme nous l’avons signalé, les classes HashMap et TreeMap n’implémentent plus l’interface Collection, mais une autre interface nommée Map. Ceci provient essentiellement du fait que leurs éléments ne sont plus à proprement parler des objets, mais des “paires” d’objets c’est-à-dire une association entre deux objets.\n👍 Ajout d’information 🌼 La plupart des constructeurs créent une table vide. Pour ajouter une clé à une table, on utilise la méthode put à laquelle on fournit la clé et la valeur associée ; par exemple, si K désigne le type des clés et V celui des valeurs :\n/* création d’une table vide */ HashMap \u003cK, V\u003e m = new HashMap \u003cK, V\u003e () ; /* ajoute à m, un élément associant la clé \"m\" (String) à la valeur 3 (Integer) */ m.put (\"m\", 3) ;\r🌼 Si la clé fournie à put existe déjà, la valeur associée remplacera l’ancienne (une clé donnée ne pouvant figurer qu’une seule fois dans une table). D’ailleurs, put fournit en retour soit l’ancienne valeur si la clé existait déjà, soit nul.\n🌼 Notez que, comme pour les autres collections, les clés et les valeurs doivent être des objets. Il n’est théoriquement pas nécessaire que toutes les clés soient de même type, pas plus que les éléments. En pratique, ce sera presque toujours le cas pour des questions évidentes de facilité d’exploitation de la table.\n👍 Recherche d’information 🌼 On obtient la valeur associée à une clé donnée à l’aide de la méthode get, laquelle fournit nulle si la clé cherchée n’est pas présente (V représente le type de la valeur) :\nV o = get (\"x\") ; // fournit la valeur associée à la clé \"x\" // if (o == null) System.out.println (\"Aucune valeur associée à la clé x\") ;\r🌼 L’efficacité de cette recherche est en O (1) pour HashMap et en O(Log N) pour TreeMap.\n🌼 La méthode containsKey permet de savoir si une clé donnée est présente avec la même efficacité.\n👍 Suppression d’information 🌼 On peut supprimer un élément d’une table en utilisant la méthode remove, laquelle fournit en retour l’ancienne valeur associée si la clé existe ou la valeur null dans le cas contraire :\nV val = remove (cle) ;\t// supprime l’élément (clé + valeur) de clé \"x\" if (val != null) System.out.println (\"On a supprimé l’élément de clé \" + cle + \" et de valeur\" + val);\r🔹 HashMap Associe une clé à une valeur, accès rapide.\nExemple : Dictionnaire (mot → définition). import java.util.HashMap; public class ExempleHashMap { public static void main(String[] args) { Map\u003cString, Integer\u003e notes = new HashMap\u003c\u003e(); notes.put(\"Alice\", 85); notes.put(\"Bob\", 90); System.out.println(\"Note de Bob : \" + notes.get(\"Bob\")); // Parcours des clés/valeurs for (Map.Entry\u003cString, Integer\u003e e : notes.entrySet()) { System.out.println(e.getKey() + \" → \" + e.getValue()); } } }\rComplexité :\nRecherche : O(1) (moyenne), O(n) (pire cas si collisions). Insertion : O(1).* Suppression : O(1). Mémoire : O(n) + surcharge pour les tables de hachage. 🔹 TreeMap Map triée par clés.\nExemple : Carnet d’adresses trié par nom. import java.util.TreeMap; public class ExempleTreeMap { public static void main(String[] args) { TreeMap\u003cString, Integer\u003e carnet = new TreeMap\u003c\u003e(); carnet.put(\"Charlie\", 555123); carnet.put(\"Alice\", 555789); carnet.put(\"Bob\", 555456); System.out.println(\"Carnet trié : \" + carnet); System.out.println(\"Premier : \" + arbre.firstEntry()); System.out.println(\"Dernier : \" + arbre.lastEntry()); } }\rComplexité :\nRecherche : O(log n). Insertion : O(log n). Suppression : O(log n). Mémoire : O(n). 🔹 LinkedHashMap Map qui garde l’ordre d’insertion.\nExemple : Historique de navigation. import java.util.LinkedHashMap; public class ExempleLinkedHashMap { public static void main(String[] args) { LinkedHashMap\u003cInteger, String\u003e historique = new LinkedHashMap\u003c\u003e(); historique.put(1, \"Google\"); historique.put(2, \"YouTube\"); historique.put(3, \"Wikipedia\"); System.out.println(\"Historique : \" + historique); } }\rComplexité :\nRecherche : O(log n). Insertion : O(log n). Suppression : O(log n). Mémoire : O(n). 🔹 LinkedHashSet Définition : Ensemble qui garde l’ordre d’insertion. Exemple : Liste d’achats sans doublons. import java.util.LinkedHashSet; public class ExempleLinkedHashSet { public static void main(String[] args) { LinkedHashSet\u003cString\u003e courses = new LinkedHashSet\u003c\u003e(); courses.add(\"Lait\"); courses.add(\"Pain\"); courses.add(\"Lait\"); // ignoré courses.add(\"Oeufs\"); System.out.println(\"Liste d’achats : \" + courses); } }\rTableau des complexités Structure Accès Insertion Suppression Mémoire HashMap O(1) O(1) O(1) O(n) TreeMap O(log n) O(log n) O(log n) O(n) LinkedHashMap O(1) O(1) O(1) O(n) LinkedList O(n) O(1) tête/fin O(1) tête/fin O(n) ArrayList O(1) index O(1) fin amorti O(n) O(n) Vector O(1) index O(1) fin amorti O(n) O(n) Stack O(n) accès O(1) push O(1) pop O(n) ArrayDeque O(n) accès O(1) tête/fin O(1) tête/fin O(n) HashSet O(1) O(1) O(1) O(n) TreeSet O(log n) O(log n) O(log n) O(n) LinkedHashSet O(1) O(1) O(1) O(n) 🔹 Tas (Heap) (PriorityQueue) import java.util.*; public class ExempleTas { public static void main(String[] args) { PriorityQueue\u003cInteger\u003e tas = new PriorityQueue\u003c\u003e(); tas.add(30); tas.add(10); tas.add(20); // Extrait toujours le plus petit élément System.out.println(\"Min : \" + tas.poll()); // 10 System.out.println(\"Min suivant : \" + tas.poll()); // 20 } }",
    "description": "Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util). On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.",
    "tags": [],
    "title": "Les structures de données en Java ",
    "uri": "/420-311/sdd/javasdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "🌼 Pour coder une liste doublement chaînée en orientée objet, on doit coder :\nLa classe Lien ou Nœud Nous n’allons pas utiliser la notion de générique. La classe Lien ou nœud possède les champs suivants : Suivant de type Lien ou Nœud; Précédent de type Lien ou Nœud; Valeur de type entier. La classe Lien ou nœud possède les méthodes suivantes: Constructeur avec un paramètre qui sera la valeur; Getter/Setter pour les champs; Méthode d’affichage de la valeur. La classe ListeDoublementChainee Les champs de la classe : Premier de type Lien ou Nœud; Dernier de type Lien ou Nœud. Les méthodes: Un constructeur sans paramètres : ou il faut mettre Premier et Dernier à NULL; Une méthode booléenne estVide () : qui teste si Premier est NULL; Une méthode : public void insererEnDebutListe (int valeur) { Déclarer un nouveau Lien et lui passer la valeur en paramètres de la méthode; Si la liste estVide (){ Dernier = nouveauLien; } Sinon { Premier.Precedent = nouveauLien; nouveauLien.suivant = Premier; } Premier = nouveauLien; }\rUne méthode : public void insererEnFinDeListe (int valeur) { Déclarer un nouveauLien et lui passer la valeur en paramètres de la méthode; Si la liste estVide (){ Premier = nouveauLien; } Sinon { Dernier.suivant = nouveauLien; nouveauLien.precedent = Dernier; } Dernier = nouveauLien; }\rpublic boolean insererApresValeur (int valeurPosition, int valeurAInserer) { Lien courant = premier; Tant que (courant.valeur n’est pas égale à valeurPosition){ courant = courant.suivant; si (courant est NULL) { retourner FALSE; } Déclarer un nouveauLien et lui passer la valeurAInserer en paramètres de la méthode; Si (courant = Dernier){ nouveauLien.suivant = null; dernier = nouveauLien; } Sinon { nouveauLien.suivant = courant.suivant; courant.suivant.precedent = nouveauLien; } nouveauLien.precedent = courant; courant.suivant = nouveauLien; retourner true; // on a trouvé, on insére \"valeurAInserer\" } }",
    "description": "🌼 Pour coder une liste doublement chaînée en orientée objet, on doit coder :\nLa classe Lien ou Nœud Nous n’allons pas utiliser la notion de générique. La classe Lien ou nœud possède les champs suivants : Suivant de type Lien ou Nœud; Précédent de type Lien ou Nœud; Valeur de type entier. La classe Lien ou nœud possède les méthodes suivantes: Constructeur avec un paramètre qui sera la valeur; Getter/Setter pour les champs; Méthode d’affichage de la valeur. La classe ListeDoublementChainee Les champs de la classe : Premier de type Lien ou Nœud; Dernier de type Lien ou Nœud. Les méthodes: Un constructeur sans paramètres : ou il faut mettre Premier et Dernier à NULL; Une méthode booléenne estVide () : qui teste si Premier est NULL; Une méthode : public void insererEnDebutListe (int valeur) { Déclarer un nouveau Lien et lui passer la valeur en paramètres de la méthode; Si la liste estVide (){ Dernier = nouveauLien; } Sinon { Premier.Precedent = nouveauLien; nouveauLien.suivant = Premier; } Premier = nouveauLien; }\rUne méthode : public void insererEnFinDeListe (int valeur) { Déclarer un nouveauLien et lui passer la valeur en paramètres de la méthode; Si la liste estVide (){ Premier = nouveauLien; } Sinon { Dernier.suivant = nouveauLien; nouveauLien.precedent = Dernier; } Dernier = nouveauLien; }\rpublic boolean insererApresValeur (int valeurPosition, int valeurAInserer) { Lien courant = premier; Tant que (courant.valeur n’est pas égale à valeurPosition){ courant = courant.suivant; si (courant est NULL) { retourner FALSE; } Déclarer un nouveauLien et lui passer la valeurAInserer en paramètres de la méthode; Si (courant = Dernier){ nouveauLien.suivant = null; dernier = nouveauLien; } Sinon { nouveauLien.suivant = courant.suivant; courant.suivant.precedent = nouveauLien; } nouveauLien.precedent = courant; courant.suivant = nouveauLien; retourner true; // on a trouvé, on insére \"valeurAInserer\" } }",
    "tags": [],
    "title": "Algorithmes codage de la liste doublement chaînée",
    "uri": "/420-311/sdd/linkedlist/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "🌼 Différence entre L’interface Comparator et Comparable\n🌼 Comparator et comparable sont deux interfaces de l’API Java.\n🌼 Il est souvent nécessaire de trier les objets stockés dans des collections ou tableaux (Array). En utilisant ces 02 interfaces, objets Java peuvent être triés dans un ordre prédéfini .\nComparator est défini dans le package java.util Comparable est défini dans le paquet java.lang Comparable 🧭 Un objet implémentant Comparable est capable de se comparer avec un autre objet . La classe elle-même doit implémente l’interface java.lang.Comparable afin de comparer ses instances.\n❓ Quand utiliser l’interface Comparable?\n🧭 Si vous voulez trier une collection d’objets par une propriété particulière par défaut - par exemple: Vous avez une liste d’objets Employé et que vous voulez trier les objets par EmpID par défaut, vous pouvez utiliser comparable .\njava.lang.Comparable: int compareTo(Object obj1) 🥥 Cette méthode compare l’objet en cours à obj1 et retour un entier.\nPositive: l’objet courant est supérieur à obj1 Zéro: l’objet courant est égal à obj1 Négative: l’objet courant est inférieur à obj1 Comparator 🍸 Un objet implémentant l’interface Comparator est capable de comparer deux objets différents. La classe ne compare pas ses instances, mais les instances d’autres classes.\n❓ Quand utiliser interface Comparator?\n🍸 Si vous voulez trier un objet suivant une propriété autre que celle par défaut, vous pouvez utiliser comparateur.\njava.util.Comparator: int compare(Object o1, Object o2) 🥥 Cette méthode compare o1 à o2 et retour un entier.\nPositive: o1 est supérieur à o2 Zéro: o1 est égal à o2 Négative: o1 est inférieur à o2",
    "description": "🌼 Différence entre L’interface Comparator et Comparable\n🌼 Comparator et comparable sont deux interfaces de l’API Java.\n🌼 Il est souvent nécessaire de trier les objets stockés dans des collections ou tableaux (Array). En utilisant ces 02 interfaces, objets Java peuvent être triés dans un ordre prédéfini .\nComparator est défini dans le package java.util Comparable est défini dans le paquet java.lang Comparable 🧭 Un objet implémentant Comparable est capable de se comparer avec un autre objet . La classe elle-même doit implémente l’interface java.lang.Comparable afin de comparer ses instances.",
    "tags": [],
    "title": "Comparable Vs Comparator",
    "uri": "/420-311/sdd/compare/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "Définition Le hachage est une technique qui consiste à transformer une donnée (clé) en un nombre entier appelé code de hachage (hash code). ➡️ Ce nombre sert d’adresse pour placer ou retrouver rapidement la donnée dans une table.\n👉 Exemple simple :\nClé = \"Alice\" Fonction de hachage → produit un entier 12345 Cet entier est utilisé comme position pour stocker la valeur associée. La méthode hashCode() en Java Dans Java, chaque objet hérite de la méthode :\npublic int hashCode()\rCette méthode retourne un entier qui représente l’objet.\nPour que le hachage fonctionne correctement, il faut respecter le contrat :\nSi deux objets sont égaux (equals), ils doivent avoir le même hashCode. Si deux objets ont des hashCode différents → ils sont forcément différents. Si deux objets ont le même hashCode → ils peuvent être égaux ou différents (c’est une collision). Exemple avec HashMap import java.util.HashMap; public class ExempleHashage { public static void main(String[] args) { HashMap\u003cString, Integer\u003e notes = new HashMap\u003c\u003e(); notes.put(\"Alice\", 85); notes.put(\"Bob\", 90); System.out.println(\"Note de Bob : \" + notes.get(\"Bob\")); } }\r➡️ Ici :\n\"Bob\" est passé à une fonction de hachage (hashCode()). Le résultat détermine dans quel compartiment de la HashMap l’élément est stocké. Lorsqu’on fait notes.get(\"Bob\"), Java recalcule le hash et retrouve la valeur. Gestion des collisions Une collision arrive quand deux clés différentes produisent le même hashCode. 👉 Exemple :\n\"AB\" → hashCode = 123 \"BA\" → hashCode = 123 Java doit alors stocker les deux valeurs dans le même compartiment et vérifier avec equals() pour distinguer les objets.\nEfficacité Recherche, insertion, suppression dans une HashMap ou HashSet : O(1) en moyenne. Mais en cas de nombreuses collisions, cela peut devenir O(n) (rare si la fonction de hachage est bien conçue). Exemple personnalisé : redéfinir hashCode() et equals() class Etudiant { String nom; int id; Etudiant(String nom, int id) { this.nom = nom; this.id = id; } @Override public int hashCode() { return id; // simplification } @Override public boolean equals(Object obj) { if (this == obj) return true; if (!(obj instanceof Etudiant)) return false; Etudiant autre = (Etudiant) obj; return this.id == autre.id \u0026\u0026 this.nom.equals(autre.nom); } } public class TestHash { public static void main(String[] args) { HashSet\u003cEtudiant\u003e set = new HashSet\u003c\u003e(); set.add(new Etudiant(\"Alice\", 1)); set.add(new Etudiant(\"Alice\", 1)); // considéré comme identique System.out.println(set.size()); // 1 } }\rComment éviter (ou limiter) les collisions en Java 1. Bien redéfinir hashCode() et equals() Quand on crée ses propres classes (ex. Etudiant, Livre…), il faut s’assurer que :\nhashCode() distribue les objets de manière uniforme dans l’espace des entiers. equals() est cohérent avec hashCode(). 👉 Mauvais exemple (cause de collisions fréquentes) :\n@Override public int hashCode() { return 1; // tous les objets ont le même hash ! }\r👉 Bon exemple :\n@Override public int hashCode() { return Objects.hash(nom, id); }\rDans cet exemple, Objects.hash() combine les champs en générant un hash plus équilibré.\n2. Choisir des champs pertinents Un hashCode() doit utiliser les attributs discriminants de l’objet :\nExemple : pour un étudiant → id et nom. Ne pas se baser sur des valeurs qui changent souvent (risque d’incohérence). 3. Utiliser des nombres premiers Dans l’implémentation manuelle, on recommande souvent de :\nMultiplier par un nombre premier (souvent 31) pour générer un hash plus varié. 👉 Exemple classique :\n@Override public int hashCode() { int result = 17; // nombre premier result = 31 * result + id; result = 31 * result + (nom == null ? 0 : nom.hashCode()); return result; }\r4. Maintenir une bonne taille de table Dans une HashMap, la taille du tableau interne influe sur les collisions :\nTrop petite → collisions fréquentes. Trop grande → gaspillage de mémoire. Java redimensionne automatiquement la HashMap quand elle dépasse un seuil (load factor, par défaut 0.75). Si on compte stocker beaucoup d’éléments, il serait mieux d’initialiser la HashMap avec une capacité suffisante :\nHashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e(10_000);\r5. Utiliser TreeMap ou TreeSet si l’ordre est utile Si l’égalité entre les éléments peut être testée efficacement avec un ordre (compareTo), un TreeSet ou un TreeMap réduit le risque de collisions car ils s’appuient sur des arbres équilibrés (O(log n)) au lieu d’un hash.\nComment Java gère les collisions Avant Java 8 : collisions stockées dans une liste chaînée dans chaque compartiment → O(n) dans le pire cas. Depuis Java 8 : quand une case contient beaucoup d’éléments, la liste devient un arbre rouge-noir → O(log n) dans le pire cas. Résumé (à retenir) Le hachage transforme une clé en un entier (hashCode). Utilisé par HashMap, HashSet, Hashtable. Doit être couplé avec equals() pour distinguer les objets. Très efficace → O(1) en moyenne pour les opérations de recherche et d’insertion. Les collisions sont gérées par des structures internes (listes chaînées, puis arbres rouges-noirs depuis Java 8). Avec le mauvais hashCode, toutes les données vont dans le même compartiment → le HashSet devient une liste chaînée → temps d’insertion beaucoup plus long.\nAvec le bon hashCode, les données sont bien réparties → temps d’insertion rapide (O(1) en moyenne).\nPour éviter les collisions : Toujours redéfinir hashCode() et equals() correctement. Utiliser des champs discriminants et stables. Combiner les champs avec des nombres premiers. Ajuster la capacité initiale de la HashMap si besoin. S’appuyer sur les collections triées (TreeSet, TreeMap) si un ordre est préférable.",
    "description": "Définition Le hachage est une technique qui consiste à transformer une donnée (clé) en un nombre entier appelé code de hachage (hash code). ➡️ Ce nombre sert d’adresse pour placer ou retrouver rapidement la donnée dans une table.\n👉 Exemple simple :\nClé = \"Alice\" Fonction de hachage → produit un entier 12345 Cet entier est utilisé comme position pour stocker la valeur associée. La méthode hashCode() en Java Dans Java, chaque objet hérite de la méthode :",
    "tags": [],
    "title": "📖 Le hachage",
    "uri": "/420-311/sdd/hachage/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "Étude de cas 1 Étude de cas Soit les classes suivantes avec leurs attributs successives : Classe Compagnie assurance :\nnuméro de la compagnie (unique), nom de compagnie, liste assurances : une collection d’assurances de type List. Classe Assurance : code d’assurance (unique), nom de l’assurance, prix de l’assurance, type d’assurance (Habitation, Auto ou Vie). Écrire en Java un programme qui permet la gestion de la compagnie d’assurance. Dans ce programme vous devez coder les méthodes suivantes: Afficher le chiffre d’affaires total de la compagnie (somme totale des assurances). Afficher l’inventaire (la liste des assurances) de la compagnie triée en ordre décroissant de prix d’assurance (du plus grand vers le plus petit). Convertir la liste lue en une collection de type Map (Integer, Assurance). Trier la Map par clé (numéro d’assurance). Parcourir la liste des assurances et modifier les prix des assurances comme suit : Augmenter le prix de l’assurance habitation de 10% Diminuer le prix d’assurance auto de 8% Diviser le prix de l’assurance vie par : 3 si le code d’assurance est impair. 4 si le code d’assurance est pair. Étude de cas 2 La classe Compte possède les attributs suivants :\nnumCompte nom solde Objectif Mettre en pratique les notions liées aux collections Java :\nList Set Map Vous devez coder les méthodes suivantes :\n🔹 List Nom de la méthode Description addCompteToList Permet de rajouter une instance de la classe Compte dans une collection de type List. findCompte Permet de rechercher une instance de la classe Compte dans une collection de type List. deleteCompte Permet de supprimer une instance de la classe Compte dans une collection de type List. emptyList Permet de vider complètement une collection de type List. sortList Permet de trier une collection de type List. 🔹 Set Nom de la méthode Description addCompteToSet Permet de rajouter une instance de la classe Compte dans une collection de type Set. findCompte Permet de rechercher une instance de la classe Compte dans une collection de type Set. deleteCompte Permet de supprimer une instance de la classe Compte dans une collection de type Set. emptySet Permet de vider complètement une collection de type Set. sortSet Permet de trier une collection de type Set. 🔹 Map Nom de la méthode Description addCompteToMap Permet de rajouter une instance de la classe Compte dans une collection de type Map. findCompte Permet de rechercher une instance de la classe Compte dans une collection de type Map. deleteCompte Permet de supprimer une instance de la classe Compte dans une collection de type Map. emptyMap Permet de vider complètement une collection de type Map. sortMap Permet de trier une collection de type Map. ✅ À faire Coder les méthodes précédentes. Utiliser JUnit pour tester toutes les méthodes.",
    "description": "Étude de cas 1 Étude de cas Soit les classes suivantes avec leurs attributs successives : Classe Compagnie assurance :\nnuméro de la compagnie (unique), nom de compagnie, liste assurances : une collection d’assurances de type List. Classe Assurance : code d’assurance (unique), nom de l’assurance, prix de l’assurance, type d’assurance (Habitation, Auto ou Vie). Écrire en Java un programme qui permet la gestion de la compagnie d’assurance. Dans ce programme vous devez coder les méthodes suivantes: Afficher le chiffre d’affaires total de la compagnie (somme totale des assurances). Afficher l’inventaire (la liste des assurances) de la compagnie triée en ordre décroissant de prix d’assurance (du plus grand vers le plus petit). Convertir la liste lue en une collection de type Map (Integer, Assurance). Trier la Map par clé (numéro d’assurance). Parcourir la liste des assurances et modifier les prix des assurances comme suit : Augmenter le prix de l’assurance habitation de 10% Diminuer le prix d’assurance auto de 8% Diviser le prix de l’assurance vie par : 3 si le code d’assurance est impair. 4 si le code d’assurance est pair. Étude de cas 2 La classe Compte possède les attributs suivants :",
    "tags": [],
    "title": "📝 Exercices : Collections en Java",
    "uri": "/420-311/sdd/exercicessdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Complexité algorithmique",
    "content": "Qu’est-ce que la complexité algorithmique ? La complexité algorithmique désigne en informatique la quantité de ressources qu’un algorithme consomme lors de son exécution (On utilise Grand O pour décrire la performance d’une algorithme). Elle se décline en deux dimensions principales :\nLa complexité temporelle, qui mesure le temps d’exécution. La complexité spatiale, qui évalue la mémoire supplémentaire requise en dehors des données d’entrée. Ces deux aspects sont indépendants : un algorithme peut être très rapide mais consommer beaucoup de mémoire, ou inversement.\nPour bien évaluer un algorithme, il faut examiner son comportement dans différents contextes :\nle meilleur cas, le pire cas (souvent privilégié pour anticiper les situations extrêmes), et le cas moyen, qui reflète son usage habituel. Comparer la complexité de plusieurs algorithmes résolvant le même problème permet ainsi de choisir la solution la plus adaptée en fonction des contraintes de performance.\nComment et pourquoi mesurer la complexité ? Pour mesurer la complexité d’un algorithme, on utilise la notation Big O, écrite sous la forme O(f(n)). Elle exprime la croissance du temps ou de la mémoire nécessaires en fonction de la taille de l’entrée, généralement notée n.\nLe but de cette notation est de mettre en évidence le comportement asymptotique : comment l’algorithme évolue lorsque n devient très grand. On ignore donc les détails secondaires (constantes et termes mineurs) pour ne retenir que le terme dominant. Par exemple, une complexité exacte de 3n² + 5n + 7 se résume en O(n²), puisque n² domine pour de grandes valeurs de n.\nUn programme qui fonctionne n’est pas forcément efficace.\nExemple concret :\nRechercher un mot dans un dictionnaire papier (O(log n)). Rechercher une photo dans une pile désordonnée (O(n)). Plus les données sont grosses, plus le choix de l’algorithme est critique.\nNotation Big-O (pire cas) La notation Big-O décrit comment le temps d’exécution évolue en fonction de la taille de l’entrée (n).\nComplexité Exemple Interprétation O(1) Accès à un tableau par index Constant O(log n) Recherche binaire Logarithmique : croissance lente O(n) Parcours d’une liste Linéaire O(n log n) Tri rapide/merge sort Plus rapide que O(n²) O(n²) Doubles boucles imbriquées Quadratique : explose vite O(2^n) Problèmes combinatoires Exponentielle : impraticable 💡 Règle d’or :\nPour n petit, toutes les méthodes semblent rapides. Pour n grand, seules les bonnes structures/algorithmes tiennent la route. Exemples en Java 🔹 O(1) – Affichage simple public static void affiche(int[] tab) { // O(1) System.out.println(tab[0]); }\rAussi :\npublic static void affiche(int[] tab) { // O(2) qui sera simplifée à O(1) System.out.println(tab[0]); System.out.println(tab[1]); }\r🔹 O(n) – Boucle (itération sur tous les élements) public static void afficheTableau(int[] tab) { // O(n) for (int num : tab) { System.out.println(num); } }\rMême chose pour les boucles for, while et do while\n🔹 O(n ^ 2) – Boucle inbriquée public static void afficheTableau2D(int[] tab) { // O(n ^ 2) for (int num1 : tab) { for (int num2 : tab) { System.out.println(num1 * num2); } } }\r🔹 O(log n) – Recherche binaire ⚠️ Nécessite un tableau trié.\npublic static boolean rechercheBinaire(int[] tab, int val) { int g = 0, d = tab.length - 1; while (g \u003c= d) { int m = (g + d) / 2; if (tab[m] == val) return true; if (tab[m] \u003c val) g = m + 1; else d = m - 1; } return false; }\rSi nous cherchant dans un tableau d’un million d’éléments, 19 comparaisons seront suffusantes pour trouver l’élément recherché.\n🔹 Comparaison avec des exemples import java.util.*; public class Bench { public static void main(String[] args) { int n = 1_000_000; int[] tab = new int[n]; for (int i = 0; i \u003c n; i++) tab[i] = i; int cible = n - 1; // Recherche linéaire long t1 = System.nanoTime(); rechercheLineaire(tab, cible); long t2 = System.nanoTime(); System.out.println(\"Lineaire : \" + (t2 - t1) / 1_000_000.0 + \" ms\"); // Recherche binaire long t3 = System.nanoTime(); rechercheBinaire(tab, cible); long t4 = System.nanoTime(); System.out.println(\"Binaire : \" + (t4 - t3) / 1_000_000.0 + \" ms\"); } public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) if (x == val) return true; return false; } public static boolean rechercheBinaire(int[] tab, int val) { int g = 0, d = tab.length - 1; while (g \u003c= d) { int m = (g + d) / 2; if (tab[m] == val) return true; if (tab[m] \u003c val) g = m + 1; else d = m - 1; } return false; } }\rOn peut dire que :\nUn algorithme linéaire, qui met une seconde à traiter un tableau à 100 éléments, mettra 100 secondes à traiter un tableau à 10 000 éléments. Un algorithme quadratique qui met également une seconde à traiter le cas d’un tableau à 100 éléments mettra 10 000 secondes (soit près de trois heures) à traiter le cas du tableau à 10 000 éléments. Un algorithme en O(2n) qui mettrait aussi une seconde avec 100 éléments qui mettrait 2100 secondes à traiter ne serait-ce que 200 éléments, soit environ 4.1022 années (4000 milliards de milliards d’années). Analyse de boucles Boucle simple for (int i=0; i\u003cn; i++) → O(n). Boucles imbriquées for i, for j → O(n²). Boucle divisant par 2 while (n \u003e 1) n/=2 → O(log n). Complexité spatiale (mémoire) La complexité spatiale (ou complexité mémoire) mesure la quantité de mémoire nécessaire pour exécuter un algorithme en fonction de la taille de l’entrée (n).\n💡 On ne parle pas seulement de la mémoire des données initiales, mais aussi :\nde la mémoire supplémentaire utilisée par l’algorithme (variables, structures temporaires, pile d’appels).\nO(1) : pile, file, liste chaînée → mémoire proportionnelle aux données. O(n) : tableau de n éléments. O(n²) : matrice d’adjacence pour un graphe. Exemple 1 : Complexité spatiale O(1)\npublic static void afficheTableau(int[] tab) { // O(1) space for (int num : tab) { System.out.println(num); } }\rExemple 2 : Complexité spatiale O(n)\npublic static void afficheTableau(int[] tab) { // O(n) space (c'est l'espace qu'on a alloué à l'iterieur de cette méthode) int[] tabCopy = new int[tab.length]; for (int num : tab) { System.out.println(num); } }\rExemple 3 : Complexité spatiale O(n) (récursion)\npublic static int factoriel(int n) { // O(n) space if (n == 0) return 1; return n * factoriel(n - 1); }\rExercices Quelle est la complexité de :\nfor (int i=0; i\u003cn; i++) for (int j=0; j\u003cn; j++) System.out.println(i + \",\" + j);\rQuelle est la complexité de :\nfor (int i=0; i\u003cn; i*=2) System.out.println(i);\rQuelle est la complexité spatiale d’un tableau int[1000][1000] ?\nFiche synthèse Complexité temporelle → combien de temps ça prend.\nComplexité spatiale → combien de mémoire ça utilise.\nParfois, il faut choisir :\nMoins de temps mais plus de mémoire (ex. table de hachage).\nMoins de mémoire mais plus de temps (ex. recherche linéaire dans une liste).\nOn utilise la notion grand O (Big O) pour mesurer la complexité :\nO(1) : accès direct. O(log n) : recherche dichotomique, arbres équilibrés. O(n) : parcours d’une collection. O(n log n) : tris efficaces. O(n²) : algorithmes naïfs à doubles boucles. O(2^n) : problèmes combinatoires → à éviter.",
    "description": "Qu’est-ce que la complexité algorithmique ? La complexité algorithmique désigne en informatique la quantité de ressources qu’un algorithme consomme lors de son exécution (On utilise Grand O pour décrire la performance d’une algorithme). Elle se décline en deux dimensions principales :\nLa complexité temporelle, qui mesure le temps d’exécution. La complexité spatiale, qui évalue la mémoire supplémentaire requise en dehors des données d’entrée. Ces deux aspects sont indépendants : un algorithme peut être très rapide mais consommer beaucoup de mémoire, ou inversement.",
    "tags": [],
    "title": "Complexité algorithmique",
    "uri": "/420-311/complexalgo/complexalgo/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Ressources utiles",
    "content": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsqu’un contributeur a réalisé une modification qui est prête à l’envoyer, il pousse (push) celle-ci vers le dépôt. Le dépôt garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version décentralisé. Il y a 2 dépôts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez récupérer le code de votre repository (dépôt remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configuré la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de déposer les modifications sur une dépôt local. Il faut également être vigilant au niveau de la branche utilisé pour le commit. De plus, il est important de mettre souvent à jour la branche avant de procéder à un commit.\nLorsqu’on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour référer à la tâche en cours. Après cet identifiant, on peut y mettre une description. Par exemple:\n“PRJ-3428: Ajout de tests unitaires sur la méthode du service getClients”\nLorsqu’on relie l’identifiant et les commits, on peut alors connaître le travail effectué dans le code pour une tâche donnée dans le système de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandé de faire un git fetch / pull avant de procéder à celui-ci. À moins d’être seul dans ce repository et/ou la branche visée.\nGit Fetch, checkout, pull La commande git fetch permet de mettre à jour notre dépôt local en récupérant l’ état courant qui remote. La commande git checkout permet de les appliquer à la copie de travail (et donc de les voir).\nLa commande git pull fait les deux à la fois.\nPensez à vous mettre à jour avant chaque session de travail !\nC’est la première chose qu’un développeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaître l’état courant de vos copies locales (les modifications ont-elles été commitées, les fichiers ajoutés, les commit pushé).\nLes interface graphiques (dont intelliJ) vous l’indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectué. Ces commit peuvent être fort utili pour faire d’autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet d’appliquer les changements (fusionner) d’une autre branche à votre branche sélectionnée dans votre repository locale. Il y a souvent des conflits lors d’une fusion. Surtout si vous avez travailler dans un même fichier qu’un ou une de vos collègues.\nVous devez tenter de résoudre les conflits avec des outils en ligne de commande ou à l’aide d’un interface graphique. C’est une habilité à acquérir avec le temps. C’est parfois très complexe et si l’opération n’est pas effectée avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste à changer la base de votre branche d’un commit vers un autre, donnant l’illusion que vous avez créé votre branche à partir d’un commit différent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder l’état actuel de votre répertoire de travail. C’est possible de le faire avec git stash et de revenir à un répertoire de travail propre sans ces modifications. Vous pourrez ensuite récupérer ce travail en utilisant le nom que vous lui aurez donné. Vous pouvez en avoir plusieurs sauvegardés dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// Récupérer les changements précédents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalité si vous avez terminé.\nNe pas prendre les branches pour plusieurs fonctionnalités. Séparez vos tâches en plus petites et faites des commits plus souvent.\nRécupérer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre équipe vos intentions! Ne travaillez pas sur les mêmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillé sur une fonctionnalité ou un fix.\nAvant le jour de la mise en production. Vous devriez créer une branche à partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visée vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les éléments. Testez que votre branche fonctionne et qu’elle est bien compilée. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront déjà été résolus! Bingo.\nGitflow Pour maintenir une certain cohésion en entreprise, un modèle de branche a été proposé. Il implique de séparer les branches de développement et les branches primaires qui sont déployés dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRéférence Richard E. Silverman (2013), Git Pocket Guide, O’Reilly\nAlice Jacquot, Introduction à Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-311/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e IO",
    "content": "📖 Le format JSON 1. Définition JSON est un format de texte standardisé pour représenter et échanger des données. Inspiré de JavaScript, mais indépendant du langage : tous les langages modernes (Java, Python, C#, PHP, etc.) peuvent le lire et l’écrire. Lisible par les humains, facile à traiter par les machines. 2. Structure du JSON Le JSON est composé de deux structures principales :\nObjet (Object) → une collection de paires clé–valeur\n{ \"nom\": \"Alice\", \"age\": 23, \"etudiant\": true }\rTableau (Array) → une liste ordonnée de valeurs\n[\"Java\", \"Python\", \"C++\"]\r3. Types de valeurs autorisés String : chaîne de caractères Number : entier ou décimal Boolean : true ou false Null : valeur nulle Object : { ... } Array : [ ... ] Exemple combinant plusieurs types :\n{ \"nom\": \"Bob\", \"age\": 25, \"competences\": [\"Java\", \"SQL\", \"Git\"], \"actif\": true, \"adresse\": { \"ville\": \"Montréal\", \"codePostal\": \"H2X 1Y4\" } }\rExemple avec Jackson En Java, on peut manipuler JSON avec des bibliothèques comme Jackson ou Gson.\nExemple Objet Java → JSON et JSON → Objet Java import com.fasterxml.jackson.databind.ObjectMapper; public class ExempleJackson1 { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); Client client = new Client(12345, \"Dupont\", \"Alice\", 2500.75); // Conversion Objet → JSON String json = mapper.writeValueAsString(client); System.out.println(\"Objet vers JSON : \" + json); } }\rRésultat attendu :\n{\"numCompte\":12345,\"nom\":\"Dupont\",\"prenom\":\"Alice\",\"solde\":2500.75}\rString donnees = \"{\\\"numCompte\\\":98765,\\\"nom\\\":\\\"Martin\\\",\\\"prenom\\\":\\\"Bob\\\",\\\"solde\\\":1500.0}\"; // Conversion JSON → Objet Client client1 = mapper.readValue(donnees, client.class); System.out.println(\"Client : \" + client1.getNom() + \" \" + client1.getPrenom() + \", Compte : \" + client1.getNumCompte() + \", Solde : \" + client1.getSolde());\rRésultat attendu :\nClient : Martin Bob, Compte : 98765, Solde : 1500.0\rLecture/écriture de fichier JSON // Écriture dans un fichier mapper.writeValue(new FileInputStream(\"client.json\"), client); // Lecture depuis un fichier Client client2 = mapper.readValue(new FileInputStream(\"client.json\"), Client.class); System.out.println(\"Nom lu depuis fichier : \" + client2.getNom());\rtableau JSON String jsonArray = \"[{\\\"numCompte\\\":111,\\\"nom\\\":\\\"Durand\\\",\\\"prenom\\\":\\\"Paul\\\",\\\"solde\\\":3000.0},\" + \"{\\\"numCompte\\\":222,\\\"nom\\\":\\\"Moreau\\\",\\\"prenom\\\":\\\"Sophie\\\",\\\"solde\\\":4500.5}]\"; Client[] clients = mapper.readValue(jsonArray, Client[].class); for (Client c : clients) { System.out.println(c.getNumCompte() + \" - \" + c.getNom() + \" \" + c.getPrenom() + \" : \" + c.getSolde()); } // créer un fichier json avec liste de clients List\u003cClient\u003e listeClients = Arrays.asList(clients); // créer un fichier json avec liste de clients mapper.writeValue(new FileOutputStream(\"clients.json\"), listeClients); List\u003cClient\u003e clientsLus = mapper.readValue(new FileInputStream(\"clients.json\"), new TypeReference\u003cList\u003cClient\u003e\u003e() {});\rRésultat attendu :\n111 - Durand Paul : 3000.0\r222 - Moreau Sophie : 4500.5\r5. Avantages du JSON ✅ Lisible et léger ✅ Standard universel (API, configuration, échanges de données) ✅ Facile à convertir en objet dans la plupart des langages ✅ Support natif dans JavaScript (et simple en Java avec des bibliothèques) 6. Comparaison JSON vs XML Aspect JSON XML Lisibilité Plus simple, léger Verbeux, balises lourdes Types natifs String, Number, Boolean, etc. Tout est texte Usage APIs REST, stockage léger Données hiérarchiques complexes 7. Cas d’utilisation typiques Communication entre client (front-end) et serveur (back-end) → APIs REST Stockage léger de configurations (config.json, package.json) Bases de données NoSQL (MongoDB utilise JSON comme format natif → BSON) Résumé JSON = format texte universel pour représenter des objets et des tableaux. Clés toujours entre guillemets (\"clé\"). Valeurs : string, number, boolean, null, object, array. Très utilisé dans les APIs web et les bases NoSQL. En Java → bibliothèques populaires : Gson, Jackson.",
    "description": "📖 Le format JSON 1. Définition JSON est un format de texte standardisé pour représenter et échanger des données. Inspiré de JavaScript, mais indépendant du langage : tous les langages modernes (Java, Python, C#, PHP, etc.) peuvent le lire et l’écrire. Lisible par les humains, facile à traiter par les machines. 2. Structure du JSON Le JSON est composé de deux structures principales :\nObjet (Object) → une collection de paires clé–valeur",
    "tags": [],
    "title": "Format JSON",
    "uri": "/420-311/io/jsonformat/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Objectifs généraux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de données.\nÉvaluer et comparer la complexité algorithmique des opérations (temps et mémoire).\nUtiliser des fils d’exécution (threads) pour exécuter plusieurs tâches en parallèle.\nDévelopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi étudier les structures de données ? Parce qu’elles sont au cœur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de données.\nParce qu’elles permettent de réduire le temps d’exécution et économiser de la mémoire.\nParce qu’elles développent la capacité à choisir la bonne approche selon un problème donné.\nParce qu’elles forment une base solide pour les cours ultérieurs et pour travailler dans des projets d’envergure.\nCitation classique : « Un bon algorithme mal implanté dans une mauvaise structure de données sera inefficace. Une bonne structure de données peut transformer un problème complexe en une solution élégante. »\n🌼 Notion de structure de données Le principe de base d’une structure de données, c’est de stocker des éléments auxquels le programmeur veut pouvoir accéder plus tard. On appelle les différentes utilisations possibles de la structure de données des opérations.\n🌼 Les structures de données en Java Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util).\nOn y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nNous commencerons par examiner les concepts communs qu’elles (structures de données) exploitent ainsi : généricité, itérateur, ordonnancement et relation d’ordre.\nNous verrons également quelles sont les opérations qui leur sont communes : ajout ou suppression d’éléments, construction à partir des éléments d’une autre collection…\nNous étudierons ensuite en détail chacune de ces structures, à savoir :\n🗝 Les listes, implémentées par la classe LinkedList;\r🗝 Les vecteurs dynamiques, implémentés par les classes ArrayList et Vector;\r🗝 Les ensembles, implémentés par les classes HashSet et TreeSet;\r🗝 Les queues avec priorité, implémentées par la classe PriorityQueue (introduite par le JDK 5.0) ;\r🗝 Les queues à double entrée, implémentées par la classe ArrayDeque (introduite par Java6).",
    "description": "Objectifs généraux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de données.\nÉvaluer et comparer la complexité algorithmique des opérations (temps et mémoire).\nUtiliser des fils d’exécution (threads) pour exécuter plusieurs tâches en parallèle.\nDévelopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi étudier les structures de données ? Parce qu’elles sont au cœur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de données.",
    "tags": [],
    "title": "Structures de donnée",
    "uri": "/420-311/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e IO",
    "content": "Définition L’API I/O (Input/Output) de Java permet de gérer les flux de données (streams), c’est-à-dire la lecture (Input) et l’écriture (Output) de données vers :\nle clavier et l’écran (console), les fichiers (texte ou binaire), le réseau, la mémoire. Tout en Java I/O est basé sur la notion de flux.\nLes flux (Streams) Un flux est une séquence d’octets ou de caractères qui circule entre une source (input) et une destination (output).\nTypes de flux Flux de bytes (8 bits) → pour les fichiers binaires (images, sons, etc.)\nInputStream (lecture) OutputStream (écriture) Flux de caractères (16 bits) → pour les fichiers texte (compatibles Unicode)\nReader (lecture) Writer (écriture) Les classes de lecture et d’écriture Hiérarchie principale Pour les bytes : FileInputStream / FileOutputStream BufferedInputStream / BufferedOutputStream Pour les caractères : FileReader / FileWriter BufferedReader / BufferedWriter PrintWriter Les classes de lecture : Reader, InputStreamReader, FileReader et BufferedReader Reader est la classe abstraite pour la lecture des flux de caractères.\nElle met en œuvre les méthodes fondamentales suivantes :\nread() : lit un caractère unique. read(char[]) : lit un tableau de caractères. skip(long) : ignore certains caractères. close() : ferme le flux. InputStreamReader est un pont entre les flux d’octets et les flux de caractères.\nIl convertit des octets en caractères à l’aide d’un jeu de caractères spécifié (charset).\nLe jeu de caractères peut être celui par défaut du système d’exploitation,\nou être spécifié explicitement lors de la création d’un InputStreamReader. FileReader est une classe pratique pour lire des fichiers texte en utilisant\nle codage de caractères par défaut du système d’exploitation.\nBufferedReader lit le texte d’un flux de caractères avec efficacité\n(les caractères sont mis en mémoire tampon pour éviter de lire fréquemment le flux sous-jacent).\nFournit une méthode pratique pour lire une ligne de texte : readLine(). Le diagramme suivant montre la relation de ces classes de lecture dans le package java.io.\nReader\r|_ InputStreamReader\r| |_ FileReader\r|_ BufferedReader Les classes d’écriture : Writer, OutputStreamWriter, FileWriter et BufferedWriter Writer est la classe abstraite pour l’écriture de flux de caractères.\nElle met en œuvre les méthodes fondamentales suivantes :\n👍 write(int) : écrit un seul caractère. 👍 write(char[]) : écrit un tableau de caractères. 👍 write(String) : écrit une chaîne de caractères. 👍 close() : ferme le flux. OutputStreamWriter est un pont entre les flux d’octets et les flux de caractères.\nLes caractères sont codés en octets à l’aide d’un jeu de caractères spécifié.\n👍 Le jeu de caractères peut être celui par défaut du système d’exploitation,\nou être spécifié explicitement lors de la création d’un OutputStreamWriter. FileWriter est une classe pratique pour écrire des fichiers texte\nen utilisant le codage de caractères par défaut du système d’exploitation.\nBufferedWriter écrit du texte dans un flux de caractères avec efficacité\n(les caractères, tableaux et chaînes sont mis en mémoire tampon pour éviter d’écrire trop souvent sur le flux sous-jacent).\n👍 Fournit une méthode pratique pour écrire un séparateur de ligne : newLine(). Le diagramme suivant montre la relation de ces classes d’écriture dans le package java.io.\nWriter\r|_ OutputStreamWriter\r| |_ FileWriter\r|_ BufferedWriter Exemples Exepmle de lecture d’un fichier texte import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class LectureFichier { public static void main(String[] args) { try (BufferedReader br = new BufferedReader(new FileReader(\"test.txt\"))) { String ligne; while ((ligne = br.readLine()) != null) { System.out.println(ligne); } } catch (IOException e) { e.printStackTrace(); } } }\rDans cet exemple, BufferedReader lit un fichier texte ligne par ligne.\nExepmle d’écriture dans un fichier texte import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; public class EcritureFichier { public static void main(String[] args) { try (BufferedWriter bw = new BufferedWriter(new FileWriter(\"sortie.txt\"))) { bw.write(\"Bonjour, monde !\"); bw.newLine(); bw.write(\"Deuxième ligne.\"); } catch (IOException e) { e.printStackTrace(); } } }\rDans cet exemple, BufferedWriter permet d’écrire efficacement dans un fichier.\n6. Exemple : copier un fichier binaire (image) import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class CopierFichier { public static void main(String[] args) { try (FileInputStream in = new FileInputStream(\"image.png\"); FileOutputStream out = new FileOutputStream(\"copie.png\")) { byte[] buffer = new byte[1024]; int bytesLus; while ((bytesLus = in.read(buffer)) != -1) { out.write(buffer, 0, bytesLus); } } catch (IOException e) { e.printStackTrace(); } } }\r➡️ Utilise un buffer pour optimiser la lecture/écriture d’un fichier binaire.\n7. Entrées/sorties standard System.in → flux d’entrée standard (clavier). System.out → flux de sortie standard (console). System.err → flux d’erreurs. Exemple :\nimport java.util.Scanner; public class ExempleIO { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\"Entrez votre nom : \"); String nom = sc.nextLine(); System.out.println(\"Bonjour \" + nom); } }\r8. Sérialisation d’objets L’API I/O permet aussi de sauvegarder des objets avec ObjectOutputStream et ObjectInputStream.\nimport java.io.*; import java.util.ArrayList; public class SauvegardeObjets { public static void main(String[] args) { try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"data.ser\"))) { ArrayList\u003cString\u003e liste = new ArrayList\u003c\u003e(); liste.add(\"Alice\"); liste.add(\"Bob\"); out.writeObject(liste); } catch (IOException e) { e.printStackTrace(); } } }\r9. Résumé Input/Output = gestion des flux (bytes ou caractères). Lecteurs/Écrivains (Reader/Writer) → texte. InputStream/OutputStream → données binaires. Toujours utiliser des buffers pour optimiser les performances. Penser à fermer les flux (close() ou try-with-resources).",
    "description": "Définition L’API I/O (Input/Output) de Java permet de gérer les flux de données (streams), c’est-à-dire la lecture (Input) et l’écriture (Output) de données vers :\nle clavier et l’écran (console), les fichiers (texte ou binaire), le réseau, la mémoire. Tout en Java I/O est basé sur la notion de flux.\nLes flux (Streams) Un flux est une séquence d’octets ou de caractères qui circule entre une source (input) et une destination (output).",
    "tags": [],
    "title": "📖 L’API Java I/O (Input / Output)",
    "uri": "/420-311/io/javaapi/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Ressources utiles",
    "content": "Maven (Project Managment Tool) Creation d’un projet maven: Pour créer un projet maven on suit les étape suivantes :\nDans IntelliJ cliquer sur create new project. Cette fois-ci ne pas choisir java mais maven. Vous pouvez cocher la case Create from archetype. Vous pouvez choisir maven-archetype-quickstart (dans notre cas pas besoin on va configurer notre projet par nous même). cliquez sur next. Vous pouvez spécifier le nom de votre projet, ça location. Vous pouves cliquer sur la flèche vers le bas pour afficher les champs qui permettent d’identifier notre programme de façon unique (comme un UID). Il est conseiller de les garder comme suggèrer sauf si vous voulez un nom différent pour votre application. Cliquez sur next. cliquez sur finish. Un projet avec la structure suivante sera créé. Il faut respecter cette structure pour vos prochains projets avec maven. Affichier la fenêtre maven Ici vous pouvez observer les .jar (dépendances télechargés) dans la section dependencies (une fois que vous avez ajouter au moins une dépendance, la section apparait).\nVous pouvez forcer le téléchargement des dépendances comme suit : Configurer l’exécution avec maven Dans edit configuration ajouter une configuration et choisir au lieu application cette fois-ci maven. L’onglet runner vous permet de spécifier la version SDK au runtime, vous pouvez la changer si ce n’est pas celle à laquelle que vous avez besoin.\nAssuerz vous que votre version de compilateur dans pom.xml est compatible avec votre version au runtime.\nVisualisation des dépendences (graphique) Visulaliser le dépendances de votre projet maven\nLes liens Maven 1. Modèle du projet Maven pour la recherche dans Eclipse ou IntelliJ maven-archetype-quickstart\rorg.apache.maven.archetypes:maven-archetype-quickstart\r2. Lien vers maven repository 3. Comment créer un projet Maven dans Eclipse 4. Les dépendances utiles 🌼 Dépendance FasterXml pour les Jsons\n\u003cdependency\u003e\r\u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e\r\u003cartifactId\u003ejackson-core\u003c/artifactId\u003e\r\u003cversion\u003e2.15.2\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e\r\u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e\r\u003cversion\u003e2.15.2\u003c/version\u003e\r\u003c/dependency\u003e\rjackson-core : gère la lecture et l’écriture de flux JSON (bas niveau).\njackson-databind : permet de convertir automatiquement un objet Java en JSON (sérialisation) et un JSON en objet Java (désérialisation). 👉 Exemple :\nObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(monObjet); // Objet → JSON MonObjet obj = mapper.readValue(json, MonObjet.class); // JSON → Objet\r🌼 Dépendance JUNIT 5 – Tests unitaires\n\u003cdependency\u003e\r\u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e\r\u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e\r\u003cversion\u003e5.11.0\u003c/version\u003e\r\u003cscope\u003etest\u003c/scope\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e\r\u003cartifactId\u003ejunit-jupiter-params\u003c/artifactId\u003e\r\u003cversion\u003e5.11.0\u003c/version\u003e\r\u003cscope\u003etest\u003c/scope\u003e\r\u003c/dependency\u003e\rjunit-jupiter-api : fournit les annotations et l’API pour écrire des tests (@Test, @BeforeEach, etc.).\njunit-jupiter-params : permet de créer des tests paramétrés (tester plusieurs valeurs d’entrée avec un seul test). 👉 Exemple :\n@Test void additionTest() { assertEquals(4, 2 + 2); }\r🌼 Dépendance Apache Commons Lang \u003cdependency\u003e\r\u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e\r\u003cartifactId\u003ecommons-lang3\u003c/artifactId\u003e\r\u003cversion\u003e3.17.0\u003c/version\u003e\r\u003c/dependency\u003e\rAjoute des utilitaires pour manipuler les chaînes de caractères, nombres, dates et objets.\nFacilite des opérations répétitives comme StringUtils.isEmpty() ou RandomStringUtils.randomAlphanumeric().\n👉 Exemple :\nif (StringUtils.isBlank(nom)) { throw new IllegalArgumentException(\"Le nom ne peut pas être vide\"); }\r🌼 Dépendance Apache Commons IO\n\u003cdependency\u003e\r\u003cgroupId\u003ecommons-io\u003c/groupId\u003e\r\u003cartifactId\u003ecommons-io\u003c/artifactId\u003e\r\u003cversion\u003e2.16.1\u003c/version\u003e\r\u003c/dependency\u003e\rFournit des utilitaires pour travailler avec les fichiers, flux et chemins.\nSimplifie les lectures/écritures et la copie de fichiers.\n👉 Exemple :\nString contenu = FileUtils.readFileToString(new File(\"data.txt\"), StandardCharsets.UTF_8);\r🌼 Dépendance Project Lombok\n\u003cdependency\u003e\r\u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e\r\u003cartifactId\u003elombok\u003c/artifactId\u003e\r\u003cversion\u003e1.18.34\u003c/version\u003e\r\u003cscope\u003eprovided\u003c/scope\u003e\r\u003c/dependency\u003e\rGénére automatiquement du code répétitif (getters, setters, constructeurs, toString…) grâce à des annotations.\nRéduit la verbosité dans les classes Java. 👉 Exemple :\n@Data // génère getters, setters, equals, hashCode, toString @AllArgsConstructor public class Etudiant { private int id; private String nom; }\r🌼 Dépendance Driver MariaDB\n\u003cdependency\u003e\r\u003cgroupId\u003eorg.mariadb.jdbc\u003c/groupId\u003e\r\u003cartifactId\u003emariadb-java-client\u003c/artifactId\u003e\r\u003cversion\u003e3.4.1\u003c/version\u003e\r\u003c/dependency\u003e\rPermet de connecter une application Java à une base MariaDB/MySQL via JDBC.\n👉 Exemple :\nConnection conn = DriverManager.getConnection( \"jdbc:mariadb://localhost:3306/maBase\", \"user\", \"password\" );\r🌼 Dépendance Itext pdf\n\u003cdependency\u003e\r\u003cgroupId\u003ecom.itextpdf\u003c/groupId\u003e\r\u003cartifactId\u003eitextpdf\u003c/artifactId\u003e\r\u003cversion\u003e5.5.13.3\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003ecom.lowagie\u003c/groupId\u003e\r\u003cartifactId\u003eitext\u003c/artifactId\u003e\r\u003cversion\u003e2.1.7\u003c/version\u003e\r\u003c/dependency\u003e\ritextpdf : créer et manipuler des fichiers PDF.\ncom.lowagie:itext : ancienne version, encore utilisée dans certains projets pour la compatibilité.\n👉 Exemple :\nDocument doc = new Document(); PdfWriter.getInstance(doc, new FileOutputStream(\"fichier.pdf\")); doc.open(); doc.add(new Paragraph(\"Bonjour PDF !\")); doc.close();\r🌼 Dépendance Java MAIL\n\u003cdependency\u003e\r\u003cgroupId\u003ecom.sun.mail\u003c/groupId\u003e\r\u003cartifactId\u003ejavax.mail\u003c/artifactId\u003e\r\u003cversion\u003e1.6.0\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003ejavax.activation\u003c/groupId\u003e\r\u003cartifactId\u003eactivation\u003c/artifactId\u003e\r\u003cversion\u003e1.1.1\u003c/version\u003e\r\u003c/dependency\u003e\rjavax.mail : envoi et réception de mails via SMTP, POP3, IMAP.\nactivation : permet de gérer les pièces jointes (MIME types).\n👉 Exemple :\nMimeMessage message = new MimeMessage(session); message.setSubject(\"Bonjour\"); message.setText(\"Ceci est un test !\"); Transport.send(message);\r🌼 Dépendance Google ZXing – Code-barres / QR codes\n\u003cdependency\u003e\r\u003cgroupId\u003ecom.google.zxing\u003c/groupId\u003e\r\u003cartifactId\u003ecore\u003c/artifactId\u003e\r\u003cversion\u003e3.5.2\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003ecom.google.zxing\u003c/groupId\u003e\r\u003cartifactId\u003ejavase\u003c/artifactId\u003e\r\u003cversion\u003e3.5.2\u003c/version\u003e\r\u003c/dependency\u003e\rcore : librairie principale pour générer et lire des codes-barres/QR codes.\njavase : intégration avec Java standard (Image I/O, BufferedImage).\n👉 Exemple :\nQRCodeWriter qrCodeWriter = new QRCodeWriter(); BitMatrix matrix = qrCodeWriter.encode(\"Hello\", BarcodeFormat.QR_CODE, 200, 200); MatrixToImageWriter.writeToPath(matrix, \"PNG\", Path.of(\"qr.png\"));\r🌼 Fix to slf4j (Simple Logger)\n\u003cdependency\u003e\r\u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e\r\u003cartifactId\u003eslf4j-simple\u003c/artifactId\u003e\r\u003cversion\u003e1.7.21\u003c/version\u003e\r\u003c/dependency\u003e\rslf4j-simple : fournit une implémentation simple de SLF4J (Simple Logging Facade for Java).\nSert à afficher des logs dans la console sans config lourde (utile en dev).\n👉 Exemple :\nprivate static final Logger logger = LoggerFactory.getLogger(MaClasse.class); logger.info(\"Application démarrée\"); logger.error(\"Une erreur est survenue\");",
    "description": "Maven (Project Managment Tool) Creation d’un projet maven: Pour créer un projet maven on suit les étape suivantes :\nDans IntelliJ cliquer sur create new project. Cette fois-ci ne pas choisir java mais maven. Vous pouvez cocher la case Create from archetype. Vous pouvez choisir maven-archetype-quickstart (dans notre cas pas besoin on va configurer notre projet par nous même). cliquez sur next.",
    "tags": [],
    "title": "Maven",
    "uri": "/420-311/ressourcesutiles/maven/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Complexité algorithmique",
    "content": "🔹 Exercice 1 : for (int i = 0; i \u003c n; i++) { System.out.println(i); }\r👉 Quelle est la complexité temporelle en fonction de n ?\n🔹 Exercice 2 while (n \u003e 1) { n = n / 2; }\r👉 Quelle est la complexité temporelle ?\n🔹 Exercice 3 public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) { if (x == val) return true; } return false; }\r👉 Quelle est la complexité temporelle dans le pire cas ?\n🔹Exercice 4 public static void insertionSort(int[] tab) { for (int i = 1; i \u003c tab.length; i++) { int cle = tab[i]; int j = i - 1; while (j \u003e= 0 \u0026\u0026 tab[j] \u003e cle) { tab[j+1] = tab[j]; j--; } tab[j+1] = cle; } }\r👉 Quelle est la complexité dans le meilleur cas et dans le pire cas ?\n🔹Exercice 5 Classez les algorithmes suivants du plus rapide au plus lent quand n devient très grand :\nO(n²) O(n log n) O(n) O(log n) 🔹Exercice 6 Vous avez ce code :\nfor (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j *= 2) { System.out.println(i + \",\" + j); } }\r👉 Quelle est la complexité de cet algorithme ? Expliquez.\n🔹Exercice 7 public static int somme(int[] tab) { int total = 0; for (int n : tab) { total += n; } return total; }\r👉 Question : Quelle est la complexité spatiale de cette méthode ? Justifiez votre réponse.\n🔹Exercice 8 public static int[] doubleTableau(int[] tab) { int[] resultat = new int[tab.length]; for (int i = 0; i \u003c tab.length; i++) { resultat[i] = tab[i] * 2; } return resultat; }\r👉 Question : Combien de mémoire supplémentaire est utilisée par rapport à la taille de l’entrée n ?\n🔹Exercice 9 int[][] matrice = new int[n][n];\r👉 Question : Quelle est la complexité spatiale de cette structure ?\n🔹Exercice 10 On veut calculer la suite de Fibonacci :\nVersion récursive simple :\npublic static int fib(int n) { if (n \u003c= 1) return n; return fib(n - 1) + fib(n - 2); }\rVersion avec mémoïsation :\npublic static int fibMemo(int n, int[] memo) { if (memo[n] != 0) return memo[n]; if (n \u003c= 1) return n; memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo); return memo[n]; }\r👉 Questions :\nQuelle est la complexité spatiale des deux versions ? Pourquoi la version avec mémoïsation consomme plus de mémoire mais gagne en temps ? 🔹Exercice 11 : Écrivez un programme qui :\nCréez un tableau de 1 million d’entiers. Créez une LinkedList et un ArrayList chacun contenant 1 million d’entiers. Comparez la mémoire consommée (avec Runtime.getRuntime().totalMemory() - freeMemory()) pour chaque structure. Observer concrètement l’impact de la structure choisie sur la mémoire. Que remarquez vous ?",
    "description": "🔹 Exercice 1 : for (int i = 0; i \u003c n; i++) { System.out.println(i); }\r👉 Quelle est la complexité temporelle en fonction de n ?\n🔹 Exercice 2 while (n \u003e 1) { n = n / 2; }\r👉 Quelle est la complexité temporelle ?\n🔹 Exercice 3 public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) { if (x == val) return true; } return false; }\r👉 Quelle est la complexité temporelle dans le pire cas ?",
    "tags": [],
    "title": "📝 Exercices sur complexité algorithmique",
    "uri": "/420-311/complexalgo/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-311/categories/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Ressources utiles",
    "content": "Nommage des Packages Le nom d’un package doit respecter les conventions suivantes :\nTout en minuscule. Utiliser seulement [a-z], [0-9] et le point ‘.’ *Ne pas utiliser de tiret ‘-’, d’Under score ‘_’, d’espace, ou d’autres caractères ($, , accents, …). Remarque :\nLa convention d’Oracle indique que tout package doit avoir comme root un des packages suivants : com, edu, gov, mil, net, org. Ex : com.monprojet.bean\nNommage des Classes et Interfaces Le nom d’une classe doit respecter les conventions suivantes :\n1re lettre en majuscule. Mélange de minuscules, majuscule avec la première lettre de chaque mot en majuscule. Donner des noms simples et descriptifs. Éviter les acronymes. Remarque :\nN’utiliser que les lettres [a-z] et [A-Z] et [0-9] *Ne pas utiliser de tiret ‘-’, d’Under score ‘_’, ou d’autres caractères ($, , accents, …). Nommage des Variables Le nom d’une variable doit respecter les conventions suivantes :\n1re lettre en minuscule. Mélange de minuscules, majuscule avec la première lettre de chaque mot en majuscule. Donner des noms simples et descriptifs. Ne pas commencer les noms avec ‘$’ ou ‘_’ bien que ce soit possible. Variable d’une seule lettre (pour un usage local : variable de méthode) int : i, j, k, m, et n char : c, d, et e Remarque :\nN’utiliser que les lettres [a-z] et [A-Z] et [0-9] *Ne pas utiliser de tiret ‘-’, d’Under score ‘_’, ou d’autres caractères ($, , accents …). Nommage des Constantes Le nom d’une constante doit respecter les conventions suivantes :\nTout en majuscule. Séparer les mots par Under score ‘_’. Donner des noms simples et descriptifs. Remarque :\nN’utiliser que les lettres [A-Z], [0-9] et ‘_’ : *Ne pas utiliser de tiret ‘-’ ou d’autres caractères ($, , accents …).",
    "description": "Nommage des Packages Le nom d’un package doit respecter les conventions suivantes :\nTout en minuscule. Utiliser seulement [a-z], [0-9] et le point ‘.’ *Ne pas utiliser de tiret ‘-’, d’Under score ‘_’, d’espace, ou d’autres caractères ($, , accents, …). Remarque :\nLa convention d’Oracle indique que tout package doit avoir comme root un des packages suivants : com, edu, gov, mil, net, org. Ex : com.monprojet.bean\nNommage des Classes et Interfaces Le nom d’une classe doit respecter les conventions suivantes :",
    "tags": [],
    "title": "Convention de programmation et de nommage",
    "uri": "/420-311/ressourcesutiles/javaconv/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Genericity",
    "content": "🔹 Introduction 🌼 Le terme générique est un concept introduit dans Java depuis la version 5.\nLa généricité (ou generics) en Java permet de créer des classes, interfaces et méthodes paramétrées par des types.\n👉 Cela signifie qu’on peut écrire du code réutilisable et indépendant du type exact des objets manipulés.\n🌼 L’ensemble de la famille Collection est basé sur les génériques pour la sécurité de type.\n🌼 Les génériques permettent aux types (classes et interfaces) d’être des paramètres lors de la définition de classes, d’interfaces et de méthodes.\nSans généricité : on manipule souvent des Object et on doit faire du casting.\nAvec généricité : on précise le type attendu, et le compilateur assure la sécurité des types.\n🌼 Les paramètres de type générique vous permettent de réutiliser le même code avec des entrées différentes.\n🔹 Type générique 🌼 Un type générique est une classe ou une interface paramétrée sur des types.\n🌼 Nous utilisons des crochets angulaires (\u003c\u003e) pour spécifier le paramètre type. Nous pouvons définir nos propres classes avec le type générique.\nclass NomClasse\u003cT1, T2, T3, ... , Tn\u003e { /* ... */ }\r🌼 La section de paramètre type, délimitée par des crochets (\u003c\u003e), suit le nom de la classe. Cela spécifie les paramètres de type (également appelés variables de type) T1, T2, … et Tn.\n🔹 Exemple simple : une boîte (Box) Sans généricité class Box { private Object contenu; public void setContenu(Object contenu) { this.contenu = contenu; } public Object getContenu() { return contenu; } } // Utilisation Box b = new Box(); b.setContenu(\"Bonjour\"); String texte = (String) b.getContenu(); // ⚠️ Il faut caster\r⚠️ Problème : si on met un Integer mais qu’on cast en String, cela provoque une ClassCastException.\nAvec généricité class Box\u003cT\u003e { private T contenu; public void setContenu(T contenu) { this.contenu = contenu; } public T getContenu() { return contenu; } } // Utilisation Box\u003cString\u003e b = new Box\u003c\u003e(); b.setContenu(\"Bonjour\"); String texte = b.getContenu(); // ✅ Pas de cast nécessaire\rDans cete exemple, T est un paramètre de type. Lors de l’utilisation, on précise Box\u003cString\u003e, donc T = String.\n🔹 Conventions de nommage des paramètres de type 🌼 Par convention, les noms de paramètre de type sont des lettres simples majuscules.\n🌼 Les conventions de dénomination des paramètres de type sont importantes pour apprendre les génériques de manière approfondie.\n🌼 Les noms de paramètre de type les plus couramment utilisés sont :\nE : Element ( largement utilisé par les collections Java) K: Key N: Number T: Type V : Value S, U, V etc. 2nd, 3rd, 4th types 🔹 Les collections et la généricité En Java, toutes les collections (List, Set, Map, etc.) utilisent la généricité.\nList\u003cString\u003e noms = new ArrayList\u003c\u003e(); noms.add(\"Alice\"); noms.add(\"Bob\"); String premier = noms.get(0); // ✅ pas besoin de cast\rSans généricité, List stockait des Object et obligeait au cast. Avec généricité, on gagne en sécurité et en lisibilité.\n🔹 Méthodes génériques 🌼 Les méthodes génériques sont des méthodes qui introduisent leurs propres paramètres de type.\n🌼 Ceci est similaire à la déclaration d’un type générique, mais la portée du paramètre type est limitée à la méthode où il est déclaré.\n🌼 Les méthodes génériques statiques et non statiques sont autorisées, ainsi que les constructeurs de classes génériques.\npublic class Util { public static \u003cT\u003e void afficher(T element) { System.out.println(element); } } // Utilisation Util.afficher(\"Hello\"); // String Util.afficher(123); // Integer Util.afficher(3.14); // Double\rDans cet exemple, \u003cT\u003e indique que la méthode est générique et peut recevoir n’importe quel type.\n🔹 Les bornes (extends / super) On peut restreindre les types autorisés.\nExemple : extends class BoiteNombre\u003cT extends Number\u003e { private T valeur; public BoiteNombre(T valeur) { this.valeur = valeur; } public double doubleValue() { return valeur.doubleValue(); } } // Utilisation BoiteNombre\u003cInteger\u003e b1 = new BoiteNombre\u003c\u003e(5); BoiteNombre\u003cDouble\u003e b2 = new BoiteNombre\u003c\u003e(3.14); // BoiteNombre\u003cString\u003e b3 = new BoiteNombre\u003c\u003e(\"texte\"); ❌ Erreur\rExemple : super Permet de travailler avec des super-types. Utile dans les méthodes avec collections (principe PECS : Producer Extends, Consumer Super) : Si la collection produit des éléments → on utilise extends. Si la collection consomme des éléments → on utilise super.\nimport java.util.*; public class DemoPECS { public static void afficherNombres(List\u003c? extends Number\u003e nombres) { for (Number n : nombres) { System.out.println(n); } } public static void main(String[] args) { List\u003cInteger\u003e entiers = Arrays.asList(1, 2, 3); List\u003cDouble\u003e doubles = Arrays.asList(3.14, 2.71); afficherNombres(entiers); // OK afficherNombres(doubles); // OK } }\rDans cet exemple, List\u003c? extends Number\u003e accepte une liste de Integer, Double, etc. Mais ⚠️ on ne peut pas ajouter d’éléments dans la liste (sauf null) car on ne connaît pas le type exact.\nimport java.util.*; public class DemoPECS { public static void ajouterEntiers(List\u003c? super Integer\u003e liste) { liste.add(10); liste.add(20); // liste.add(3.14); // ❌ impossible car pas sûr que ce soit accepté } public static void main(String[] args) { List\u003cInteger\u003e entiers = new ArrayList\u003c\u003e(); List\u003cNumber\u003e nombres = new ArrayList\u003c\u003e(); List\u003cObject\u003e objets = new ArrayList\u003c\u003e(); ajouterEntiers(entiers); // OK ajouterEntiers(nombres); // OK ajouterEntiers(objets); // OK } }\rDans cet exemple, List\u003c? super Integer\u003e accepte une List, List ou List. On peut donc y insérer des Integer en toute sécurité.\n🔹 Avantages de la généricité 1. Sécurité des types (Contrôles de type au moment de la compilation) ▶️ Un compilateur Java applique une vérification de type stricte au code générique et génère des erreurs si le code viole la sécurité du type → plus de ClassCastException au runtime. ▶️ Il est plus facile de corriger les erreurs de compilation que de réparer les erreurs d’exécution, qui peuvent être difficiles à trouver.\n2. Réutilisabilité ▶️ On écrit une seule classe ou méthode pour plusieurs types.\n3. Lisibilité ▶️ on sait immédiatement quel type est attendu.\n🔹 Inconvénients des génériques ◀️ Impossible d’instancier des types génériques avec des types primitifs Les génériques ne fonctionnent qu’avec des types objets, pas avec les types primitifs (int, double, char, etc.) -\u003e Solution : utiliser les classes enveloppes (Integer, Double, Character, etc.).\n◀️ Impossible de créer des instances de paramètres de type On ne peut pas écrire :\nclass Box\u003cT\u003e { private T contenu; public Box() { contenu = new T(); // ❌ Erreur } }\r◀️ Impossible de déclarer des champs statiques dont les types sont des paramètres de type Le paramètre générique T n’existe qu’au niveau instance, pas au niveau classe statique.\n❌ Exemple invalide :\nclass Box\u003cT\u003e { private static T contenu; // ❌ Erreur }\r◀️ Impossible d’utiliser des casts ou des instancesof avec des types paramétrés Java utilise l’effacement de types (type erasure). Cela signifie que List et List deviennent la même chose à l’exécution : juste List.\n❌ Exemple invalide :\nList\u003cString\u003e liste = new ArrayList\u003c\u003e(); if (liste instanceof List\u003cString\u003e) { // ❌ Erreur ... }\rOn peut tester uniquement la forme brute (raw type).\nif (liste instanceof List) { // ✅ System.out.println(\"C'est bien une liste !\"); }\r◀️ Impossible de créer des tableaux de types paramétrés ❌ Exemple invalide :\nList\u003cString\u003e[] tableau = new ArrayList\u003cString\u003e[10]; // ❌ Erreur\rCar cela provoquerait des problèmes de compatibilité (ex. : insérer un List par erreur) -\u003e Solution : utiliser des collections (List\u003cList\u003e) ou faire un cast avec précaution.\nList\u003cList\u003cString\u003e\u003e tableau = new ArrayList\u003c\u003e(); tableau.add(new ArrayList\u003c\u003e()); tableau.get(0).add(\"Bonjour\");\rIci, au lieu d’un tableau, on utilise une collection de collections.\n◀️ Impossible de créer, d’attraper ou de lancer des objets de types paramétrés On ne peut pas utiliser un type paramétré dans une exception, car les exceptions doivent être déterminées au moment de la compilation.\n❌ Exemple invalide :\nclass MyException\u003cT\u003e extends Exception { } // ❌ Erreur\rEt on ne peut pas non plus :\ntry { // ... } catch (T e) { // ❌ Impossible ... }\rLien vers la documentation Oracle\n🎯 Exemple récapitulatif // Méthode générique qui retourne le plus grand élément d'une liste public static \u003cT extends Comparable\u003cT\u003e\u003e T max(List\u003cT\u003e liste) { T max = liste.get(0); for (T elem : liste) { if (elem.compareTo(max) \u003e 0) { max = elem; } } return max; } // Utilisation List\u003cInteger\u003e entiers = Arrays.asList(3, 7, 2, 9, 5); System.out.println(max(entiers)); // 9\rRéflexions sur les génériques 🌼 Le code générique nous permet de créer du code polyvalent et réutilisable qui peut fonctionner avec n’importe quel type en fonction de nos contraintes spécifiées. Cela minimise la duplication de code et transmet son objectif de manière plus abstraite.\n🌼 Cependant, les génériques ne sont pas sans défauts. En Java, les génériques sont définitivement une fonctionnalité essentielle. Mais pour être honnête, leur mise en œuvre peut parfois sembler alambiquée et insuffisante, surtout par rapport à d’autres langages.\n🌼 Pour les développeurs utilisant des API génériques, celles-ci sont généralement simples à utiliser et offrent des fonctionnalités substantielles.\n🌼 En revanche, l’écriture d’API génériques peut s’avérer plus difficile. Personnellement, j’apprécie l’idée de créer des outils puissants, mais complexes pour écrire du code sans imposer le même niveau de complexité à ceux qui utilisent le code.\n🌼 Les concepteurs de langage doivent toujours faire des compromis et décider de leur priorité absolue. Et dans la bonne tradition Java, la rétrocompatibilité était une priorité absolue.\nLien vers statistiques langages de programmation 2024",
    "description": "🔹 Introduction 🌼 Le terme générique est un concept introduit dans Java depuis la version 5.\nLa généricité (ou generics) en Java permet de créer des classes, interfaces et méthodes paramétrées par des types.\n👉 Cela signifie qu’on peut écrire du code réutilisable et indépendant du type exact des objets manipulés.\n🌼 L’ensemble de la famille Collection est basé sur les génériques pour la sécurité de type.\n🌼 Les génériques permettent aux types (classes et interfaces) d’être des paramètres lors de la définition de classes, d’interfaces et de méthodes.",
    "tags": [],
    "title": "La généricité en Java",
    "uri": "/420-311/genericity/javagen/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-311/tags/index.html"
  }
]
