var relearn_searchindex = [
  {
    "breadcrumb": "Structures de donnée",
    "content": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "tags": [],
    "title": "Préalables",
    "uri": "/420-311/intro/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Rappel : Concepts de base Classe : Modèle définissant les attributs (variables) et comportements (méthodes).\nObjet : Instance concrète d’une classe.\nEncapsulation : Protéger les données via des modificateurs d’accès (private, public, protected) et exposer des méthodes d’accès (getters/setters).\nAbstraction : Masquer les détails d’implémentation et ne montrer que les fonctionnalités essentielles (via classes abstraites et interfaces).\nHéritage : Une classe peut hériter des attributs et méthodes d’une autre (mot-clé extends).\nPolymorphisme :\nSurcharge (overloading) : même nom de méthode, signatures différentes. Redéfinition (overriding) : une sous-classe redéfinit le comportement d’une méthode héritée. Constructeur : Méthode spéciale exécutée lors de la création d’un objet (new).\nModificateurs d’accès Modificateur Même classe Même package Sous-classe Partout public ✅ ✅ ✅ ✅ protected ✅ ✅ ✅ ❌ (default) ✅ ✅ ❌ ❌ private ✅ ❌ ❌ ❌ Syntaxe essentielle Définir une classe public class Voiture { private String marque; private int annee; public Voiture(String marque, int annee) { this.marque = marque; this.annee = annee; } public void demarrer() { System.out.println(marque + \" démarre !\"); } }\rCréer un objet Voiture v1 = new Voiture(\"Toyota\", 2022); v1.demarrer();\rHéritage et polymorphisme class Animal { public void parler() { System.out.println(\"??\"); } } class Chien extends Animal { @Override public void parler() { System.out.println(\"Woof\"); } } Animal a = new Chien(); // polymorphisme a.parler(); // \"Woof\"\rAbstraction et interfaces abstract class Forme { abstract double aire(); } class Cercle extends Forme { private double r; Cercle(double r) { this.r = r; } @Override double aire() { return Math.PI * r * r; } } interface Volant { void voler(); } class Avion implements Volant { public void voler() { System.out.println(\"En vol ✈️\"); } }\rClasses utiles Object : classe racine de toutes les classes Java. Méthodes importantes : toString(), equals(), hashCode(), clone().\nfinal :\nfinal class : non-héritée. final method : non-redéfinissable. final variable : constante. Gestion mémoire Les objets sont créés sur le tas (heap) via new. Le garbage collector libère automatiquement la mémoire des objets non référencés. Bonnes pratiques Utiliser private pour protéger les données. Toujours redéfinir toString() pour représenter un objet. Respecter la cohérence equals() / hashCode(). Favoriser la composition plutôt que l’héritage trop profond. Documenter avec JavaDoc (/** … */). Exemple : package s01; class Etudiant { private String nom; private int age; public Etudiant(String nom, int age) { this.nom = nom; this.age = age; } public void afficherInfos() { System.out.println(\"Nom : \" + nom + \", Âge : \" + age); } } class EtudiantRegulier extends Etudiant { private String programme; public EtudiantRegulier(String nom, int age, String programme) { super(nom, age); this.programme = programme; } @Override public void afficherInfos() { super.afficherInfos(); System.out.println(\"Programme : \" + programme); } } public class RappelPOO { public static void main(String[] args) { EtudiantRegulier e = new EtudiantRegulier(\"Alice\", 20, \"Informatique\"); e.afficherInfos(); } }",
    "description": "Rappel : Concepts de base Classe : Modèle définissant les attributs (variables) et comportements (méthodes).\nObjet : Instance concrète d’une classe.\nEncapsulation : Protéger les données via des modificateurs d’accès (private, public, protected) et exposer des méthodes d’accès (getters/setters).\nAbstraction : Masquer les détails d’implémentation et ne montrer que les fonctionnalités essentielles (via classes abstraites et interfaces).\nHéritage : Une classe peut hériter des attributs et méthodes d’une autre (mot-clé extends).",
    "tags": [],
    "title": "Révision",
    "uri": "/420-311/intro/revisionpoo/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Questions théoriques Question 1 : Quel est le résultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le résultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le résultat du code suivant:\npublic class Question3 { public static void main(String[]args) { int val1 = 9; int val2 = 9; String str = \"9\"; System.out.println(val1 + val2 + str);\t} }\rQuestion 4 : Quel est le résultat du code suivant:\npublic class Question4 { public static void main(String[]args) { try { int a, b; b = 0; a = 5 / b; System.out.print(\"A\"); } catch (Exception e) { System.out.print(\"B\"); } finally { System.out.print(\"C\"); }\t} }\rQuestion 5 : Quel est le résultat du code suivant:\npublic class Question5 { public static void main(String[]args) { String obj = \"Bonjour\"; String obj1 = \"Bonsoir\"; String obj2 = \"Bonjour\"; System.out.println(obj.equals(obj1) + \" \" + obj.equals(obj2)); } }\rQuestion 6 : Quel est le résultat du code suivant:\npublic class ClasseA { public int i; public int j; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.j = 3; System.out.println(i + \" \" + j); } } public class Question6 { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 7 : Quel est le résultat du code suivant:\npublic class ClasseA { public int i; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.i = j + 1; System.out.println ( j + \" \" + i); } } public class Main { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 8 : Quel est le résultat du code suivant:\npublic class Question8{ public static void main(String[] args) { String s = \"Hello World\"; int A = s.indexOf('o'); int B = s.lastIndexOf('l'); System.out.println(A + \" \" + B); } }\rQuestion 9 : Quel est le résultat du code suivant:\npublic class Question9{ public static void main(String[] args) { char ch; ch = \"hello\".charAt(1); System.out.println(ch); } }\rQuestion 10 : Quel est le résultat du code suivant:\npublic class Question10{ public static void main(String[] args) { String chars[] = {\"a\", \"b\", \"c\", \"a\", \"c\"}; for (int i = 0; i \u003c chars.length; ++i) for (int j = i + 1; j \u003c chars.length; ++j) if(chars[i].compareTo(chars[j]) == 0) System.out.print(chars[j]); } }\rQuestion 11 : Quel est le résultat du code suivant:\npublic class Question11{ public static void main(String[] args) { int a1[] = new int[10]; int a2[] = { 1, 2, 3, 4, 5 }; System.out.println(a1.length + \" \" + a2.length); } }\rQuestion 12 : Quel est le résultat du code suivant:\npublic class Question12{ public static void main(String[] args) { int arr[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i \u003c arr.length - 2; ++i) System.out.print(arr[i] + \" \"); } }\rQuestion 13 : Quel est le résultat du code suivant:\npublic class Question13{ public static int param1; public static int param2; public void add(int a, int b) { param1 = a + b; param2 = param1 + b; } public static void main(String args[]) { Question13 obj1 = new Question13(); Question13 obj2 = new Question13(); int a = 2; obj1.add(a, a + 1); obj2.add(5, a); System.out.println(obj1.param1 + \" \" + obj2.param2); } }\rQuestion 14 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question14{ public static void main(String[] args) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 15 : Quel est le résultat du code suivant:\npublic class Question15{ public static int param1; public void increment() { param1++; } public static void main(String args[]) { Question15 obj1 = new Question15(); Question15 obj2 = new Question15(); obj1.param1 = 0; obj1.increment(); obj2.increment(); System.out.println(obj1.param1 + \" \" + obj2.param1); } }\rQuestion 16 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question16 { public static void main(String args[]) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 17 : Quel est le résultat du code suivant:\npublic class Question17 { public static void main(String[] args) { ClasseB classeB = new ClasseB(); System.out.println(\"Valeur = \" + classeB.calculer(3, 6)); } } class ClassA { final public int calculer(int a, int b) { return 0; } } class ClasseB extends ClasseA { public int calculer(int a, int b) { return 1; } }\rQuestion 18 : Quel est le résultat du code suivant:\npublic class Question18 { public static void main (String args[]) { int param1, param2= 1; param1= 10; if (param1!= 10 \u0026\u0026 param1/ 0 == 0) { System.out.println(param2); } else { System.out.println(++param2); } } }\rQuestion 19 : Quel est le résultat du code suivant:\npublic class Question19 { public static int param1; public static int param2; public void add(int val1, int val2) { param1 = val1 + val2; param2 = param1 + val2; } public static void main(String[] args) { Question19 instance1 = new Question19 (); Question19 instance2 = new Question19 (); Question19 instance3 = new Question19 (); int abc = 2;\tinstance1.add(abc, abc-1); instance3.add(6, 6/abc); instance2.add(5, abc/2); System.out.println(instance1.param1); System.out.println(instance2.param2); } }\rQuestion 20 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question20 { public static void main(String args[]) { int array[] = new int [5]; for (int i = 5; i \u003e 0; i--) { array[5 - i] = i; } Arrays.sort(array); System.out.print(Arrays.toString(array)); } }",
    "description": "Questions théoriques Question 1 : Quel est le résultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le résultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le résultat du code suivant:",
    "tags": [],
    "title": "Questions et exercices",
    "uri": "/420-311/intro/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code d’événement dans le bandeau supérieur Quiz 2 : méthodes et interfaces Quiz Wooclap sur les méthodes et les interfaces",
    "description": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code d’événement dans le bandeau supérieur Quiz 2 : méthodes et interfaces Quiz Wooclap sur les méthodes et les interfaces",
    "tags": [],
    "title": "Quiz",
    "uri": "/420-311/intro/quiz/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Ressources utiles",
    "content": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsqu’un contributeur a réalisé une modification qui est prête à l’envoyer, il pousse (push) celle-ci vers le dépôt. Le dépôt garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version décentralisé. Il y a 2 dépôts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez récupérer le code de votre repository (dépôt remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configuré la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de déposer les modifications sur une dépôt local. Il faut également être vigilant au niveau de la branche utilisé pour le commit. De plus, il est important de mettre souvent à jour la branche avant de procéder à un commit.\nLorsqu’on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour référer à la tâche en cours. Après cet identifiant, on peut y mettre une description. Par exemple:\n“PRJ-3428: Ajout de tests unitaires sur la méthode du service getClients”\nLorsqu’on relie l’identifiant et les commits, on peut alors connaître le travail effectué dans le code pour une tâche donnée dans le système de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandé de faire un git fetch / pull avant de procéder à celui-ci. À moins d’être seul dans ce repository et/ou la branche visée.\nGit Fetch, checkout, pull La commande git fetch permet de mettre à jour notre dépôt local en récupérant l’ état courant qui remote. La commande git checkout permet de les appliquer à la copie de travail (et donc de les voir).\nLa commande git pull fait les deux à la fois.\nPensez à vous mettre à jour avant chaque session de travail !\nC’est la première chose qu’un développeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaître l’état courant de vos copies locales (les modifications ont-elles été commitées, les fichiers ajoutés, les commit pushé).\nLes interface graphiques (dont intelliJ) vous l’indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectué. Ces commit peuvent être fort utili pour faire d’autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet d’appliquer les changements (fusionner) d’une autre branche à votre branche sélectionnée dans votre repository locale. Il y a souvent des conflits lors d’une fusion. Surtout si vous avez travailler dans un même fichier qu’un ou une de vos collègues.\nVous devez tenter de résoudre les conflits avec des outils en ligne de commande ou à l’aide d’un interface graphique. C’est une habilité à acquérir avec le temps. C’est parfois très complexe et si l’opération n’est pas effectée avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste à changer la base de votre branche d’un commit vers un autre, donnant l’illusion que vous avez créé votre branche à partir d’un commit différent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder l’état actuel de votre répertoire de travail. C’est possible de le faire avec git stash et de revenir à un répertoire de travail propre sans ces modifications. Vous pourrez ensuite récupérer ce travail en utilisant le nom que vous lui aurez donné. Vous pouvez en avoir plusieurs sauvegardés dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// Récupérer les changements précédents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalité si vous avez terminé.\nNe pas prendre les branches pour plusieurs fonctionnalités. Séparez vos tâches en plus petites et faites des commits plus souvent.\nRécupérer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre équipe vos intentions! Ne travaillez pas sur les mêmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillé sur une fonctionnalité ou un fix.\nAvant le jour de la mise en production. Vous devriez créer une branche à partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visée vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les éléments. Testez que votre branche fonctionne et qu’elle est bien compilée. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront déjà été résolus! Bingo.\nGitflow Pour maintenir une certain cohésion en entreprise, un modèle de branche a été proposé. Il implique de séparer les branches de développement et les branches primaires qui sont déployés dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRéférence Richard E. Silverman (2013), Git Pocket Guide, O’Reilly\nAlice Jacquot, Introduction à Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-311/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Objectifs généraux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de données.\nÉvaluer et comparer la complexité algorithmique des opérations (temps et mémoire).\nUtiliser des fils d’exécution (threads) pour exécuter plusieurs tâches en parallèle.\nDévelopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi étudier les structures de données ? Parce qu’elles sont au cœur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de données.\nParce qu’elles permettent de réduire le temps d’exécution et économiser de la mémoire.\nParce qu’elles développent la capacité à choisir la bonne approche selon un problème donné.\nParce qu’elles forment une base solide pour les cours ultérieurs et pour travailler dans des projets d’envergure.\nCitation classique : « Un bon algorithme mal implanté dans une mauvaise structure de données sera inefficace. Une bonne structure de données peut transformer un problème complexe en une solution élégante. »\n🌼 Notion de structure de données Le principe de base d’une structure de données, c’est de stocker des éléments auxquels le programmeur veut pouvoir accéder plus tard. On appelle les différentes utilisations possibles de la structure de données des opérations.\n🌼 Les structures de données en Java Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util).\nOn y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nNous commencerons par examiner les concepts communs qu’elles (structures de données) exploitent ainsi : généricité, itérateur, ordonnancement et relation d’ordre.\nNous verrons également quelles sont les opérations qui leur sont communes : ajout ou suppression d’éléments, construction à partir des éléments d’une autre collection…\nNous étudierons ensuite en détail chacune de ces structures, à savoir :\n🗝 Les listes, implémentées par la classe LinkedList;\r🗝 Les vecteurs dynamiques, implémentés par les classes ArrayList et Vector;\r🗝 Les ensembles, implémentés par les classes HashSet et TreeSet;\r🗝 Les queues avec priorité, implémentées par la classe PriorityQueue (introduite par le JDK 5.0) ;\r🗝 Les queues à double entrée, implémentées par la classe ArrayDeque (introduite par Java6).",
    "description": "Objectifs généraux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de données.\nÉvaluer et comparer la complexité algorithmique des opérations (temps et mémoire).\nUtiliser des fils d’exécution (threads) pour exécuter plusieurs tâches en parallèle.\nDévelopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi étudier les structures de données ? Parce qu’elles sont au cœur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de données.",
    "tags": [],
    "title": "Structures de donnée",
    "uri": "/420-311/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-311/categories/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-311/tags/index.html"
  }
]
