var relearn_searchindex = [
  {
    "breadcrumb": "Structures de donn√©e",
    "content": "Dans ce module nous ferons une courte r√©vision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte r√©vision des notions essentielles au cours.",
    "tags": [],
    "title": "Pr√©alables",
    "uri": "/420-311/intro/index.html"
  },
  {
    "breadcrumb": "Structures de donn√©e¬†\u003e¬†Pr√©alables",
    "content": "Rappel : Concepts de base Classe : Mod√®le d√©finissant les attributs (variables) et comportements (m√©thodes).\nObjet : Instance concr√®te d‚Äôune classe.\nEncapsulation : Prot√©ger les donn√©es via des modificateurs d‚Äôacc√®s (private, public, protected) et exposer des m√©thodes d‚Äôacc√®s (getters/setters).\nAbstraction : Masquer les d√©tails d‚Äôimpl√©mentation et ne montrer que les fonctionnalit√©s essentielles (via classes abstraites et interfaces).\nH√©ritage : Une classe peut h√©riter des attributs et m√©thodes d‚Äôune autre (mot-cl√© extends).\nPolymorphisme :\nSurcharge (overloading) : m√™me nom de m√©thode, signatures diff√©rentes. Red√©finition (overriding) : une sous-classe red√©finit le comportement d‚Äôune m√©thode h√©rit√©e. Constructeur : M√©thode sp√©ciale ex√©cut√©e lors de la cr√©ation d‚Äôun objet (new).\nModificateurs d‚Äôacc√®s Modificateur M√™me classe M√™me package Sous-classe Partout public ‚úÖ ‚úÖ ‚úÖ ‚úÖ protected ‚úÖ ‚úÖ ‚úÖ ‚ùå (default) ‚úÖ ‚úÖ ‚ùå ‚ùå private ‚úÖ ‚ùå ‚ùå ‚ùå Syntaxe essentielle D√©finir une classe public class Voiture { private String marque; private int annee; public Voiture(String marque, int annee) { this.marque = marque; this.annee = annee; } public void demarrer() { System.out.println(marque + \" d√©marre !\"); } }\rCr√©er un objet Voiture v1 = new Voiture(\"Toyota\", 2022); v1.demarrer();\rH√©ritage et polymorphisme class Animal { public void parler() { System.out.println(\"??\"); } } class Chien extends Animal { @Override public void parler() { System.out.println(\"Woof\"); } } Animal a = new Chien(); // polymorphisme a.parler(); // \"Woof\"\rAbstraction et interfaces abstract class Forme { abstract double aire(); } class Cercle extends Forme { private double r; Cercle(double r) { this.r = r; } @Override double aire() { return Math.PI * r * r; } } interface Volant { void voler(); } class Avion implements Volant { public void voler() { System.out.println(\"En vol ‚úàÔ∏è\"); } }\rClasses utiles Object : classe racine de toutes les classes Java. M√©thodes importantes : toString(), equals(), hashCode(), clone().\nfinal :\nfinal class : non-h√©rit√©e. final method : non-red√©finissable. final variable : constante. Gestion m√©moire Les objets sont cr√©√©s sur le tas (heap) via new. Le garbage collector lib√®re automatiquement la m√©moire des objets non r√©f√©renc√©s. Bonnes pratiques Utiliser private pour prot√©ger les donn√©es. Toujours red√©finir toString() pour repr√©senter un objet. Respecter la coh√©rence equals() / hashCode(). Favoriser la composition plut√¥t que l‚Äôh√©ritage trop profond. Documenter avec JavaDoc (/** ‚Ä¶ */). Exemple : package s01; class Etudiant { private String nom; private int age; public Etudiant(String nom, int age) { this.nom = nom; this.age = age; } public void afficherInfos() { System.out.println(\"Nom : \" + nom + \", √Çge : \" + age); } } class EtudiantRegulier extends Etudiant { private String programme; public EtudiantRegulier(String nom, int age, String programme) { super(nom, age); this.programme = programme; } @Override public void afficherInfos() { super.afficherInfos(); System.out.println(\"Programme : \" + programme); } } public class RappelPOO { public static void main(String[] args) { EtudiantRegulier e = new EtudiantRegulier(\"Alice\", 20, \"Informatique\"); e.afficherInfos(); } }",
    "description": "Rappel : Concepts de base Classe : Mod√®le d√©finissant les attributs (variables) et comportements (m√©thodes).\nObjet : Instance concr√®te d‚Äôune classe.\nEncapsulation : Prot√©ger les donn√©es via des modificateurs d‚Äôacc√®s (private, public, protected) et exposer des m√©thodes d‚Äôacc√®s (getters/setters).\nAbstraction : Masquer les d√©tails d‚Äôimpl√©mentation et ne montrer que les fonctionnalit√©s essentielles (via classes abstraites et interfaces).\nH√©ritage : Une classe peut h√©riter des attributs et m√©thodes d‚Äôune autre (mot-cl√© extends).",
    "tags": [],
    "title": "R√©vision",
    "uri": "/420-311/intro/revisionpoo/index.html"
  },
  {
    "breadcrumb": "Structures de donn√©e¬†\u003e¬†Pr√©alables",
    "content": "Questions th√©oriques Question 1 : Quel est le r√©sultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le r√©sultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le r√©sultat du code suivant:\npublic class Question3 { public static void main(String[]args) { int val1 = 9; int val2 = 9; String str = \"9\"; System.out.println(val1 + val2 + str);\t} }\rQuestion 4 : Quel est le r√©sultat du code suivant:\npublic class Question4 { public static void main(String[]args) { try { int a, b; b = 0; a = 5 / b; System.out.print(\"A\"); } catch (Exception e) { System.out.print(\"B\"); } finally { System.out.print(\"C\"); }\t} }\rQuestion 5 : Quel est le r√©sultat du code suivant:\npublic class Question5 { public static void main(String[]args) { String obj = \"Bonjour\"; String obj1 = \"Bonsoir\"; String obj2 = \"Bonjour\"; System.out.println(obj.equals(obj1) + \" \" + obj.equals(obj2)); } }\rQuestion 6 : Quel est le r√©sultat du code suivant:\npublic class ClasseA { public int i; public int j; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.j = 3; System.out.println(i + \" \" + j); } } public class Question6 { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 7 : Quel est le r√©sultat du code suivant:\npublic class ClasseA { public int i; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.i = j + 1; System.out.println ( j + \" \" + i); } } public class Main { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 8 : Quel est le r√©sultat du code suivant:\npublic class Question8{ public static void main(String[] args) { String s = \"Hello World\"; int A = s.indexOf('o'); int B = s.lastIndexOf('l'); System.out.println(A + \" \" + B); } }\rQuestion 9 : Quel est le r√©sultat du code suivant:\npublic class Question9{ public static void main(String[] args) { char ch; ch = \"hello\".charAt(1); System.out.println(ch); } }\rQuestion 10 : Quel est le r√©sultat du code suivant:\npublic class Question10{ public static void main(String[] args) { String chars[] = {\"a\", \"b\", \"c\", \"a\", \"c\"}; for (int i = 0; i \u003c chars.length; ++i) for (int j = i + 1; j \u003c chars.length; ++j) if(chars[i].compareTo(chars[j]) == 0) System.out.print(chars[j]); } }\rQuestion 11 : Quel est le r√©sultat du code suivant:\npublic class Question11{ public static void main(String[] args) { int a1[] = new int[10]; int a2[] = { 1, 2, 3, 4, 5 }; System.out.println(a1.length + \" \" + a2.length); } }\rQuestion 12 : Quel est le r√©sultat du code suivant:\npublic class Question12{ public static void main(String[] args) { int arr[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i \u003c arr.length - 2; ++i) System.out.print(arr[i] + \" \"); } }\rQuestion 13 : Quel est le r√©sultat du code suivant:\npublic class Question13{ public static int param1; public static int param2; public void add(int a, int b) { param1 = a + b; param2 = param1 + b; } public static void main(String args[]) { Question13 obj1 = new Question13(); Question13 obj2 = new Question13(); int a = 2; obj1.add(a, a + 1); obj2.add(5, a); System.out.println(obj1.param1 + \" \" + obj2.param2); } }\rQuestion 14 : Quel est le r√©sultat du code suivant:\nimport java.util.Arrays; public class Question14{ public static void main(String[] args) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 15 : Quel est le r√©sultat du code suivant:\npublic class Question15{ public static int param1; public void increment() { param1++; } public static void main(String args[]) { Question15 obj1 = new Question15(); Question15 obj2 = new Question15(); obj1.param1 = 0; obj1.increment(); obj2.increment(); System.out.println(obj1.param1 + \" \" + obj2.param1); } }\rQuestion 16 : Quel est le r√©sultat du code suivant:\nimport java.util.Arrays; public class Question16 { public static void main(String args[]) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 17 : Quel est le r√©sultat du code suivant:\npublic class Question17 { public static void main(String[] args) { ClasseB classeB = new ClasseB(); System.out.println(\"Valeur = \" + classeB.calculer(3, 6)); } } class ClassA { final public int calculer(int a, int b) { return 0; } } class ClasseB extends ClasseA { public int calculer(int a, int b) { return 1; } }\rQuestion 18 : Quel est le r√©sultat du code suivant:\npublic class Question18 { public static void main (String args[]) { int param1, param2= 1; param1= 10; if (param1!= 10 \u0026\u0026 param1/ 0 == 0) { System.out.println(param2); } else { System.out.println(++param2); } } }\rQuestion 19 : Quel est le r√©sultat du code suivant:\npublic class Question19 { public static int param1; public static int param2; public void add(int val1, int val2) { param1 = val1 + val2; param2 = param1 + val2; } public static void main(String[] args) { Question19 instance1 = new Question19 (); Question19 instance2 = new Question19 (); Question19 instance3 = new Question19 (); int abc = 2;\tinstance1.add(abc, abc-1); instance3.add(6, 6/abc); instance2.add(5, abc/2); System.out.println(instance1.param1); System.out.println(instance2.param2); } }\rQuestion 20 : Quel est le r√©sultat du code suivant:\nimport java.util.Arrays; public class Question20 { public static void main(String args[]) { int array[] = new int [5]; for (int i = 5; i \u003e 0; i--) { array[5 - i] = i; } Arrays.sort(array); System.out.print(Arrays.toString(array)); } }",
    "description": "Questions th√©oriques Question 1 : Quel est le r√©sultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le r√©sultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le r√©sultat du code suivant:",
    "tags": [],
    "title": "Questions et exercices",
    "uri": "/420-311/intro/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donn√©e¬†\u003e¬†Pr√©alables",
    "content": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code d‚Äô√©v√©nement dans le bandeau sup√©rieur Quiz 2 : m√©thodes et interfaces Quiz Wooclap sur les m√©thodes et les interfaces",
    "description": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code d‚Äô√©v√©nement dans le bandeau sup√©rieur Quiz 2 : m√©thodes et interfaces Quiz Wooclap sur les m√©thodes et les interfaces",
    "tags": [],
    "title": "Quiz",
    "uri": "/420-311/intro/quiz/index.html"
  },
  {
    "breadcrumb": "Structures de donn√©e¬†\u003e¬†Ressources utiles",
    "content": "Introduction √† Git Git est un logiciel de contr√¥le de version. Il permet de g√©rer des fichiers et leur √©volution dans le temps.\nIl permet de retracer l‚Äôorigine de chaque modification, de r√©tablir des versions pr√©c√©dentes et permet l‚Äôint√©gration de modifications effectu√©es en parall√®le.\nConcept Le principe d‚Äôun gestionnaire de version est qu‚Äôil g√®re un document comme ‚Äúune base‚Äù √† laquelle est ajout√© une suite de modifications.\nIl y a un d√©p√¥t commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsqu‚Äôun contributeur a r√©alis√© une modification qui est pr√™te √† l‚Äôenvoyer, il pousse (push) celle-ci vers le d√©p√¥t. Le d√©p√¥t garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version d√©centralis√©. Il y a 2 d√©p√¥ts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez r√©cup√©rer le code de votre repository (d√©p√¥t remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configur√© la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de d√©poser les modifications sur une d√©p√¥t local. Il faut √©galement √™tre vigilant au niveau de la branche utilis√© pour le commit. De plus, il est important de mettre souvent √† jour la branche avant de proc√©der √† un commit.\nLorsqu‚Äôon fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour r√©f√©rer √† la t√¢che en cours. Apr√®s cet identifiant, on peut y mettre une description. Par exemple:\n‚ÄúPRJ-3428: Ajout de tests unitaires sur la m√©thode du service getClients‚Äù\nLorsqu‚Äôon relie l‚Äôidentifiant et les commits, on peut alors conna√Ætre le travail effectu√© dans le code pour une t√¢che donn√©e dans le syst√®me de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommand√© de faire un git fetch / pull avant de proc√©der √† celui-ci. √Ä moins d‚Äô√™tre seul dans ce repository et/ou la branche vis√©e.\nGit Fetch, checkout, pull La commande git fetch permet de mettre √† jour notre d√©p√¥t local en r√©cup√©rant l‚Äô √©tat courant qui remote. La commande git checkout permet de les appliquer √† la copie de travail (et donc de les voir).\nLa commande git pull fait les deux √† la fois.\nPensez √† vous mettre √† jour avant chaque session de travail !\nC‚Äôest la premi√®re chose qu‚Äôun d√©veloppeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de conna√Ætre l‚Äô√©tat courant de vos copies locales (les modifications ont-elles √©t√© commit√©es, les fichiers ajout√©s, les commit push√©).\nLes interface graphiques (dont intelliJ) vous l‚Äôindique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectu√©. Ces commit peuvent √™tre fort utili pour faire d‚Äôautres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet d‚Äôappliquer les changements (fusionner) d‚Äôune autre branche √† votre branche s√©lectionn√©e dans votre repository locale. Il y a souvent des conflits lors d‚Äôune fusion. Surtout si vous avez travailler dans un m√™me fichier qu‚Äôun ou une de vos coll√®gues.\nVous devez tenter de r√©soudre les conflits avec des outils en ligne de commande ou √† l‚Äôaide d‚Äôun interface graphique. C‚Äôest une habilit√© √† acqu√©rir avec le temps. C‚Äôest parfois tr√®s complexe et si l‚Äôop√©ration n‚Äôest pas effect√©e avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste √† changer la base de votre branche d‚Äôun commit vers un autre, donnant l‚Äôillusion que vous avez cr√©√© votre branche √† partir d‚Äôun commit diff√©rent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder l‚Äô√©tat actuel de votre r√©pertoire de travail. C‚Äôest possible de le faire avec git stash et de revenir √† un r√©pertoire de travail propre sans ces modifications. Vous pourrez ensuite r√©cup√©rer ce travail en utilisant le nom que vous lui aurez donn√©. Vous pouvez en avoir plusieurs sauvegard√©s dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// R√©cup√©rer les changements pr√©c√©dents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalit√© si vous avez termin√©.\nNe pas prendre les branches pour plusieurs fonctionnalit√©s. S√©parez vos t√¢ches en plus petites et faites des commits plus souvent.\nR√©cup√©rer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre √©quipe vos intentions! Ne travaillez pas sur les m√™mes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaill√© sur une fonctionnalit√© ou un fix.\nAvant le jour de la mise en production. Vous devriez cr√©er une branche √† partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE vis√©e vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les √©l√©ments. Testez que votre branche fonctionne et qu‚Äôelle est bien compil√©e. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront d√©j√† √©t√© r√©solus! Bingo.\nGitflow Pour maintenir une certain coh√©sion en entreprise, un mod√®le de branche a √©t√© propos√©. Il implique de s√©parer les branches de d√©veloppement et les branches primaires qui sont d√©ploy√©s dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nR√©f√©rence Richard E. Silverman (2013), Git Pocket Guide, O‚ÄôReilly\nAlice Jacquot, Introduction √† Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction √† Git Git est un logiciel de contr√¥le de version. Il permet de g√©rer des fichiers et leur √©volution dans le temps.\nIl permet de retracer l‚Äôorigine de chaque modification, de r√©tablir des versions pr√©c√©dentes et permet l‚Äôint√©gration de modifications effectu√©es en parall√®le.\nConcept Le principe d‚Äôun gestionnaire de version est qu‚Äôil g√®re un document comme ‚Äúune base‚Äù √† laquelle est ajout√© une suite de modifications.\nIl y a un d√©p√¥t commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-311/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Objectifs g√©n√©raux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de donn√©es.\n√âvaluer et comparer la complexit√© algorithmique des op√©rations (temps et m√©moire).\nUtiliser des fils d‚Äôex√©cution (threads) pour ex√©cuter plusieurs t√¢ches en parall√®le.\nD√©velopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi √©tudier les structures de donn√©es ? Parce qu‚Äôelles sont au c≈ìur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de donn√©es.\nParce qu‚Äôelles permettent de r√©duire le temps d‚Äôex√©cution et √©conomiser de la m√©moire.\nParce qu‚Äôelles d√©veloppent la capacit√© √† choisir la bonne approche selon un probl√®me donn√©.\nParce qu‚Äôelles forment une base solide pour les cours ult√©rieurs et pour travailler dans des projets d‚Äôenvergure.\nCitation classique : ¬´ Un bon algorithme mal implant√© dans une mauvaise structure de donn√©es sera inefficace. Une bonne structure de donn√©es peut transformer un probl√®me complexe en une solution √©l√©gante. ¬ª\nüåº Notion de structure de donn√©es Le principe de base d‚Äôune structure de donn√©es, c‚Äôest de stocker des √©l√©ments auxquels le programmeur veut pouvoir acc√©der plus tard. On appelle les diff√©rentes utilisations possibles de la structure de donn√©es des op√©rations.\nüåº Les structures de donn√©es en Java Le langage Java a √©largi et harmonis√© la biblioth√®que de classes utilitaires (java.util).\nOn y trouve d√©sormais des classes permettant de manipuler les principales structures de donn√©es, c‚Äôest-√†-dire les vecteurs dynamiques, les ensembles, les listes cha√Æn√©es, les queues et les tables associatives.\nNous commencerons par examiner les concepts communs qu‚Äôelles (structures de donn√©es) exploitent ainsi : g√©n√©ricit√©, it√©rateur, ordonnancement et relation d‚Äôordre.\nNous verrons √©galement quelles sont les op√©rations qui leur sont communes : ajout ou suppression d‚Äô√©l√©ments, construction √† partir des √©l√©ments d‚Äôune autre collection‚Ä¶\nNous √©tudierons ensuite en d√©tail chacune de ces structures, √† savoir :\nüóù Les listes, impl√©ment√©es par la classe LinkedList;\rüóù Les vecteurs dynamiques, impl√©ment√©s par les classes ArrayList et Vector;\rüóù Les ensembles, impl√©ment√©s par les classes HashSet et TreeSet;\rüóù Les queues avec priorit√©, impl√©ment√©es par la classe PriorityQueue (introduite par le JDK 5.0) ;\rüóù Les queues √† double entr√©e, impl√©ment√©es par la classe ArrayDeque (introduite par Java6).",
    "description": "Objectifs g√©n√©raux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de donn√©es.\n√âvaluer et comparer la complexit√© algorithmique des op√©rations (temps et m√©moire).\nUtiliser des fils d‚Äôex√©cution (threads) pour ex√©cuter plusieurs t√¢ches en parall√®le.\nD√©velopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi √©tudier les structures de donn√©es ? Parce qu‚Äôelles sont au c≈ìur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de donn√©es.",
    "tags": [],
    "title": "Structures de donn√©e",
    "uri": "/420-311/index.html"
  },
  {
    "breadcrumb": "Structures de donn√©e",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-311/categories/index.html"
  },
  {
    "breadcrumb": "Structures de donn√©e",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-311/tags/index.html"
  }
]
