var relearn_searchindex = [
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Dans ce module nous ferons une courte rÃ©vision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte rÃ©vision des notions essentielles au cours.",
    "tags": [],
    "title": "PrÃ©alables",
    "uri": "/420-311/intro/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Structure de donnÃ©es",
    "content": "Notion de structure de donnÃ©es â“‚ï¸ Le principe de base dâ€™une structure de donnÃ©es, câ€™est de stocker des Ã©lÃ©ments auxquels le programmeur veut pouvoir accÃ©der plus tard. On appelle les diffÃ©rentes utilisations possibles de la structure de donnÃ©es des opÃ©rations.\nLes structures de donnÃ©es en Java Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util). On y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nStructure gÃ©nÃ©rale des collections en Java Une collection reprÃ©sente un groupe dâ€™objets, connu par ses Ã©lÃ©ments. Certaines collections acceptent les doublons, dâ€™autres pas. Certaines sont ordonnÃ©es, dâ€™autres pas.\nInterface Collection Depuis la version 1.6 de Java, il y a un changement dans la structure des collections. Il y a eu lâ€™ajout du package java.util.concurrent\nVous pourrez gÃ©nÃ©ralement vous contenter de connaÃ®tre les fonctionnalitÃ©s supplÃ©mentaires quâ€™offre chacune des classes LinkedList, ArrayList, Vector, HashSet, TreeSet, PriorityQueue et ArrayDeque. Mais, dans certains cas, vous devrez avoir quelques notions sur lâ€™architecture dâ€™interfaces employÃ©e par les concepteurs de la librairie. Elle se prÃ©sente comme suit :\nCollection\nList implÃ©mentÃ©e par LinkedList, ArrayList et Vector Set implÃ©mentÃ©e par HashSet SortedSet implÃ©mentÃ©e par TreeSet NavigableSet implÃ©mentÃ©e par TreeSet (Java 6) Queue (JDK 5.0) implÃ©mentÃ©e par LinkedList, PriorityQueue Deque (Java 6) implÃ©mentÃ©e par ArrayDeque, LinkedList Lâ€™interface Iterable public interface \u003cE\u003e Collection extends Iterable \u003cE\u003e\rCollection est lâ€™interface racine dans la hiÃ©rarchie des collections. Une collection reprÃ©sente un groupe dâ€™objets, connu sous le nom de ses Ã©lÃ©ments. Certaines collections :\nPermettent de dupliquer les Ã©lÃ©ments et dâ€™autres pas. Elles sont ordonnÃ©es et dâ€™autres pas. Le JDK ne fournit pas directement les implÃ©mentations de cette interface : il fournit des implÃ©mentations de sous-interfaces plus spÃ©cifiques telles que Set et List.\nLâ€™interface List public interface List\u003cE\u003e extends Collection\u003cE\u003e\rUne liste est une collection ordonnÃ©e (Ã©galement connu sous le nom de sÃ©quence).\nLâ€™utilisateur de cette interface Ã  un contrÃ´le prÃ©cis sur lâ€™endroit oÃ¹ est insÃ©rÃ© chaque Ã©lÃ©ment dans la liste. Lâ€™utilisateur peut accÃ©der aux Ã©lÃ©ments par leur index (position dans la liste), et rechercher des Ã©lÃ©ments dans la liste. Les listes permettent gÃ©nÃ©ralement les Ã©lÃ©ments dupliquÃ©s. Les listes permettent de multiples Ã©lÃ©ments nuls. Il nâ€™est pas inconcevable que quelquâ€™un puisse vouloir mettre en place une liste qui interdit les doublons, par exemple : en lanÃ§ant des exceptions dâ€™exÃ©cution lorsque lâ€™utilisateur tente de les insÃ©rer, cet usage est rare.\nLes listes chaÃ®nÃ©es - classe LinkedList La classe LinkedList permet de manipuler des listes dites â€œdoublement chaÃ®nÃ©esâ€. Ã€ chaque Ã©lÃ©ment de la collection, on associe (de faÃ§on totalement transparente pour le programmeur) deux informations supplÃ©mentaires qui ne sont autres que les rÃ©fÃ©rences Ã  lâ€™Ã©lÃ©ment prÃ©cÃ©dent et au suivant. Une telle collection peut ainsi Ãªtre parcourue Ã  lâ€™aide dâ€™un itÃ©rateur bidirectionnel de type ListIterator.\nLe grand avantage dâ€™une telle structure est de permettre des ajouts ou des suppressions Ã  une position donnÃ©e avec une efficacitÃ© en O (1) (ceci grÃ¢ce Ã  un simple jeu de modification de rÃ©fÃ©rences).\nEn revanche, lâ€™accÃ¨s Ã  un Ã©lÃ©ment en fonction de sa valeur ou de sa position dans la liste sera peu efficace puisquâ€™il nÃ©cessitera obligatoirement de parcourir une partie de la liste. Lâ€™efficacitÃ© sera donc en moyenne en O (N).",
    "description": "Notion de structure de donnÃ©es â“‚ï¸ Le principe de base dâ€™une structure de donnÃ©es, câ€™est de stocker des Ã©lÃ©ments auxquels le programmeur veut pouvoir accÃ©der plus tard. On appelle les diffÃ©rentes utilisations possibles de la structure de donnÃ©es des opÃ©rations.\nLes structures de donnÃ©es en Java Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util). On y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.",
    "tags": [],
    "title": "Les structures de donnÃ©es (Java)",
    "uri": "/420-311/sdd/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Dans ce chapitre nous allons dÃ©couvrir quelques structures de donnÃ©es et apprendre Ã  choisir la bonne structure selon le problÃ¨me.\nâ“‚ï¸ Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util).\nâ“‚ï¸ On y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nâ“‚ï¸ Nous commencerons par examiner les concepts communs quâ€™elles (structures de donnÃ©es) exploitent ainsi : gÃ©nÃ©ricitÃ©, itÃ©rateur, ordonnancement et relation dâ€™ordre.\nâ“‚ï¸ Nous verrons Ã©galement quelles sont les opÃ©rations qui leur sont communes : ajout ou suppression dâ€™Ã©lÃ©ments, construction Ã  partir des Ã©lÃ©ments dâ€™une autre collectionâ€¦\nâ“‚ï¸ Nous Ã©tudierons ensuite en dÃ©tail chacune de ces structures, Ã  savoir :\nğŸŒ± Les listes, implÃ©mentÃ©es par la classe LinkedList;\rğŸŒ± Les vecteurs dynamiques, implÃ©mentÃ©s par les classes ArrayList et Vector;\rğŸŒ± Les ensembles, implÃ©mentÃ©s par les classes HashSet et TreeSet;\rğŸŒ± Les queues avec prioritÃ©, implÃ©mentÃ©es par la classe PriorityQueue (introduite par le JDK 5.0) ;\rğŸŒ± Les queues Ã  double entrÃ©e, implÃ©mentÃ©es par la classe ArrayDeque (introduite par Java6).",
    "description": "Dans ce chapitre nous allons dÃ©couvrir quelques structures de donnÃ©es et apprendre Ã  choisir la bonne structure selon le problÃ¨me.\nâ“‚ï¸ Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util).\nâ“‚ï¸ On y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nâ“‚ï¸ Nous commencerons par examiner les concepts communs quâ€™elles (structures de donnÃ©es) exploitent ainsi : gÃ©nÃ©ricitÃ©, itÃ©rateur, ordonnancement et relation dâ€™ordre.",
    "tags": [],
    "title": "Structure de donnÃ©es",
    "uri": "/420-311/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Dans ce chapitre, nous allons voir ce que signifie la notation Big-O et analyser la complexitÃ© dâ€™un algorithme simple, ainsi que comparer plusieurs approches pour rÃ©soudre un mÃªme problÃ¨me. En fin, nous allons voir comment mesurer expÃ©rimentalement la performance dâ€™un programme en Java.",
    "description": "Dans ce chapitre, nous allons voir ce que signifie la notation Big-O et analyser la complexitÃ© dâ€™un algorithme simple, ainsi que comparer plusieurs approches pour rÃ©soudre un mÃªme problÃ¨me. En fin, nous allons voir comment mesurer expÃ©rimentalement la performance dâ€™un programme en Java.",
    "tags": [],
    "title": "ComplexitÃ© algorithmique",
    "uri": "/420-311/complexalgo/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Rappel : Concepts de base Classe : ModÃ¨le dÃ©finissant les attributs (variables) et comportements (mÃ©thodes).\nObjet : Instance concrÃ¨te dâ€™une classe.\nEncapsulation : ProtÃ©ger les donnÃ©es via des modificateurs dâ€™accÃ¨s (private, public, protected) et exposer des mÃ©thodes dâ€™accÃ¨s (getters/setters).\nAbstraction : Masquer les dÃ©tails dâ€™implÃ©mentation et ne montrer que les fonctionnalitÃ©s essentielles (via classes abstraites et interfaces).\nHÃ©ritage : Une classe peut hÃ©riter des attributs et mÃ©thodes dâ€™une autre (mot-clÃ© extends).\nPolymorphisme :\nSurcharge (overloading) : mÃªme nom de mÃ©thode, signatures diffÃ©rentes. RedÃ©finition (overriding) : une sous-classe redÃ©finit le comportement dâ€™une mÃ©thode hÃ©ritÃ©e. Constructeur : MÃ©thode spÃ©ciale exÃ©cutÃ©e lors de la crÃ©ation dâ€™un objet (new).\nModificateurs dâ€™accÃ¨s Modificateur MÃªme classe MÃªme package Sous-classe Partout public âœ… âœ… âœ… âœ… protected âœ… âœ… âœ… âŒ (default) âœ… âœ… âŒ âŒ private âœ… âŒ âŒ âŒ Syntaxe essentielle DÃ©finir une classe public class Voiture { private String marque; private int annee; public Voiture(String marque, int annee) { this.marque = marque; this.annee = annee; } public void demarrer() { System.out.println(marque + \" dÃ©marre !\"); } }\rCrÃ©er un objet Voiture v1 = new Voiture(\"Toyota\", 2022); v1.demarrer();\rHÃ©ritage et polymorphisme class Animal { public void parler() { System.out.println(\"??\"); } } class Chien extends Animal { @Override public void parler() { System.out.println(\"Woof\"); } } Animal a = new Chien(); // polymorphisme a.parler(); // \"Woof\"\rAbstraction et interfaces abstract class Forme { abstract double aire(); } class Cercle extends Forme { private double r; Cercle(double r) { this.r = r; } @Override double aire() { return Math.PI * r * r; } } interface Volant { void voler(); } class Avion implements Volant { public void voler() { System.out.println(\"En vol âœˆï¸\"); } }\rClasses utiles Object : classe racine de toutes les classes Java. MÃ©thodes importantes : toString(), equals(), hashCode(), clone().\nfinal :\nfinal class : non-hÃ©ritÃ©e. final method : non-redÃ©finissable. final variable : constante. Gestion mÃ©moire Les objets sont crÃ©Ã©s sur le tas (heap) via new. Le garbage collector libÃ¨re automatiquement la mÃ©moire des objets non rÃ©fÃ©rencÃ©s. Bonnes pratiques Utiliser private pour protÃ©ger les donnÃ©es. Toujours redÃ©finir toString() pour reprÃ©senter un objet. Respecter la cohÃ©rence equals() / hashCode(). Favoriser la composition plutÃ´t que lâ€™hÃ©ritage trop profond. Documenter avec JavaDoc (/** â€¦ */). Exemple : package s01; class Etudiant { private String nom; private int age; public Etudiant(String nom, int age) { this.nom = nom; this.age = age; } public void afficherInfos() { System.out.println(\"Nom : \" + nom + \", Ã‚ge : \" + age); } } class EtudiantRegulier extends Etudiant { private String programme; public EtudiantRegulier(String nom, int age, String programme) { super(nom, age); this.programme = programme; } @Override public void afficherInfos() { super.afficherInfos(); System.out.println(\"Programme : \" + programme); } } public class RappelPOO { public static void main(String[] args) { EtudiantRegulier e = new EtudiantRegulier(\"Alice\", 20, \"Informatique\"); e.afficherInfos(); } }\rğŸ“˜ RÃ©sumÃ© de rÃ©vision â€“ POO ğŸ”¹ 1. Classes Une classe public est accessible depuis nâ€™importe quel package. Une classe abstract sert de modÃ¨le, ne peut pas Ãªtre instanciÃ©e et peut contenir des mÃ©thodes abstraites. Une classe final ne peut pas Ãªtre hÃ©ritÃ©e. Une classe private nâ€™est possible quâ€™en classe interne (nested class). Toute classe hÃ©rite implicitement de Object â†’ possÃ¨de donc les mÃ©thodes toString(), equals(), hashCode(), etc. ğŸ”¹ 2. Constructeurs Si aucune dÃ©claration â†’ le compilateur gÃ©nÃ¨re un constructeur par dÃ©faut (sans paramÃ¨tres). Un constructeur peut Ãªtre private (utilisÃ© dans le pattern Singleton ou classes utilitaires). ğŸ”¹ 3. MÃ©thodes Les mÃ©thodes peuvent Ãªtre surchargÃ©es (overloading) â†’ mÃªme nom, paramÃ¨tres diffÃ©rents. Les mÃ©thodes peuvent Ãªtre surdÃ©finies (overriding) â†’ mÃªme signature, dans une sous-classe. Une mÃ©thode final ne peut pas Ãªtre redÃ©finie dans une sous-classe. Une mÃ©thode abstract est dÃ©clarÃ©e sans corps et doit Ãªtre implÃ©mentÃ©e dans une sous-classe. abstract et final sont incompatibles (contradiction). ğŸ”¹ 4. Attributs Un attribut final est une constante : doit Ãªtre initialisÃ© une seule fois (dÃ©claration ou constructeur). ğŸ”¹ 5. Interfaces Une interface ne peut pas Ãªtre instanciÃ©e.\nUne interface nâ€™est pas un objet, câ€™est un contrat.\nUne interface nâ€™hÃ©rite pas dâ€™Object, mais les classes qui lâ€™implÃ©mentent hÃ©ritent dâ€™Object.\nUne interface peut hÃ©riter dâ€™une ou plusieurs autres interfaces avec extends.\nUne interface ne peut pas hÃ©riter dâ€™une classe.\nMÃ©thodes dans une interface :\nAvant Java 8 â†’ uniquement public abstract. Depuis Java 8 â†’ mÃ©thodes default et static avec implÃ©mentation. Depuis Java 9 â†’ mÃ©thodes private pour factoriser du code interne. ğŸ”¹ 6. Comparable vs Comparator Comparable : dÃ©finit lâ€™ordre naturel dâ€™une classe (mÃ©thode compareTo). Comparator : dÃ©finit un ordre externe, peut Ãªtre multiple et personnalisÃ© (mÃ©thode compare). ğŸ”¹ 7. Mots-clÃ©s spÃ©ciaux null â†’ valeur littÃ©rale spÃ©ciale, pas un mot-clÃ©. this â†’ rÃ©fÃ©rence Ã  lâ€™instance courante. super â†’ rÃ©fÃ©rence Ã  la classe parente. RÃ©sumÃ© Ã‰lÃ©ment Description Exemple Classe abstract Non instanciable, modÃ¨le pour hÃ©ritage abstract class Forme { abstract double aire(); } Classe final Ne peut pas Ãªtre hÃ©ritÃ©e final class Utilitaire {} MÃ©thode final Ne peut pas Ãªtre redÃ©finie public final void calcul() {} MÃ©thode abstract Sans corps, Ã  implÃ©menter abstract void afficher(); Attribut final Constante, valeur fixÃ©e une seule fois final double PI = 3.14; Interface Contrat, non instanciable interface Vehicule { void rouler(); } Comparable Ordre naturel, compareTo class Etudiant implements Comparable\u003cEtudiant\u003e Comparator Ordre externe, compare Comparator\u003cEtudiant\u003e parNom = ...;",
    "description": "Rappel : Concepts de base Classe : ModÃ¨le dÃ©finissant les attributs (variables) et comportements (mÃ©thodes).\nObjet : Instance concrÃ¨te dâ€™une classe.\nEncapsulation : ProtÃ©ger les donnÃ©es via des modificateurs dâ€™accÃ¨s (private, public, protected) et exposer des mÃ©thodes dâ€™accÃ¨s (getters/setters).\nAbstraction : Masquer les dÃ©tails dâ€™implÃ©mentation et ne montrer que les fonctionnalitÃ©s essentielles (via classes abstraites et interfaces).\nHÃ©ritage : Une classe peut hÃ©riter des attributs et mÃ©thodes dâ€™une autre (mot-clÃ© extends).",
    "tags": [],
    "title": "RÃ©vision",
    "uri": "/420-311/intro/revisionpoo/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Questions thÃ©oriques Question 1 : Quel est le rÃ©sultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le rÃ©sultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le rÃ©sultat du code suivant:\npublic class Question3 { public static void main(String[]args) { int val1 = 9; int val2 = 9; String str = \"9\"; System.out.println(val1 + val2 + str);\t} }\rQuestion 4 : Quel est le rÃ©sultat du code suivant:\npublic class Question4 { public static void main(String[]args) { try { int a, b; b = 0; a = 5 / b; System.out.print(\"A\"); } catch (Exception e) { System.out.print(\"B\"); } finally { System.out.print(\"C\"); }\t} }\rQuestion 5 : Quel est le rÃ©sultat du code suivant:\npublic class Question5 { public static void main(String[]args) { String obj = \"Bonjour\"; String obj1 = \"Bonsoir\"; String obj2 = \"Bonjour\"; System.out.println(obj.equals(obj1) + \" \" + obj.equals(obj2)); } }\rQuestion 6 : Quel est le rÃ©sultat du code suivant:\npublic class ClasseA { public int i; public int j; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.j = 3; System.out.println(i + \" \" + j); } } public class Question6 { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 7 : Quel est le rÃ©sultat du code suivant:\npublic class ClasseA { public int i; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.i = j + 1; System.out.println ( j + \" \" + i); } } public class Main { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 8 : Quel est le rÃ©sultat du code suivant:\npublic class Question8{ public static void main(String[] args) { String s = \"Hello World\"; int A = s.indexOf('o'); int B = s.lastIndexOf('l'); System.out.println(A + \" \" + B); } }\rQuestion 9 : Quel est le rÃ©sultat du code suivant:\npublic class Question9{ public static void main(String[] args) { char ch; ch = \"hello\".charAt(1); System.out.println(ch); } }\rQuestion 10 : Quel est le rÃ©sultat du code suivant:\npublic class Question10{ public static void main(String[] args) { String chars[] = {\"a\", \"b\", \"c\", \"a\", \"c\"}; for (int i = 0; i \u003c chars.length; ++i) for (int j = i + 1; j \u003c chars.length; ++j) if(chars[i].compareTo(chars[j]) == 0) System.out.print(chars[j]); } }\rQuestion 11 : Quel est le rÃ©sultat du code suivant:\npublic class Question11{ public static void main(String[] args) { int a1[] = new int[10]; int a2[] = { 1, 2, 3, 4, 5 }; System.out.println(a1.length + \" \" + a2.length); } }\rQuestion 12 : Quel est le rÃ©sultat du code suivant:\npublic class Question12{ public static void main(String[] args) { int arr[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i \u003c arr.length - 2; ++i) System.out.print(arr[i] + \" \"); } }\rQuestion 13 : Quel est le rÃ©sultat du code suivant:\npublic class Question13{ public static int param1; public static int param2; public void add(int a, int b) { param1 = a + b; param2 = param1 + b; } public static void main(String args[]) { Question13 obj1 = new Question13(); Question13 obj2 = new Question13(); int a = 2; obj1.add(a, a + 1); obj2.add(5, a); System.out.println(obj1.param1 + \" \" + obj2.param2); } }\rQuestion 14 : Quel est le rÃ©sultat du code suivant:\nimport java.util.Arrays; public class Question14{ public static void main(String[] args) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 15 : Quel est le rÃ©sultat du code suivant:\npublic class Question15{ public static int param1; public void increment() { param1++; } public static void main(String args[]) { Question15 obj1 = new Question15(); Question15 obj2 = new Question15(); obj1.param1 = 0; obj1.increment(); obj2.increment(); System.out.println(obj1.param1 + \" \" + obj2.param1); } }\rQuestion 16 : Quel est le rÃ©sultat du code suivant:\nimport java.util.Arrays; public class Question16 { public static void main(String args[]) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 17 : Quel est le rÃ©sultat du code suivant:\npublic class Question17 { public static void main(String[] args) { ClasseB classeB = new ClasseB(); System.out.println(\"Valeur = \" + classeB.calculer(3, 6)); } } class ClassA { final public int calculer(int a, int b) { return 0; } } class ClasseB extends ClasseA { public int calculer(int a, int b) { return 1; } }\rQuestion 18 : Quel est le rÃ©sultat du code suivant:\npublic class Question18 { public static void main (String args[]) { int param1, param2= 1; param1= 10; if (param1!= 10 \u0026\u0026 param1/ 0 == 0) { System.out.println(param2); } else { System.out.println(++param2); } } }\rQuestion 19 : Quel est le rÃ©sultat du code suivant:\npublic class Question19 { public static int param1; public static int param2; public void add(int val1, int val2) { param1 = val1 + val2; param2 = param1 + val2; } public static void main(String[] args) { Question19 instance1 = new Question19 (); Question19 instance2 = new Question19 (); Question19 instance3 = new Question19 (); int abc = 2;\tinstance1.add(abc, abc-1); instance3.add(6, 6/abc); instance2.add(5, abc/2); System.out.println(instance1.param1); System.out.println(instance2.param2); } }\rQuestion 20 : Quel est le rÃ©sultat du code suivant:\nimport java.util.Arrays; public class Question20 { public static void main(String args[]) { int array[] = new int [5]; for (int i = 5; i \u003e 0; i--) { array[5 - i] = i; } Arrays.sort(array); System.out.print(Arrays.toString(array)); } }\rQuestion 21 : Quel est le rÃ©sultat du code suivant:\npublic class Question21 { public static void main(String [] args) { Question21 instance = new Question21(); instance.myMethod(); } public void myMethod(){ long [] tab1 = {6,8,9}; long []tab2 = affectation(tab1); System.out.print(tab1[0] + tab1[1] + tab1[2] + \" \"); System.out.println(tab2[0] + tab2[1] + tab2[2]); } public long[] affectation(long[] tab3){ tab3[1] = 7; return tab3; } }\rExercices pratiques Exercice 1 : Soit la String suivante: A-b-C-d-E-f-1234-***///-\u003e , Ã©crire un programme en Java qui:\nğŸ‘ convertit chaque caractÃ¨re alphabÃ©tique majuscule de la String en un caractÃ¨re minuscule; ğŸ‘ Convertis chaque caractÃ¨re alphabÃ©tique minuscule de la String en un caractÃ¨re majuscule; ğŸ‘ Supprime tous les caractÃ¨res spÃ©ciaux de la String; Exercice 2 : Soit le tableau suivant: String [] days = { \"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\", \"Dimanche\"}; Ã‰crire un programme en Java qui:\nğŸ‘ choisi alÃ©atoirement une journÃ©e du tableau et lâ€™affiche; ğŸ‘ Tri le tableau; Exercice 3 : Soit le code Java suivant:\nString str1 = \"Bonjour\"; String str2 = new String (\"Bonjour\"); str1 == str2; //3 str1.equals(str2); //4\rExpliquez la diffÃ©rence entre les 02 lignes de code (ligne 3 et ligne 4)?\nExercice 4 : Soit la classe Compte bancaire avec les attributs suivants:\nidCpte (numÃ©ro unique: donc 2 comptes ne peuvent pas avoir le mÃªme ID); firstName; lastName; solde; En utilisant les collections Java (List, Set et Map) et en vous utilisant lâ€™API Java, vous devez coder les mÃ©thodes suivantes:\nğŸ‘ addCompteToCollection (List | Set | Map)\rğŸ‘ serachCompteInCollection (List | Set | Map)\rğŸ‘ sortCollection (List | Set | Map)\rğŸ‘ removeCompteFromCollection (List | Set | Map)\rğŸ‘ emptyCollectionComptes (List | Set | Map)\rExercice 5 : Ã‰crire un code Java qui convertit un tableau dâ€™entiers (tableau Ã  crochets) en une collection de type List.\nÃ‰crire un code Java qui convertit une collection de type List en un tableau Ã  crochets.\nÃ‰crire un code Java qui convertit une collection de type List en une collection de Type Set.\nÃ‰crire un code Java qui convertit une collection de type Set en une collection de Type List.\nÃ‰crire un code Java qui convertit une collection de type List en une collection de Type Map.\nÃ‰crire un code Java qui convertit une collection de type Map en une collection de Type List.\nExercice 6 : Soit le tableau de conversion des devises suivant :\nDe Vers Taux Dollar canadien (CAD) Euro 1 CAD = 0.74 EURO Dollar canadien (CAD) Dollar amÃ©ricain (USD) 1 CAD = 0.69 USD Euro Dollar canadien (CAD) 1 EURO = 1.45 CAD Dollar amÃ©ricain (USD) Dollar canadien (CAD) 1 USD = 1.36 CAD Ã‰crire un programme Java qui demande Ã  un utilisateur de choisir un type conversion et saisir un montant Ã  convertir. Le programme traitera la conversion et affichera le montant converti.\nCondition:\nLe programme nâ€™acceptera que les montants entre 90 et 6500, cela dans chaque sorte de devises. Le programme ne doit pas sâ€™arrÃªter tant que lâ€™utilisateur nâ€™aura pas choisi de quitter. Exercice 7 : Soit le systÃ¨me de notation universitaire :\nNote numÃ©rique Note littÃ©rale 90 et + A De 80 Ã  89 B De 70 Ã  79 C De 60 Ã  69 D De 50 Ã  59 E \u003c 50 F Ã‰crire un programme Java qui demande Ã  un utilisateur de saisir 4 notes numÃ©riques. Ensuite le programme calculera la moyenne et affichera la note littÃ©rale correspondante.\nCondition:\nLe programme nâ€™acceptera que les notes entre 0 et 100.\nExemple\nLe programme demande les notes Ã  lâ€™utilisateur : Veuillez saisir vos notes Svp : Lâ€™utilisateur saisit les notes suivantes : 59, 72.5, 83.73, 45.5\nLe programme calculera la moyenne et affichera :\nVotre moyenne numÃ©rique est : 65,18 ce qui donnera en littÃ©rale la note de D.\nExercice 8 : Soit la liste des villes suivantes : Ottawa, Paris, Berne, Washington, Berlin, Madrid, Mexico.\nğŸŒ¼ Ã‰crire un programme Java qui gÃ©nÃ¨re alÃ©atoirement 2 villes parmi la liste des villes et demandera Ã  un utilisateur de deviner les 2 villes au bout de 3 tentatives.\nSi lâ€™utilisateur arrive Ã  deviner les 2 villes alÃ©atoires, le programme affichera un message et quittera. Si lâ€™utilisateur nâ€™arrive pas Ã  deviner les 2 villes alÃ©atoires au bout de 3 tentatives, le programme affichera le rÃ©sultat et quittera. Clarification\nModÃ¨le de message en cas de succÃ¨s de devinette Bravo! Vous avez devinÃ© les 2 villes : Ottawa et Paris. ModÃ¨le de message en cas dâ€™Ã©chec de devinette Oups! En 3 tentatives, vous nâ€™Ãªtes pas arrivÃ© Ã  deviner les 2 villes : Ottawa et Paris. Exercice 9 : On souhaite gÃ©rer une liste de prÃ©noms dâ€™Ã©tudiants dans un cours. RÃ©alise un programme Java qui :\nCrÃ©e une liste de type ArrayList. Ajoute les prÃ©noms suivants : â€œAliceâ€, â€œBobâ€, â€œCharlieâ€, â€œDianeâ€. Affiche la taille de la liste et son contenu. Demande Ã  lâ€™utilisateur dâ€™entrer un prÃ©nom, puis : VÃ©rifie sâ€™il est prÃ©sent dans la liste (affiche un message appropriÃ©). Si prÃ©sent, affiche sa position dans la liste. Supprime un prÃ©nom donnÃ© par lâ€™utilisateur et rÃ©affiche la liste. Trie la liste par ordre alphabÃ©tique et affiche le rÃ©sultat. Exercice 10 : Soit le diagramme de classes suivant :\nCrÃ©er les classes Java correspondant aux classes du diagramme. Il vous faudra respecter les attributs et les relations entre les diffÃ©rentes classes. Ã‰crire une mÃ©thode de service qui permet de calculer le prix rÃ©el dâ€™un produit suivant la rÃ¨gle suivante : a.\tSi le produit est biologique, Â« indiceBio Â» et le produit appartiennent Ã  un fournisseur habitant la province du Â« QuÃ©bec Â», alors le prix rÃ©el est :\ni.\tPrix rÃ©el = prix du produit + prix du produit*tps + prix du produit * tvq. b.\tSi le produit est biologique, Â« indiceBio Â» et le produit appartiennent Ã  un fournisseur habitant le Canada (sauf la province du QuÃ©bec) alors le prix rÃ©el est :\ni.\tPrix rÃ©el = prix du produit + prix du produit*tps. c.\tSi le produit est biologique Â« indiceBio Â» et le produit appartient Ã  un fournisseur habitant les USA alors le prix rÃ©el est :\ni.\tPrix rÃ©el = prix du produit + prix du produit*usTax. Ã‰crire une mÃ©thode de service qui permet de calculer le total prix (la somme totale) des produits de tous les fournisseurs amÃ©ricains.",
    "description": "Questions thÃ©oriques Question 1 : Quel est le rÃ©sultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le rÃ©sultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le rÃ©sultat du code suivant:",
    "tags": [],
    "title": "Questions et exercices",
    "uri": "/420-311/intro/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code dâ€™Ã©vÃ©nement dans le bandeau supÃ©rieur Quiz 2 : mÃ©thodes et interfaces Quiz Wooclap sur les mÃ©thodes et les interfaces",
    "description": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code dâ€™Ã©vÃ©nement dans le bandeau supÃ©rieur Quiz 2 : mÃ©thodes et interfaces Quiz Wooclap sur les mÃ©thodes et les interfaces",
    "tags": [],
    "title": "Quiz",
    "uri": "/420-311/intro/quiz/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ ComplexitÃ© algorithmique",
    "content": "Quâ€™est-ce que la complexitÃ© algorithmique ? La complexitÃ© algorithmique dÃ©signe en informatique la quantitÃ© de ressources quâ€™un algorithme consomme lors de son exÃ©cution (On utilise Grand O pour dÃ©crire la performance dâ€™une algorithme). Elle se dÃ©cline en deux dimensions principales :\nLa complexitÃ© temporelle, qui mesure le temps dâ€™exÃ©cution. La complexitÃ© spatiale, qui Ã©value la mÃ©moire supplÃ©mentaire requise en dehors des donnÃ©es dâ€™entrÃ©e. Ces deux aspects sont indÃ©pendants : un algorithme peut Ãªtre trÃ¨s rapide mais consommer beaucoup de mÃ©moire, ou inversement.\nPour bien Ã©valuer un algorithme, il faut examiner son comportement dans diffÃ©rents contextes :\nle meilleur cas, le pire cas (souvent privilÃ©giÃ© pour anticiper les situations extrÃªmes), et le cas moyen, qui reflÃ¨te son usage habituel. Comparer la complexitÃ© de plusieurs algorithmes rÃ©solvant le mÃªme problÃ¨me permet ainsi de choisir la solution la plus adaptÃ©e en fonction des contraintes de performance.\nComment et pourquoi mesurer la complexitÃ© ? Pour mesurer la complexitÃ© dâ€™un algorithme, on utilise la notation Big O, Ã©crite sous la forme O(f(n)). Elle exprime la croissance du temps ou de la mÃ©moire nÃ©cessaires en fonction de la taille de lâ€™entrÃ©e, gÃ©nÃ©ralement notÃ©e n.\nLe but de cette notation est de mettre en Ã©vidence le comportement asymptotique : comment lâ€™algorithme Ã©volue lorsque n devient trÃ¨s grand. On ignore donc les dÃ©tails secondaires (constantes et termes mineurs) pour ne retenir que le terme dominant. Par exemple, une complexitÃ© exacte de 3nÂ² + 5n + 7 se rÃ©sume en O(nÂ²), puisque nÂ² domine pour de grandes valeurs de n.\nUn programme qui fonctionne nâ€™est pas forcÃ©ment efficace.\nExemple concret :\nRechercher un mot dans un dictionnaire papier (O(log n)). Rechercher une photo dans une pile dÃ©sordonnÃ©e (O(n)). Plus les donnÃ©es sont grosses, plus le choix de lâ€™algorithme est critique.\nNotation Big-O (pire cas) La notation Big-O dÃ©crit comment le temps dâ€™exÃ©cution Ã©volue en fonction de la taille de lâ€™entrÃ©e (n).\nComplexitÃ© Exemple InterprÃ©tation O(1) AccÃ¨s Ã  un tableau par index Constant O(log n) Recherche binaire Logarithmique : croissance lente O(n) Parcours dâ€™une liste LinÃ©aire O(n log n) Tri rapide/merge sort Plus rapide que O(nÂ²) O(nÂ²) Doubles boucles imbriquÃ©es Quadratique : explose vite O(2^n) ProblÃ¨mes combinatoires Exponentielle : impraticable ğŸ’¡ RÃ¨gle dâ€™or :\nPour n petit, toutes les mÃ©thodes semblent rapides. Pour n grand, seules les bonnes structures/algorithmes tiennent la route. Exemples en Java ğŸ”¹ O(1) â€“ Affichage simple public static void affiche(int[] tab) { // O(1) System.out.println(tab[0]); }\rAussi :\npublic static void affiche(int[] tab) { // O(2) qui sera simplifÃ©e Ã  O(1) System.out.println(tab[0]); System.out.println(tab[1]); }\rğŸ”¹ O(n) â€“ Boucle (itÃ©ration sur tous les Ã©lements) public static void afficheTableau(int[] tab) { // O(n) for (int num : tab) { System.out.println(num); } }\rMÃªme chose pour les boucles for, while et do while\nğŸ”¹ O(n ^ 2) â€“ Boucle inbriquÃ©e public static void afficheTableau2D(int[] tab) { // O(n ^ 2) for (int num1 : tab) { for (int num2 : tab) { System.out.println(num1 * num2); } } }\rğŸ”¹ O(log n) â€“ Recherche binaire âš ï¸ NÃ©cessite un tableau triÃ©.\npublic static boolean rechercheBinaire(int[] tab, int val) { int g = 0, d = tab.length - 1; while (g \u003c= d) { int m = (g + d) / 2; if (tab[m] == val) return true; if (tab[m] \u003c val) g = m + 1; else d = m - 1; } return false; }\rSi nous cherchant dans un tableau dâ€™un million dâ€™Ã©lÃ©ments, 19 comparaisons seront suffusantes pour trouver lâ€™Ã©lÃ©ment recherchÃ©.\nğŸ”¹ Comparaison avec des exemples import java.util.*; public class Bench { public static void main(String[] args) { int n = 1_000_000; int[] tab = new int[n]; for (int i = 0; i \u003c n; i++) tab[i] = i; int cible = n - 1; // Recherche linÃ©aire long t1 = System.nanoTime(); rechercheLineaire(tab, cible); long t2 = System.nanoTime(); System.out.println(\"Lineaire : \" + (t2 - t1) / 1_000_000.0 + \" ms\"); // Recherche binaire long t3 = System.nanoTime(); rechercheBinaire(tab, cible); long t4 = System.nanoTime(); System.out.println(\"Binaire : \" + (t4 - t3) / 1_000_000.0 + \" ms\"); } public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) if (x == val) return true; return false; } public static boolean rechercheBinaire(int[] tab, int val) { int g = 0, d = tab.length - 1; while (g \u003c= d) { int m = (g + d) / 2; if (tab[m] == val) return true; if (tab[m] \u003c val) g = m + 1; else d = m - 1; } return false; } }\rOn peut dire que :\nUn algorithme linÃ©aire, qui met une seconde Ã  traiter un tableau Ã  100 Ã©lÃ©ments, mettra 100 secondes Ã  traiter un tableau Ã  10 000 Ã©lÃ©ments. Un algorithme quadratique qui met Ã©galement une seconde Ã  traiter le cas dâ€™un tableau Ã  100 Ã©lÃ©ments mettra 10 000 secondes (soit prÃ¨s de trois heures) Ã  traiter le cas du tableau Ã  10 000 Ã©lÃ©ments. Un algorithme en O(2n) qui mettrait aussi une seconde avec 100 Ã©lÃ©ments qui mettrait 2100 secondes Ã  traiter ne serait-ce que 200 Ã©lÃ©ments, soit environ 4.1022 annÃ©es (4000 milliards de milliards dâ€™annÃ©es). Analyse de boucles Boucle simple for (int i=0; i\u003cn; i++) â†’ O(n). Boucles imbriquÃ©es for i, for j â†’ O(nÂ²). Boucle divisant par 2 while (n \u003e 1) n/=2 â†’ O(log n). ComplexitÃ© spatiale (mÃ©moire) La complexitÃ© spatiale (ou complexitÃ© mÃ©moire) mesure la quantitÃ© de mÃ©moire nÃ©cessaire pour exÃ©cuter un algorithme en fonction de la taille de lâ€™entrÃ©e (n).\nğŸ’¡ On ne parle pas seulement de la mÃ©moire des donnÃ©es initiales, mais aussi :\nde la mÃ©moire supplÃ©mentaire utilisÃ©e par lâ€™algorithme (variables, structures temporaires, pile dâ€™appels).\nO(1) : pile, file, liste chaÃ®nÃ©e â†’ mÃ©moire proportionnelle aux donnÃ©es. O(n) : tableau de n Ã©lÃ©ments. O(nÂ²) : matrice dâ€™adjacence pour un graphe. Exemple 1 : ComplexitÃ© spatiale O(1)\npublic static void afficheTableau(int[] tab) { // O(1) space for (int num : tab) { System.out.println(num); } }\rExemple 2 : ComplexitÃ© spatiale O(n)\npublic static void afficheTableau(int[] tab) { // O(n) space (c'est l'espace qu'on a allouÃ© Ã  l'iterieur de cette mÃ©thode) int[] tabCopy = new int[tab.length]; for (int num : tab) { System.out.println(num); } }\rExemple 3 : ComplexitÃ© spatiale O(n) (rÃ©cursion)\npublic static int factoriel(int n) { // O(n) space if (n == 0) return 1; return n * factoriel(n - 1); }\rExercices Quelle est la complexitÃ© de :\nfor (int i=0; i\u003cn; i++) for (int j=0; j\u003cn; j++) System.out.println(i + \",\" + j);\rQuelle est la complexitÃ© de :\nfor (int i=0; i\u003cn; i*=2) System.out.println(i);\rQuelle est la complexitÃ© spatiale dâ€™un tableau int[1000][1000] ?\nFiche synthÃ¨se ComplexitÃ© temporelle â†’ combien de temps Ã§a prend.\nComplexitÃ© spatiale â†’ combien de mÃ©moire Ã§a utilise.\nParfois, il faut choisir :\nMoins de temps mais plus de mÃ©moire (ex. table de hachage).\nMoins de mÃ©moire mais plus de temps (ex. recherche linÃ©aire dans une liste).\nOn utilise la notion grand O (Big O) pour mesurer la complexitÃ© :\nO(1) : accÃ¨s direct. O(log n) : recherche dichotomique, arbres Ã©quilibrÃ©s. O(n) : parcours dâ€™une collection. O(n log n) : tris efficaces. O(nÂ²) : algorithmes naÃ¯fs Ã  doubles boucles. O(2^n) : problÃ¨mes combinatoires â†’ Ã  Ã©viter.",
    "description": "Quâ€™est-ce que la complexitÃ© algorithmique ? La complexitÃ© algorithmique dÃ©signe en informatique la quantitÃ© de ressources quâ€™un algorithme consomme lors de son exÃ©cution (On utilise Grand O pour dÃ©crire la performance dâ€™une algorithme). Elle se dÃ©cline en deux dimensions principales :\nLa complexitÃ© temporelle, qui mesure le temps dâ€™exÃ©cution. La complexitÃ© spatiale, qui Ã©value la mÃ©moire supplÃ©mentaire requise en dehors des donnÃ©es dâ€™entrÃ©e. Ces deux aspects sont indÃ©pendants : un algorithme peut Ãªtre trÃ¨s rapide mais consommer beaucoup de mÃ©moire, ou inversement.",
    "tags": [],
    "title": "ComplexitÃ© algorithmique",
    "uri": "/420-311/complexalgo/complexalgo/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Ressources utiles",
    "content": "Introduction Ã  Git Git est un logiciel de contrÃ´le de version. Il permet de gÃ©rer des fichiers et leur Ã©volution dans le temps.\nIl permet de retracer lâ€™origine de chaque modification, de rÃ©tablir des versions prÃ©cÃ©dentes et permet lâ€™intÃ©gration de modifications effectuÃ©es en parallÃ¨le.\nConcept Le principe dâ€™un gestionnaire de version est quâ€™il gÃ¨re un document comme â€œune baseâ€ Ã  laquelle est ajoutÃ© une suite de modifications.\nIl y a un dÃ©pÃ´t commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsquâ€™un contributeur a rÃ©alisÃ© une modification qui est prÃªte Ã  lâ€™envoyer, il pousse (push) celle-ci vers le dÃ©pÃ´t. Le dÃ©pÃ´t garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version dÃ©centralisÃ©. Il y a 2 dÃ©pÃ´ts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez rÃ©cupÃ©rer le code de votre repository (dÃ©pÃ´t remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configurÃ© la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de dÃ©poser les modifications sur une dÃ©pÃ´t local. Il faut Ã©galement Ãªtre vigilant au niveau de la branche utilisÃ© pour le commit. De plus, il est important de mettre souvent Ã  jour la branche avant de procÃ©der Ã  un commit.\nLorsquâ€™on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour rÃ©fÃ©rer Ã  la tÃ¢che en cours. AprÃ¨s cet identifiant, on peut y mettre une description. Par exemple:\nâ€œPRJ-3428: Ajout de tests unitaires sur la mÃ©thode du service getClientsâ€\nLorsquâ€™on relie lâ€™identifiant et les commits, on peut alors connaÃ®tre le travail effectuÃ© dans le code pour une tÃ¢che donnÃ©e dans le systÃ¨me de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandÃ© de faire un git fetch / pull avant de procÃ©der Ã  celui-ci. Ã€ moins dâ€™Ãªtre seul dans ce repository et/ou la branche visÃ©e.\nGit Fetch, checkout, pull La commande git fetch permet de mettre Ã  jour notre dÃ©pÃ´t local en rÃ©cupÃ©rant lâ€™ Ã©tat courant qui remote. La commande git checkout permet de les appliquer Ã  la copie de travail (et donc de les voir).\nLa commande git pull fait les deux Ã  la fois.\nPensez Ã  vous mettre Ã  jour avant chaque session de travail !\nCâ€™est la premiÃ¨re chose quâ€™un dÃ©veloppeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaÃ®tre lâ€™Ã©tat courant de vos copies locales (les modifications ont-elles Ã©tÃ© commitÃ©es, les fichiers ajoutÃ©s, les commit pushÃ©).\nLes interface graphiques (dont intelliJ) vous lâ€™indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectuÃ©. Ces commit peuvent Ãªtre fort utili pour faire dâ€™autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet dâ€™appliquer les changements (fusionner) dâ€™une autre branche Ã  votre branche sÃ©lectionnÃ©e dans votre repository locale. Il y a souvent des conflits lors dâ€™une fusion. Surtout si vous avez travailler dans un mÃªme fichier quâ€™un ou une de vos collÃ¨gues.\nVous devez tenter de rÃ©soudre les conflits avec des outils en ligne de commande ou Ã  lâ€™aide dâ€™un interface graphique. Câ€™est une habilitÃ© Ã  acquÃ©rir avec le temps. Câ€™est parfois trÃ¨s complexe et si lâ€™opÃ©ration nâ€™est pas effectÃ©e avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste Ã  changer la base de votre branche dâ€™un commit vers un autre, donnant lâ€™illusion que vous avez crÃ©Ã© votre branche Ã  partir dâ€™un commit diffÃ©rent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder lâ€™Ã©tat actuel de votre rÃ©pertoire de travail. Câ€™est possible de le faire avec git stash et de revenir Ã  un rÃ©pertoire de travail propre sans ces modifications. Vous pourrez ensuite rÃ©cupÃ©rer ce travail en utilisant le nom que vous lui aurez donnÃ©. Vous pouvez en avoir plusieurs sauvegardÃ©s dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// RÃ©cupÃ©rer les changements prÃ©cÃ©dents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalitÃ© si vous avez terminÃ©.\nNe pas prendre les branches pour plusieurs fonctionnalitÃ©s. SÃ©parez vos tÃ¢ches en plus petites et faites des commits plus souvent.\nRÃ©cupÃ©rer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre Ã©quipe vos intentions! Ne travaillez pas sur les mÃªmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillÃ© sur une fonctionnalitÃ© ou un fix.\nAvant le jour de la mise en production. Vous devriez crÃ©er une branche Ã  partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visÃ©e vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les Ã©lÃ©ments. Testez que votre branche fonctionne et quâ€™elle est bien compilÃ©e. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront dÃ©jÃ  Ã©tÃ© rÃ©solus! Bingo.\nGitflow Pour maintenir une certain cohÃ©sion en entreprise, un modÃ¨le de branche a Ã©tÃ© proposÃ©. Il implique de sÃ©parer les branches de dÃ©veloppement et les branches primaires qui sont dÃ©ployÃ©s dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRÃ©fÃ©rence Richard E. Silverman (2013), Git Pocket Guide, Oâ€™Reilly\nAlice Jacquot, Introduction Ã  Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction Ã  Git Git est un logiciel de contrÃ´le de version. Il permet de gÃ©rer des fichiers et leur Ã©volution dans le temps.\nIl permet de retracer lâ€™origine de chaque modification, de rÃ©tablir des versions prÃ©cÃ©dentes et permet lâ€™intÃ©gration de modifications effectuÃ©es en parallÃ¨le.\nConcept Le principe dâ€™un gestionnaire de version est quâ€™il gÃ¨re un document comme â€œune baseâ€ Ã  laquelle est ajoutÃ© une suite de modifications.\nIl y a un dÃ©pÃ´t commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-311/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ ComplexitÃ© algorithmique",
    "content": "Exercices â€“ ComplexitÃ© temporelle ğŸ”¹ Exercice 1 : for (int i = 0; i \u003c n; i++) { System.out.println(i); }\rğŸ‘‰ Quelle est la complexitÃ© temporelle en fonction de n ?\nğŸ”¹ Exercice 2 while (n \u003e 1) { n = n / 2; }\rğŸ‘‰ Quelle est la complexitÃ© temporelle ?\nğŸ”¹ Exercice 3 public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) { if (x == val) return true; } return false; }\rğŸ‘‰ Quelle est la complexitÃ© temporelle dans le pire cas ?\nğŸ”¹Exercice 4 public static void insertionSort(int[] tab) { for (int i = 1; i \u003c tab.length; i++) { int cle = tab[i]; int j = i - 1; while (j \u003e= 0 \u0026\u0026 tab[j] \u003e cle) { tab[j+1] = tab[j]; j--; } tab[j+1] = cle; } }\rğŸ‘‰ Quelle est la complexitÃ© dans le meilleur cas et dans le pire cas ?\nğŸ”¹Exercice 5 Classez les algorithmes suivants du plus rapide au plus lent quand n devient trÃ¨s grand :\nO(n) O(n log n) O(nÂ²) ğŸ”¹Exercice 6 Vous avez ce code :\nfor (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j *= 2) { System.out.println(i + \",\" + j); } }\rğŸ‘‰ Quelle est la complexitÃ© de cet algorithme ? Expliquez.\nğŸ”¹Exercice 7 public static int somme(int[] tab) { int total = 0; for (int n : tab) { total += n; } return total; }\rğŸ‘‰ Question : Quelle est la complexitÃ© spatiale de cette mÃ©thode ? Justifiez votre rÃ©ponse.\nğŸ”¹Exercice 8 public static int[] doubleTableau(int[] tab) { int[] resultat = new int[tab.length]; for (int i = 0; i \u003c tab.length; i++) { resultat[i] = tab[i] * 2; } return resultat; }\rğŸ‘‰ Question : Combien de mÃ©moire supplÃ©mentaire est utilisÃ©e par rapport Ã  la taille de lâ€™entrÃ©e n ?\nğŸ”¹Exercice 9 int[][] matrice = new int[n][n];\rğŸ‘‰ Question : Quelle est la complexitÃ© spatiale de cette structure ?\nğŸ”¹Exercice 10 On veut calculer la suite de Fibonacci :\nVersion rÃ©cursive simple :\npublic static int fib(int n) { if (n \u003c= 1) return n; return fib(n - 1) + fib(n - 2); }\rVersion avec mÃ©moÃ¯sation :\npublic static int fibMemo(int n, int[] memo) { if (memo[n] != 0) return memo[n]; if (n \u003c= 1) return n; memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo); return memo[n]; }\rğŸ‘‰ Questions :\nQuelle est la complexitÃ© spatiale des deux versions ? Pourquoi la version avec mÃ©moÃ¯sation consomme plus de mÃ©moire mais gagne en temps ? ğŸ”¹Exercice 11 : Ã‰crivez un programme qui :\nCrÃ©ez un tableau de 1 million dâ€™entiers. CrÃ©ez une LinkedList et un ArrayList chacun contenant 1 million dâ€™entiers. Comparez la mÃ©moire consommÃ©e (avec Runtime.getRuntime().totalMemory() - freeMemory()) pour chaque structure. Observer concrÃ¨tement lâ€™impact de la structure choisie sur la mÃ©moire. Que remarquez vous ?",
    "description": "Exercices â€“ ComplexitÃ© temporelle ğŸ”¹ Exercice 1 : for (int i = 0; i \u003c n; i++) { System.out.println(i); }\rğŸ‘‰ Quelle est la complexitÃ© temporelle en fonction de n ?\nğŸ”¹ Exercice 2 while (n \u003e 1) { n = n / 2; }\rğŸ‘‰ Quelle est la complexitÃ© temporelle ?\nğŸ”¹ Exercice 3 public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) { if (x == val) return true; } return false; }\rğŸ‘‰ Quelle est la complexitÃ© temporelle dans le pire cas ?",
    "tags": [],
    "title": "ğŸ“ Exercices sur complexitÃ© algorithmique",
    "uri": "/420-311/complexalgo/exercices/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Objectifs gÃ©nÃ©raux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de donnÃ©es.\nÃ‰valuer et comparer la complexitÃ© algorithmique des opÃ©rations (temps et mÃ©moire).\nUtiliser des fils dâ€™exÃ©cution (threads) pour exÃ©cuter plusieurs tÃ¢ches en parallÃ¨le.\nDÃ©velopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi Ã©tudier les structures de donnÃ©es ? Parce quâ€™elles sont au cÅ“ur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de donnÃ©es.\nParce quâ€™elles permettent de rÃ©duire le temps dâ€™exÃ©cution et Ã©conomiser de la mÃ©moire.\nParce quâ€™elles dÃ©veloppent la capacitÃ© Ã  choisir la bonne approche selon un problÃ¨me donnÃ©.\nParce quâ€™elles forment une base solide pour les cours ultÃ©rieurs et pour travailler dans des projets dâ€™envergure.\nCitation classique : Â« Un bon algorithme mal implantÃ© dans une mauvaise structure de donnÃ©es sera inefficace. Une bonne structure de donnÃ©es peut transformer un problÃ¨me complexe en une solution Ã©lÃ©gante. Â»\nğŸŒ¼ Notion de structure de donnÃ©es Le principe de base dâ€™une structure de donnÃ©es, câ€™est de stocker des Ã©lÃ©ments auxquels le programmeur veut pouvoir accÃ©der plus tard. On appelle les diffÃ©rentes utilisations possibles de la structure de donnÃ©es des opÃ©rations.\nğŸŒ¼ Les structures de donnÃ©es en Java Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util).\nOn y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nNous commencerons par examiner les concepts communs quâ€™elles (structures de donnÃ©es) exploitent ainsi : gÃ©nÃ©ricitÃ©, itÃ©rateur, ordonnancement et relation dâ€™ordre.\nNous verrons Ã©galement quelles sont les opÃ©rations qui leur sont communes : ajout ou suppression dâ€™Ã©lÃ©ments, construction Ã  partir des Ã©lÃ©ments dâ€™une autre collectionâ€¦\nNous Ã©tudierons ensuite en dÃ©tail chacune de ces structures, Ã  savoir :\nğŸ— Les listes, implÃ©mentÃ©es par la classe LinkedList;\rğŸ— Les vecteurs dynamiques, implÃ©mentÃ©s par les classes ArrayList et Vector;\rğŸ— Les ensembles, implÃ©mentÃ©s par les classes HashSet et TreeSet;\rğŸ— Les queues avec prioritÃ©, implÃ©mentÃ©es par la classe PriorityQueue (introduite par le JDK 5.0) ;\rğŸ— Les queues Ã  double entrÃ©e, implÃ©mentÃ©es par la classe ArrayDeque (introduite par Java6).",
    "description": "Objectifs gÃ©nÃ©raux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de donnÃ©es.\nÃ‰valuer et comparer la complexitÃ© algorithmique des opÃ©rations (temps et mÃ©moire).\nUtiliser des fils dâ€™exÃ©cution (threads) pour exÃ©cuter plusieurs tÃ¢ches en parallÃ¨le.\nDÃ©velopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi Ã©tudier les structures de donnÃ©es ? Parce quâ€™elles sont au cÅ“ur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de donnÃ©es.",
    "tags": [],
    "title": "Structures de donnÃ©e",
    "uri": "/420-311/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-311/categories/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-311/tags/index.html"
  }
]
