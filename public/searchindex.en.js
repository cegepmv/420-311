var relearn_searchindex = [
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Dans ce module nous ferons une courte rÃ©vision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte rÃ©vision des notions essentielles au cours.",
    "tags": [],
    "title": "PrÃ©alables",
    "uri": "/420-311/intro/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Rappel : Concepts de base Classe : ModÃ¨le dÃ©finissant les attributs (variables) et comportements (mÃ©thodes).\nObjet : Instance concrÃ¨te dâ€™une classe.\nEncapsulation : ProtÃ©ger les donnÃ©es via des modificateurs dâ€™accÃ¨s (private, public, protected) et exposer des mÃ©thodes dâ€™accÃ¨s (getters/setters).\nAbstraction : Masquer les dÃ©tails dâ€™implÃ©mentation et ne montrer que les fonctionnalitÃ©s essentielles (via classes abstraites et interfaces).\nHÃ©ritage : Une classe peut hÃ©riter des attributs et mÃ©thodes dâ€™une autre (mot-clÃ© extends).\nPolymorphisme :\nSurcharge (overloading) : mÃªme nom de mÃ©thode, signatures diffÃ©rentes. RedÃ©finition (overriding) : une sous-classe redÃ©finit le comportement dâ€™une mÃ©thode hÃ©ritÃ©e. Constructeur : MÃ©thode spÃ©ciale exÃ©cutÃ©e lors de la crÃ©ation dâ€™un objet (new).\nModificateurs dâ€™accÃ¨s Modificateur MÃªme classe MÃªme package Sous-classe Partout public âœ… âœ… âœ… âœ… protected âœ… âœ… âœ… âŒ (default) âœ… âœ… âŒ âŒ private âœ… âŒ âŒ âŒ Syntaxe essentielle DÃ©finir une classe public class Voiture { private String marque; private int annee; public Voiture(String marque, int annee) { this.marque = marque; this.annee = annee; } public void demarrer() { System.out.println(marque + \" dÃ©marre !\"); } }\rCrÃ©er un objet Voiture v1 = new Voiture(\"Toyota\", 2022); v1.demarrer();\rHÃ©ritage et polymorphisme class Animal { public void parler() { System.out.println(\"??\"); } } class Chien extends Animal { @Override public void parler() { System.out.println(\"Woof\"); } } Animal a = new Chien(); // polymorphisme a.parler(); // \"Woof\"\rAbstraction et interfaces abstract class Forme { abstract double aire(); } class Cercle extends Forme { private double r; Cercle(double r) { this.r = r; } @Override double aire() { return Math.PI * r * r; } } interface Volant { void voler(); } class Avion implements Volant { public void voler() { System.out.println(\"En vol âœˆï¸\"); } }\rClasses utiles Object : classe racine de toutes les classes Java. MÃ©thodes importantes : toString(), equals(), hashCode(), clone().\nfinal :\nfinal class : non-hÃ©ritÃ©e. final method : non-redÃ©finissable. final variable : constante. Gestion mÃ©moire Les objets sont crÃ©Ã©s sur le tas (heap) via new. Le garbage collector libÃ¨re automatiquement la mÃ©moire des objets non rÃ©fÃ©rencÃ©s. Bonnes pratiques Utiliser private pour protÃ©ger les donnÃ©es. Toujours redÃ©finir toString() pour reprÃ©senter un objet. Respecter la cohÃ©rence equals() / hashCode(). Favoriser la composition plutÃ´t que lâ€™hÃ©ritage trop profond. Documenter avec JavaDoc (/** â€¦ */). Exemple : package s01; class Etudiant { private String nom; private int age; public Etudiant(String nom, int age) { this.nom = nom; this.age = age; } public void afficherInfos() { System.out.println(\"Nom : \" + nom + \", Ã‚ge : \" + age); } } class EtudiantRegulier extends Etudiant { private String programme; public EtudiantRegulier(String nom, int age, String programme) { super(nom, age); this.programme = programme; } @Override public void afficherInfos() { super.afficherInfos(); System.out.println(\"Programme : \" + programme); } } public class RappelPOO { public static void main(String[] args) { EtudiantRegulier e = new EtudiantRegulier(\"Alice\", 20, \"Informatique\"); e.afficherInfos(); } }",
    "description": "Rappel : Concepts de base Classe : ModÃ¨le dÃ©finissant les attributs (variables) et comportements (mÃ©thodes).\nObjet : Instance concrÃ¨te dâ€™une classe.\nEncapsulation : ProtÃ©ger les donnÃ©es via des modificateurs dâ€™accÃ¨s (private, public, protected) et exposer des mÃ©thodes dâ€™accÃ¨s (getters/setters).\nAbstraction : Masquer les dÃ©tails dâ€™implÃ©mentation et ne montrer que les fonctionnalitÃ©s essentielles (via classes abstraites et interfaces).\nHÃ©ritage : Une classe peut hÃ©riter des attributs et mÃ©thodes dâ€™une autre (mot-clÃ© extends).",
    "tags": [],
    "title": "RÃ©vision",
    "uri": "/420-311/intro/revisionpoo/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Exercices thÃ©oriques Exercice 1 : Quel est le rÃ©sultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rExercice 2 : Quel est le rÃ©sultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rExercice 3 : Quel est le rÃ©sultat du code suivant:\npublic class Question3 { public static void main(String[]args) { int val1 = 9; int val2 = 9; String str = \"9\"; System.out.println(val1 + val2 + str);\t} }\rExercice 4 : Quel est le rÃ©sultat du code suivant:\npublic class Question4 { public static void main(String[]args) { try { int a, b; b = 0; a = 5 / b; System.out.print(\"A\"); } catch (Exception e) { System.out.print(\"B\"); } finally { System.out.print(\"C\"); }\t} }\rExercice 5 : Quel est le rÃ©sultat du code suivant:\npublic class Question5 { public static void main(String[]args) { String obj = \"Bonjour\"; String obj1 = \"Bonsoir\"; String obj2 = \"Bonjour\"; System.out.println(obj.equals(obj1) + \" \" + obj.equals(obj2)); } }\rExercice 6 : Quel est le rÃ©sultat du code suivant:\npublic class ClasseA { public int i; public int j; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.j = 3; System.out.println(i + \" \" + j); } } public class Question6 { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rExercice 7 : Quel est le rÃ©sultat du code suivant:\npublic class ClasseA { public int i; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.i = j + 1; System.out.println ( j + \" \" + i); } } public class Main { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rExercice 8 : Quel est le rÃ©sultat du code suivant:\npublic class Question8{ public static void main(String[] args) { String s = \"Hello World\"; int A = s.indexOf('o'); int B = s.lastIndexOf('l'); System.out.println(A + \" \" + B); } }\rExercice 9 : Quel est le rÃ©sultat du code suivant:\npublic class Question9{ public static void main(String[] args) { char ch; ch = \"hello\".charAt(1); System.out.println(ch); } }\rExercice 10 : Quel est le rÃ©sultat du code suivant:\npublic class Question10{ public static void main(String[] args) { String chars[] = {\"a\", \"b\", \"c\", \"a\", \"c\"}; for (int i = 0; i \u003c chars.length; ++i) for (int j = i + 1; j \u003c chars.length; ++j) if(chars[i].compareTo(chars[j]) == 0) System.out.print(chars[j]); } }\rExercice 11 : Quel est le rÃ©sultat du code suivant:\npublic class Question11{ public static void main(String[] args) { int a1[] = new int[10]; int a2[] = { 1, 2, 3, 4, 5 }; System.out.println(a1.length + \" \" + a2.length); } }\rExercice 12 : Quel est le rÃ©sultat du code suivant:\npublic class Question12{ public static void main(String[] args) { int arr[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i \u003c arr.length - 2; ++i) System.out.print(arr[i] + \" \"); } }\rExercice 13 : Quel est le rÃ©sultat du code suivant:\npublic class Question13{ public static int param1; public static int param2; public void add(int a, int b) { param1 = a + b; param2 = param1 + b; } public static void main(String args[]) { Question13 obj1 = new Question13(); Question13 obj2 = new Question13(); int a = 2; obj1.add(a, a + 1); obj2.add(5, a); System.out.println(obj1.param1 + \" \" + obj2.param2); } }\rExercice 14 : Quel est le rÃ©sultat du code suivant:\nimport java.util.Arrays; public class Question14{ public static void main(String[] args) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rExercice 15 : Quel est le rÃ©sultat du code suivant:\npublic class Question15{ public static int param1; public void increment() { param1++; } public static void main(String args[]) { Question15 obj1 = new Question15(); Question15 obj2 = new Question15(); obj1.param1 = 0; obj1.increment(); obj2.increment(); System.out.println(obj1.param1 + \" \" + obj2.param1); } }\rExercice 19 : Question Vrai/Faux OUI âœ” NON âŒ NSP â— 1- Est-ce que je peux instancier une Interface? â„ï¸ 2- Est-ce quâ€™une interface est un objet? â›„ 3- Est-ce quâ€™une interface hÃ©rite de la classe Object? âš¡ 4- Est-ce quâ€™une interface peut hÃ©riter dâ€™une autre interface? â˜ï¸ 5- Est-ce quâ€™une interface peut hÃ©riter dâ€™une classe? â˜” 6- Est-ce quâ€™une classe peut-Ãªtre Â« private Â»? ğŸŒŠ 7- Est-ce que chaque classe Java possÃ¨de la mÃ©thode Â« toString() Â»? â„ï¸ 8- Est-ce que le constructeur dâ€™une classe peut Ãªtre Â« private Â»? â›„ 9- Est-ce que chaque classe Java possÃ¨de un constructeur âš¡ 10- Dans une classe Java, est-ce que 02 mÃ©thodes peuvent avoir le mÃªme nom? â˜ï¸ 11- Est-ce quâ€™une interface peut hÃ©riter dâ€™une autre interface? â˜” 12- Est-ce quâ€™une interface peut avoir des mÃ©thodes Â« private Â» avec du code? ğŸŒŠ 13- Est-ce quâ€™une interface peut avoir des mÃ©thodes Â« publicÂ» avec du code? â„ï¸ 14- Est-ce quâ€™une interface peut avoir des mÃ©thodes Â« private Â» avec du code? â›„ 15- Est-ce quâ€™une interface peut Ãªtre instanciÃ©e? âš¡",
    "description": "Exercices thÃ©oriques Exercice 1 : Quel est le rÃ©sultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rExercice 2 : Quel est le rÃ©sultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rExercice 3 : Quel est le rÃ©sultat du code suivant:",
    "tags": [],
    "title": "Exercices",
    "uri": "/420-311/intro/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Ressources utiles",
    "content": "Introduction Ã  Git Git est un logiciel de contrÃ´le de version. Il permet de gÃ©rer des fichiers et leur Ã©volution dans le temps.\nIl permet de retracer lâ€™origine de chaque modification, de rÃ©tablir des versions prÃ©cÃ©dentes et permet lâ€™intÃ©gration de modifications effectuÃ©es en parallÃ¨le.\nConcept Le principe dâ€™un gestionnaire de version est quâ€™il gÃ¨re un document comme â€œune baseâ€ Ã  laquelle est ajoutÃ© une suite de modifications.\nIl y a un dÃ©pÃ´t commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsquâ€™un contributeur a rÃ©alisÃ© une modification qui est prÃªte Ã  lâ€™envoyer, il pousse (push) celle-ci vers le dÃ©pÃ´t. Le dÃ©pÃ´t garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version dÃ©centralisÃ©. Il y a 2 dÃ©pÃ´ts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez rÃ©cupÃ©rer le code de votre repository (dÃ©pÃ´t remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configurÃ© la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de dÃ©poser les modifications sur une dÃ©pÃ´t local. Il faut Ã©galement Ãªtre vigilant au niveau de la branche utilisÃ© pour le commit. De plus, il est important de mettre souvent Ã  jour la branche avant de procÃ©der Ã  un commit.\nLorsquâ€™on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour rÃ©fÃ©rer Ã  la tÃ¢che en cours. AprÃ¨s cet identifiant, on peut y mettre une description. Par exemple:\nâ€œPRJ-3428: Ajout de tests unitaires sur la mÃ©thode du service getClientsâ€\nLorsquâ€™on relie lâ€™identifiant et les commits, on peut alors connaÃ®tre le travail effectuÃ© dans le code pour une tÃ¢che donnÃ©e dans le systÃ¨me de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandÃ© de faire un git fetch / pull avant de procÃ©der Ã  celui-ci. Ã€ moins dâ€™Ãªtre seul dans ce repository et/ou la branche visÃ©e.\nGit Fetch, checkout, pull La commande git fetch permet de mettre Ã  jour notre dÃ©pÃ´t local en rÃ©cupÃ©rant lâ€™ Ã©tat courant qui remote. La commande git checkout permet de les appliquer Ã  la copie de travail (et donc de les voir).\nLa commande git pull fait les deux Ã  la fois.\nPensez Ã  vous mettre Ã  jour avant chaque session de travail !\nCâ€™est la premiÃ¨re chose quâ€™un dÃ©veloppeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaÃ®tre lâ€™Ã©tat courant de vos copies locales (les modifications ont-elles Ã©tÃ© commitÃ©es, les fichiers ajoutÃ©s, les commit pushÃ©).\nLes interface graphiques (dont intelliJ) vous lâ€™indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectuÃ©. Ces commit peuvent Ãªtre fort utili pour faire dâ€™autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet dâ€™appliquer les changements (fusionner) dâ€™une autre branche Ã  votre branche sÃ©lectionnÃ©e dans votre repository locale. Il y a souvent des conflits lors dâ€™une fusion. Surtout si vous avez travailler dans un mÃªme fichier quâ€™un ou une de vos collÃ¨gues.\nVous devez tenter de rÃ©soudre les conflits avec des outils en ligne de commande ou Ã  lâ€™aide dâ€™un interface graphique. Câ€™est une habilitÃ© Ã  acquÃ©rir avec le temps. Câ€™est parfois trÃ¨s complexe et si lâ€™opÃ©ration nâ€™est pas effectÃ©e avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste Ã  changer la base de votre branche dâ€™un commit vers un autre, donnant lâ€™illusion que vous avez crÃ©Ã© votre branche Ã  partir dâ€™un commit diffÃ©rent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder lâ€™Ã©tat actuel de votre rÃ©pertoire de travail. Câ€™est possible de le faire avec git stash et de revenir Ã  un rÃ©pertoire de travail propre sans ces modifications. Vous pourrez ensuite rÃ©cupÃ©rer ce travail en utilisant le nom que vous lui aurez donnÃ©. Vous pouvez en avoir plusieurs sauvegardÃ©s dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// RÃ©cupÃ©rer les changements prÃ©cÃ©dents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalitÃ© si vous avez terminÃ©.\nNe pas prendre les branches pour plusieurs fonctionnalitÃ©s. SÃ©parez vos tÃ¢ches en plus petites et faites des commits plus souvent.\nRÃ©cupÃ©rer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre Ã©quipe vos intentions! Ne travaillez pas sur les mÃªmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillÃ© sur une fonctionnalitÃ© ou un fix.\nAvant le jour de la mise en production. Vous devriez crÃ©er une branche Ã  partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visÃ©e vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les Ã©lÃ©ments. Testez que votre branche fonctionne et quâ€™elle est bien compilÃ©e. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront dÃ©jÃ  Ã©tÃ© rÃ©solus! Bingo.\nGitflow Pour maintenir une certain cohÃ©sion en entreprise, un modÃ¨le de branche a Ã©tÃ© proposÃ©. Il implique de sÃ©parer les branches de dÃ©veloppement et les branches primaires qui sont dÃ©ployÃ©s dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRÃ©fÃ©rence Richard E. Silverman (2013), Git Pocket Guide, Oâ€™Reilly\nAlice Jacquot, Introduction Ã  Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction Ã  Git Git est un logiciel de contrÃ´le de version. Il permet de gÃ©rer des fichiers et leur Ã©volution dans le temps.\nIl permet de retracer lâ€™origine de chaque modification, de rÃ©tablir des versions prÃ©cÃ©dentes et permet lâ€™intÃ©gration de modifications effectuÃ©es en parallÃ¨le.\nConcept Le principe dâ€™un gestionnaire de version est quâ€™il gÃ¨re un document comme â€œune baseâ€ Ã  laquelle est ajoutÃ© une suite de modifications.\nIl y a un dÃ©pÃ´t commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-311/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-311/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Objectifs gÃ©nÃ©raux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de donnÃ©es.\nÃ‰valuer et comparer la complexitÃ© algorithmique des opÃ©rations (temps et mÃ©moire).\nUtiliser des fils dâ€™exÃ©cution (threads) pour exÃ©cuter plusieurs tÃ¢ches en parallÃ¨le.\nDÃ©velopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi Ã©tudier les structures de donnÃ©es ? Parce quâ€™elles sont au cÅ“ur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de donnÃ©es.\nParce quâ€™elles permettent de rÃ©duire le temps dâ€™exÃ©cution et Ã©conomiser de la mÃ©moire.\nParce quâ€™elles dÃ©veloppent la capacitÃ© Ã  choisir la bonne approche selon un problÃ¨me donnÃ©.\nParce quâ€™elles forment une base solide pour les cours ultÃ©rieurs et pour travailler dans des projets dâ€™envergure.\nCitation classique : Â« Un bon algorithme mal implantÃ© dans une mauvaise structure de donnÃ©es sera inefficace. Une bonne structure de donnÃ©es peut transformer un problÃ¨me complexe en une solution Ã©lÃ©gante. Â»\nğŸŒ¼ Notion de structure de donnÃ©es Le principe de base dâ€™une structure de donnÃ©es, câ€™est de stocker des Ã©lÃ©ments auxquels le programmeur veut pouvoir accÃ©der plus tard. On appelle les diffÃ©rentes utilisations possibles de la structure de donnÃ©es des opÃ©rations.\nğŸŒ¼ Les structures de donnÃ©es en Java Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util).\nOn y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nNous commencerons par examiner les concepts communs quâ€™elles (structures de donnÃ©es) exploitent ainsi : gÃ©nÃ©ricitÃ©, itÃ©rateur, ordonnancement et relation dâ€™ordre.\nNous verrons Ã©galement quelles sont les opÃ©rations qui leur sont communes : ajout ou suppression dâ€™Ã©lÃ©ments, construction Ã  partir des Ã©lÃ©ments dâ€™une autre collectionâ€¦\nNous Ã©tudierons ensuite en dÃ©tail chacune de ces structures, Ã  savoir :\nğŸ— Les listes, implÃ©mentÃ©es par la classe LinkedList;\rğŸ— Les vecteurs dynamiques, implÃ©mentÃ©s par les classes ArrayList et Vector;\rğŸ— Les ensembles, implÃ©mentÃ©s par les classes HashSet et TreeSet;\rğŸ— Les queues avec prioritÃ©, implÃ©mentÃ©es par la classe PriorityQueue (introduite par le JDK 5.0) ;\rğŸ— Les queues Ã  double entrÃ©e, implÃ©mentÃ©es par la classe ArrayDeque (introduite par Java6).",
    "description": "Objectifs gÃ©nÃ©raux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de donnÃ©es.\nÃ‰valuer et comparer la complexitÃ© algorithmique des opÃ©rations (temps et mÃ©moire).\nUtiliser des fils dâ€™exÃ©cution (threads) pour exÃ©cuter plusieurs tÃ¢ches en parallÃ¨le.\nDÃ©velopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi Ã©tudier les structures de donnÃ©es ? Parce quâ€™elles sont au cÅ“ur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de donnÃ©es.",
    "tags": [],
    "title": "Structures de donnÃ©e",
    "uri": "/420-311/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-311/tags/index.html"
  }
]
