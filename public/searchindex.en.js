var relearn_searchindex = [
  {
    "breadcrumb": "Structures de donnée",
    "content": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "tags": [],
    "title": "Préalables",
    "uri": "/420-311/intro/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "Notion de structure de données Ⓜ️ Le principe de base d’une structure de données, c’est de stocker des éléments auxquels le programmeur veut pouvoir accéder plus tard. On appelle les différentes utilisations possibles de la structure de données des opérations.\nLes structures de données en Java Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util). On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nStructure générale des collections en Java Une collection représente un groupe d’objets, connu par ses éléments. Certaines collections acceptent les doublons, d’autres pas. Certaines sont ordonnées, d’autres pas.\nInterface Collection Depuis la version 1.6 de Java, il y a un changement dans la structure des collections. Il y a eu l’ajout du package java.util.concurrent\nVous pourrez généralement vous contenter de connaître les fonctionnalités supplémentaires qu’offre chacune des classes LinkedList, ArrayList, Vector, HashSet, TreeSet, PriorityQueue et ArrayDeque. Mais, dans certains cas, vous devrez avoir quelques notions sur l’architecture d’interfaces employée par les concepteurs de la librairie. Elle se présente comme suit :\nCollection\nList implémentée par LinkedList, ArrayList et Vector Set implémentée par HashSet SortedSet implémentée par TreeSet NavigableSet implémentée par TreeSet (Java 6) Queue (JDK 5.0) implémentée par LinkedList, PriorityQueue Deque (Java 6) implémentée par ArrayDeque, LinkedList L’interface Iterable public interface \u003cE\u003e Collection extends Iterable \u003cE\u003e\rCollection est l’interface racine dans la hiérarchie des collections. Une collection représente un groupe d’objets, connu sous le nom de ses éléments. Certaines collections :\nPermettent de dupliquer les éléments et d’autres pas. Elles sont ordonnées et d’autres pas. Le JDK ne fournit pas directement les implémentations de cette interface : il fournit des implémentations de sous-interfaces plus spécifiques telles que Set et List.\nL’interface List public interface List\u003cE\u003e extends Collection\u003cE\u003e\rUne liste est une collection ordonnée (également connu sous le nom de séquence).\nL’utilisateur de cette interface à un contrôle précis sur l’endroit où est inséré chaque élément dans la liste. L’utilisateur peut accéder aux éléments par leur index (position dans la liste), et rechercher des éléments dans la liste. Les listes permettent généralement les éléments dupliqués. Les listes permettent de multiples éléments nuls. Il n’est pas inconcevable que quelqu’un puisse vouloir mettre en place une liste qui interdit les doublons, par exemple : en lançant des exceptions d’exécution lorsque l’utilisateur tente de les insérer, cet usage est rare.\nLes listes chaînées - classe LinkedList La classe LinkedList permet de manipuler des listes dites “doublement chaînées”. À chaque élément de la collection, on associe (de façon totalement transparente pour le programmeur) deux informations supplémentaires qui ne sont autres que les références à l’élément précédent et au suivant. Une telle collection peut ainsi être parcourue à l’aide d’un itérateur bidirectionnel de type ListIterator.\nLe grand avantage d’une telle structure est de permettre des ajouts ou des suppressions à une position donnée avec une efficacité en O (1) (ceci grâce à un simple jeu de modification de références).\nEn revanche, l’accès à un élément en fonction de sa valeur ou de sa position dans la liste sera peu efficace puisqu’il nécessitera obligatoirement de parcourir une partie de la liste. L’efficacité sera donc en moyenne en O (N).",
    "description": "Notion de structure de données Ⓜ️ Le principe de base d’une structure de données, c’est de stocker des éléments auxquels le programmeur veut pouvoir accéder plus tard. On appelle les différentes utilisations possibles de la structure de données des opérations.\nLes structures de données en Java Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util). On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.",
    "tags": [],
    "title": "Les structures de données (Java)",
    "uri": "/420-311/sdd/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "Dans ce chapitre nous allons découvrir quelques structures de données et apprendre à choisir la bonne structure selon le problème.\nⓂ️ Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util).\nⓂ️ On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nⓂ️ Nous commencerons par examiner les concepts communs qu’elles (structures de données) exploitent ainsi : généricité, itérateur, ordonnancement et relation d’ordre.\nⓂ️ Nous verrons également quelles sont les opérations qui leur sont communes : ajout ou suppression d’éléments, construction à partir des éléments d’une autre collection…\nⓂ️ Nous étudierons ensuite en détail chacune de ces structures, à savoir :\n🌱 Les listes, implémentées par la classe LinkedList;\r🌱 Les vecteurs dynamiques, implémentés par les classes ArrayList et Vector;\r🌱 Les ensembles, implémentés par les classes HashSet et TreeSet;\r🌱 Les queues avec priorité, implémentées par la classe PriorityQueue (introduite par le JDK 5.0) ;\r🌱 Les queues à double entrée, implémentées par la classe ArrayDeque (introduite par Java6).",
    "description": "Dans ce chapitre nous allons découvrir quelques structures de données et apprendre à choisir la bonne structure selon le problème.\nⓂ️ Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util).\nⓂ️ On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nⓂ️ Nous commencerons par examiner les concepts communs qu’elles (structures de données) exploitent ainsi : généricité, itérateur, ordonnancement et relation d’ordre.",
    "tags": [],
    "title": "Structure de données",
    "uri": "/420-311/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "Dans ce chapitre, nous allons voir ce que signifie la notation Big-O et analyser la complexité d’un algorithme simple, ainsi que comparer plusieurs approches pour résoudre un même problème. En fin, nous allons voir comment mesurer expérimentalement la performance d’un programme en Java.",
    "description": "Dans ce chapitre, nous allons voir ce que signifie la notation Big-O et analyser la complexité d’un algorithme simple, ainsi que comparer plusieurs approches pour résoudre un même problème. En fin, nous allons voir comment mesurer expérimentalement la performance d’un programme en Java.",
    "tags": [],
    "title": "Complexité algorithmique",
    "uri": "/420-311/complexalgo/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Rappel : Concepts de base Classe : Modèle définissant les attributs (variables) et comportements (méthodes).\nObjet : Instance concrète d’une classe.\nEncapsulation : Protéger les données via des modificateurs d’accès (private, public, protected) et exposer des méthodes d’accès (getters/setters).\nAbstraction : Masquer les détails d’implémentation et ne montrer que les fonctionnalités essentielles (via classes abstraites et interfaces).\nHéritage : Une classe peut hériter des attributs et méthodes d’une autre (mot-clé extends).\nPolymorphisme :\nSurcharge (overloading) : même nom de méthode, signatures différentes. Redéfinition (overriding) : une sous-classe redéfinit le comportement d’une méthode héritée. Constructeur : Méthode spéciale exécutée lors de la création d’un objet (new).\nModificateurs d’accès Modificateur Même classe Même package Sous-classe Partout public ✅ ✅ ✅ ✅ protected ✅ ✅ ✅ ❌ (default) ✅ ✅ ❌ ❌ private ✅ ❌ ❌ ❌ Syntaxe essentielle Définir une classe public class Voiture { private String marque; private int annee; public Voiture(String marque, int annee) { this.marque = marque; this.annee = annee; } public void demarrer() { System.out.println(marque + \" démarre !\"); } }\rCréer un objet Voiture v1 = new Voiture(\"Toyota\", 2022); v1.demarrer();\rHéritage et polymorphisme class Animal { public void parler() { System.out.println(\"??\"); } } class Chien extends Animal { @Override public void parler() { System.out.println(\"Woof\"); } } Animal a = new Chien(); // polymorphisme a.parler(); // \"Woof\"\rAbstraction et interfaces abstract class Forme { abstract double aire(); } class Cercle extends Forme { private double r; Cercle(double r) { this.r = r; } @Override double aire() { return Math.PI * r * r; } } interface Volant { void voler(); } class Avion implements Volant { public void voler() { System.out.println(\"En vol ✈️\"); } }\rClasses utiles Object : classe racine de toutes les classes Java. Méthodes importantes : toString(), equals(), hashCode(), clone().\nfinal :\nfinal class : non-héritée. final method : non-redéfinissable. final variable : constante. Gestion mémoire Les objets sont créés sur le tas (heap) via new. Le garbage collector libère automatiquement la mémoire des objets non référencés. Bonnes pratiques Utiliser private pour protéger les données. Toujours redéfinir toString() pour représenter un objet. Respecter la cohérence equals() / hashCode(). Favoriser la composition plutôt que l’héritage trop profond. Documenter avec JavaDoc (/** … */). Exemple : package s01; class Etudiant { private String nom; private int age; public Etudiant(String nom, int age) { this.nom = nom; this.age = age; } public void afficherInfos() { System.out.println(\"Nom : \" + nom + \", Âge : \" + age); } } class EtudiantRegulier extends Etudiant { private String programme; public EtudiantRegulier(String nom, int age, String programme) { super(nom, age); this.programme = programme; } @Override public void afficherInfos() { super.afficherInfos(); System.out.println(\"Programme : \" + programme); } } public class RappelPOO { public static void main(String[] args) { EtudiantRegulier e = new EtudiantRegulier(\"Alice\", 20, \"Informatique\"); e.afficherInfos(); } }\r📘 Résumé de révision – POO 🔹 1. Classes Une classe public est accessible depuis n’importe quel package. Une classe abstract sert de modèle, ne peut pas être instanciée et peut contenir des méthodes abstraites. Une classe final ne peut pas être héritée. Une classe private n’est possible qu’en classe interne (nested class). Toute classe hérite implicitement de Object → possède donc les méthodes toString(), equals(), hashCode(), etc. 🔹 2. Constructeurs Si aucune déclaration → le compilateur génère un constructeur par défaut (sans paramètres). Un constructeur peut être private (utilisé dans le pattern Singleton ou classes utilitaires). 🔹 3. Méthodes Les méthodes peuvent être surchargées (overloading) → même nom, paramètres différents. Les méthodes peuvent être surdéfinies (overriding) → même signature, dans une sous-classe. Une méthode final ne peut pas être redéfinie dans une sous-classe. Une méthode abstract est déclarée sans corps et doit être implémentée dans une sous-classe. abstract et final sont incompatibles (contradiction). 🔹 4. Attributs Un attribut final est une constante : doit être initialisé une seule fois (déclaration ou constructeur). 🔹 5. Interfaces Une interface ne peut pas être instanciée.\nUne interface n’est pas un objet, c’est un contrat.\nUne interface n’hérite pas d’Object, mais les classes qui l’implémentent héritent d’Object.\nUne interface peut hériter d’une ou plusieurs autres interfaces avec extends.\nUne interface ne peut pas hériter d’une classe.\nMéthodes dans une interface :\nAvant Java 8 → uniquement public abstract. Depuis Java 8 → méthodes default et static avec implémentation. Depuis Java 9 → méthodes private pour factoriser du code interne. 🔹 6. Comparable vs Comparator Comparable : définit l’ordre naturel d’une classe (méthode compareTo). Comparator : définit un ordre externe, peut être multiple et personnalisé (méthode compare). 🔹 7. Mots-clés spéciaux null → valeur littérale spéciale, pas un mot-clé. this → référence à l’instance courante. super → référence à la classe parente. Résumé Élément Description Exemple Classe abstract Non instanciable, modèle pour héritage abstract class Forme { abstract double aire(); } Classe final Ne peut pas être héritée final class Utilitaire {} Méthode final Ne peut pas être redéfinie public final void calcul() {} Méthode abstract Sans corps, à implémenter abstract void afficher(); Attribut final Constante, valeur fixée une seule fois final double PI = 3.14; Interface Contrat, non instanciable interface Vehicule { void rouler(); } Comparable Ordre naturel, compareTo class Etudiant implements Comparable\u003cEtudiant\u003e Comparator Ordre externe, compare Comparator\u003cEtudiant\u003e parNom = ...;",
    "description": "Rappel : Concepts de base Classe : Modèle définissant les attributs (variables) et comportements (méthodes).\nObjet : Instance concrète d’une classe.\nEncapsulation : Protéger les données via des modificateurs d’accès (private, public, protected) et exposer des méthodes d’accès (getters/setters).\nAbstraction : Masquer les détails d’implémentation et ne montrer que les fonctionnalités essentielles (via classes abstraites et interfaces).\nHéritage : Une classe peut hériter des attributs et méthodes d’une autre (mot-clé extends).",
    "tags": [],
    "title": "Révision",
    "uri": "/420-311/intro/revisionpoo/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Questions théoriques Question 1 : Quel est le résultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le résultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le résultat du code suivant:\npublic class Question3 { public static void main(String[]args) { int val1 = 9; int val2 = 9; String str = \"9\"; System.out.println(val1 + val2 + str);\t} }\rQuestion 4 : Quel est le résultat du code suivant:\npublic class Question4 { public static void main(String[]args) { try { int a, b; b = 0; a = 5 / b; System.out.print(\"A\"); } catch (Exception e) { System.out.print(\"B\"); } finally { System.out.print(\"C\"); }\t} }\rQuestion 5 : Quel est le résultat du code suivant:\npublic class Question5 { public static void main(String[]args) { String obj = \"Bonjour\"; String obj1 = \"Bonsoir\"; String obj2 = \"Bonjour\"; System.out.println(obj.equals(obj1) + \" \" + obj.equals(obj2)); } }\rQuestion 6 : Quel est le résultat du code suivant:\npublic class ClasseA { public int i; public int j; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.j = 3; System.out.println(i + \" \" + j); } } public class Question6 { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 7 : Quel est le résultat du code suivant:\npublic class ClasseA { public int i; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.i = j + 1; System.out.println ( j + \" \" + i); } } public class Main { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 8 : Quel est le résultat du code suivant:\npublic class Question8{ public static void main(String[] args) { String s = \"Hello World\"; int A = s.indexOf('o'); int B = s.lastIndexOf('l'); System.out.println(A + \" \" + B); } }\rQuestion 9 : Quel est le résultat du code suivant:\npublic class Question9{ public static void main(String[] args) { char ch; ch = \"hello\".charAt(1); System.out.println(ch); } }\rQuestion 10 : Quel est le résultat du code suivant:\npublic class Question10{ public static void main(String[] args) { String chars[] = {\"a\", \"b\", \"c\", \"a\", \"c\"}; for (int i = 0; i \u003c chars.length; ++i) for (int j = i + 1; j \u003c chars.length; ++j) if(chars[i].compareTo(chars[j]) == 0) System.out.print(chars[j]); } }\rQuestion 11 : Quel est le résultat du code suivant:\npublic class Question11{ public static void main(String[] args) { int a1[] = new int[10]; int a2[] = { 1, 2, 3, 4, 5 }; System.out.println(a1.length + \" \" + a2.length); } }\rQuestion 12 : Quel est le résultat du code suivant:\npublic class Question12{ public static void main(String[] args) { int arr[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i \u003c arr.length - 2; ++i) System.out.print(arr[i] + \" \"); } }\rQuestion 13 : Quel est le résultat du code suivant:\npublic class Question13{ public static int param1; public static int param2; public void add(int a, int b) { param1 = a + b; param2 = param1 + b; } public static void main(String args[]) { Question13 obj1 = new Question13(); Question13 obj2 = new Question13(); int a = 2; obj1.add(a, a + 1); obj2.add(5, a); System.out.println(obj1.param1 + \" \" + obj2.param2); } }\rQuestion 14 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question14{ public static void main(String[] args) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 15 : Quel est le résultat du code suivant:\npublic class Question15{ public static int param1; public void increment() { param1++; } public static void main(String args[]) { Question15 obj1 = new Question15(); Question15 obj2 = new Question15(); obj1.param1 = 0; obj1.increment(); obj2.increment(); System.out.println(obj1.param1 + \" \" + obj2.param1); } }\rQuestion 16 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question16 { public static void main(String args[]) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 17 : Quel est le résultat du code suivant:\npublic class Question17 { public static void main(String[] args) { ClasseB classeB = new ClasseB(); System.out.println(\"Valeur = \" + classeB.calculer(3, 6)); } } class ClassA { final public int calculer(int a, int b) { return 0; } } class ClasseB extends ClasseA { public int calculer(int a, int b) { return 1; } }\rQuestion 18 : Quel est le résultat du code suivant:\npublic class Question18 { public static void main (String args[]) { int param1, param2= 1; param1= 10; if (param1!= 10 \u0026\u0026 param1/ 0 == 0) { System.out.println(param2); } else { System.out.println(++param2); } } }\rQuestion 19 : Quel est le résultat du code suivant:\npublic class Question19 { public static int param1; public static int param2; public void add(int val1, int val2) { param1 = val1 + val2; param2 = param1 + val2; } public static void main(String[] args) { Question19 instance1 = new Question19 (); Question19 instance2 = new Question19 (); Question19 instance3 = new Question19 (); int abc = 2;\tinstance1.add(abc, abc-1); instance3.add(6, 6/abc); instance2.add(5, abc/2); System.out.println(instance1.param1); System.out.println(instance2.param2); } }\rQuestion 20 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question20 { public static void main(String args[]) { int array[] = new int [5]; for (int i = 5; i \u003e 0; i--) { array[5 - i] = i; } Arrays.sort(array); System.out.print(Arrays.toString(array)); } }\rQuestion 21 : Quel est le résultat du code suivant:\npublic class Question21 { public static void main(String [] args) { Question21 instance = new Question21(); instance.myMethod(); } public void myMethod(){ long [] tab1 = {6,8,9}; long []tab2 = affectation(tab1); System.out.print(tab1[0] + tab1[1] + tab1[2] + \" \"); System.out.println(tab2[0] + tab2[1] + tab2[2]); } public long[] affectation(long[] tab3){ tab3[1] = 7; return tab3; } }\rExercices pratiques Exercice 1 : Soit la String suivante: A-b-C-d-E-f-1234-***///-\u003e , écrire un programme en Java qui:\n👍 convertit chaque caractère alphabétique majuscule de la String en un caractère minuscule; 👍 Convertis chaque caractère alphabétique minuscule de la String en un caractère majuscule; 👍 Supprime tous les caractères spéciaux de la String; Exercice 2 : Soit le tableau suivant: String [] days = { \"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\", \"Dimanche\"}; Écrire un programme en Java qui:\n👍 choisi aléatoirement une journée du tableau et l’affiche; 👍 Tri le tableau; Exercice 3 : Soit le code Java suivant:\nString str1 = \"Bonjour\"; String str2 = new String (\"Bonjour\"); str1 == str2; //3 str1.equals(str2); //4\rExpliquez la différence entre les 02 lignes de code (ligne 3 et ligne 4)?\nExercice 4 : Soit la classe Compte bancaire avec les attributs suivants:\nidCpte (numéro unique: donc 2 comptes ne peuvent pas avoir le même ID); firstName; lastName; solde; En utilisant les collections Java (List, Set et Map) et en vous utilisant l’API Java, vous devez coder les méthodes suivantes:\n👍 addCompteToCollection (List | Set | Map)\r👍 serachCompteInCollection (List | Set | Map)\r👍 sortCollection (List | Set | Map)\r👍 removeCompteFromCollection (List | Set | Map)\r👍 emptyCollectionComptes (List | Set | Map)\rExercice 5 : Écrire un code Java qui convertit un tableau d’entiers (tableau à crochets) en une collection de type List.\nÉcrire un code Java qui convertit une collection de type List en un tableau à crochets.\nÉcrire un code Java qui convertit une collection de type List en une collection de Type Set.\nÉcrire un code Java qui convertit une collection de type Set en une collection de Type List.\nÉcrire un code Java qui convertit une collection de type List en une collection de Type Map.\nÉcrire un code Java qui convertit une collection de type Map en une collection de Type List.\nExercice 6 : Soit le tableau de conversion des devises suivant :\nDe Vers Taux Dollar canadien (CAD) Euro 1 CAD = 0.74 EURO Dollar canadien (CAD) Dollar américain (USD) 1 CAD = 0.69 USD Euro Dollar canadien (CAD) 1 EURO = 1.45 CAD Dollar américain (USD) Dollar canadien (CAD) 1 USD = 1.36 CAD Écrire un programme Java qui demande à un utilisateur de choisir un type conversion et saisir un montant à convertir. Le programme traitera la conversion et affichera le montant converti.\nCondition:\nLe programme n’acceptera que les montants entre 90 et 6500, cela dans chaque sorte de devises. Le programme ne doit pas s’arrêter tant que l’utilisateur n’aura pas choisi de quitter. Exercice 7 : Soit le système de notation universitaire :\nNote numérique Note littérale 90 et + A De 80 à 89 B De 70 à 79 C De 60 à 69 D De 50 à 59 E \u003c 50 F Écrire un programme Java qui demande à un utilisateur de saisir 4 notes numériques. Ensuite le programme calculera la moyenne et affichera la note littérale correspondante.\nCondition:\nLe programme n’acceptera que les notes entre 0 et 100.\nExemple\nLe programme demande les notes à l’utilisateur : Veuillez saisir vos notes Svp : L’utilisateur saisit les notes suivantes : 59, 72.5, 83.73, 45.5\nLe programme calculera la moyenne et affichera :\nVotre moyenne numérique est : 65,18 ce qui donnera en littérale la note de D.\nExercice 8 : Soit la liste des villes suivantes : Ottawa, Paris, Berne, Washington, Berlin, Madrid, Mexico.\n🌼 Écrire un programme Java qui génère aléatoirement 2 villes parmi la liste des villes et demandera à un utilisateur de deviner les 2 villes au bout de 3 tentatives.\nSi l’utilisateur arrive à deviner les 2 villes aléatoires, le programme affichera un message et quittera. Si l’utilisateur n’arrive pas à deviner les 2 villes aléatoires au bout de 3 tentatives, le programme affichera le résultat et quittera. Clarification\nModèle de message en cas de succès de devinette Bravo! Vous avez deviné les 2 villes : Ottawa et Paris. Modèle de message en cas d’échec de devinette Oups! En 3 tentatives, vous n’êtes pas arrivé à deviner les 2 villes : Ottawa et Paris. Exercice 9 : On souhaite gérer une liste de prénoms d’étudiants dans un cours. Réalise un programme Java qui :\nCrée une liste de type ArrayList. Ajoute les prénoms suivants : “Alice”, “Bob”, “Charlie”, “Diane”. Affiche la taille de la liste et son contenu. Demande à l’utilisateur d’entrer un prénom, puis : Vérifie s’il est présent dans la liste (affiche un message approprié). Si présent, affiche sa position dans la liste. Supprime un prénom donné par l’utilisateur et réaffiche la liste. Trie la liste par ordre alphabétique et affiche le résultat. Exercice 10 : Soit le diagramme de classes suivant :\nCréer les classes Java correspondant aux classes du diagramme. Il vous faudra respecter les attributs et les relations entre les différentes classes. Écrire une méthode de service qui permet de calculer le prix réel d’un produit suivant la règle suivante : a.\tSi le produit est biologique, « indiceBio » et le produit appartiennent à un fournisseur habitant la province du « Québec », alors le prix réel est :\ni.\tPrix réel = prix du produit + prix du produit*tps + prix du produit * tvq. b.\tSi le produit est biologique, « indiceBio » et le produit appartiennent à un fournisseur habitant le Canada (sauf la province du Québec) alors le prix réel est :\ni.\tPrix réel = prix du produit + prix du produit*tps. c.\tSi le produit est biologique « indiceBio » et le produit appartient à un fournisseur habitant les USA alors le prix réel est :\ni.\tPrix réel = prix du produit + prix du produit*usTax. Écrire une méthode de service qui permet de calculer le total prix (la somme totale) des produits de tous les fournisseurs américains.",
    "description": "Questions théoriques Question 1 : Quel est le résultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le résultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le résultat du code suivant:",
    "tags": [],
    "title": "Questions et exercices",
    "uri": "/420-311/intro/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code d’événement dans le bandeau supérieur Quiz 2 : méthodes et interfaces Quiz Wooclap sur les méthodes et les interfaces",
    "description": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code d’événement dans le bandeau supérieur Quiz 2 : méthodes et interfaces Quiz Wooclap sur les méthodes et les interfaces",
    "tags": [],
    "title": "Quiz",
    "uri": "/420-311/intro/quiz/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Complexité algorithmique",
    "content": "Qu’est-ce que la complexité algorithmique ? La complexité algorithmique désigne en informatique la quantité de ressources qu’un algorithme consomme lors de son exécution (On utilise Grand O pour décrire la performance d’une algorithme). Elle se décline en deux dimensions principales :\nLa complexité temporelle, qui mesure le temps d’exécution. La complexité spatiale, qui évalue la mémoire supplémentaire requise en dehors des données d’entrée. Ces deux aspects sont indépendants : un algorithme peut être très rapide mais consommer beaucoup de mémoire, ou inversement.\nPour bien évaluer un algorithme, il faut examiner son comportement dans différents contextes :\nle meilleur cas, le pire cas (souvent privilégié pour anticiper les situations extrêmes), et le cas moyen, qui reflète son usage habituel. Comparer la complexité de plusieurs algorithmes résolvant le même problème permet ainsi de choisir la solution la plus adaptée en fonction des contraintes de performance.\nComment et pourquoi mesurer la complexité ? Pour mesurer la complexité d’un algorithme, on utilise la notation Big O, écrite sous la forme O(f(n)). Elle exprime la croissance du temps ou de la mémoire nécessaires en fonction de la taille de l’entrée, généralement notée n.\nLe but de cette notation est de mettre en évidence le comportement asymptotique : comment l’algorithme évolue lorsque n devient très grand. On ignore donc les détails secondaires (constantes et termes mineurs) pour ne retenir que le terme dominant. Par exemple, une complexité exacte de 3n² + 5n + 7 se résume en O(n²), puisque n² domine pour de grandes valeurs de n.\nUn programme qui fonctionne n’est pas forcément efficace.\nExemple concret :\nRechercher un mot dans un dictionnaire papier (O(log n)). Rechercher une photo dans une pile désordonnée (O(n)). Plus les données sont grosses, plus le choix de l’algorithme est critique.\nNotation Big-O (pire cas) La notation Big-O décrit comment le temps d’exécution évolue en fonction de la taille de l’entrée (n).\nComplexité Exemple Interprétation O(1) Accès à un tableau par index Constant O(log n) Recherche binaire Logarithmique : croissance lente O(n) Parcours d’une liste Linéaire O(n log n) Tri rapide/merge sort Plus rapide que O(n²) O(n²) Doubles boucles imbriquées Quadratique : explose vite O(2^n) Problèmes combinatoires Exponentielle : impraticable 💡 Règle d’or :\nPour n petit, toutes les méthodes semblent rapides. Pour n grand, seules les bonnes structures/algorithmes tiennent la route. Exemples en Java 🔹 O(1) – Affichage simple public static void affiche(int[] tab) { // O(1) System.out.println(tab[0]); }\rAussi :\npublic static void affiche(int[] tab) { // O(2) qui sera simplifée à O(1) System.out.println(tab[0]); System.out.println(tab[1]); }\r🔹 O(n) – Boucle (itération sur tous les élements) public static void afficheTableau(int[] tab) { // O(n) for (int num : tab) { System.out.println(num); } }\rMême chose pour les boucles for, while et do while\n🔹 O(n ^ 2) – Boucle inbriquée public static void afficheTableau2D(int[] tab) { // O(n ^ 2) for (int num1 : tab) { for (int num2 : tab) { System.out.println(num1 * num2); } } }\r🔹 O(log n) – Recherche binaire ⚠️ Nécessite un tableau trié.\npublic static boolean rechercheBinaire(int[] tab, int val) { int g = 0, d = tab.length - 1; while (g \u003c= d) { int m = (g + d) / 2; if (tab[m] == val) return true; if (tab[m] \u003c val) g = m + 1; else d = m - 1; } return false; }\rSi nous cherchant dans un tableau d’un million d’éléments, 19 comparaisons seront suffusantes pour trouver l’élément recherché.\n🔹 Comparaison avec des exemples import java.util.*; public class Bench { public static void main(String[] args) { int n = 1_000_000; int[] tab = new int[n]; for (int i = 0; i \u003c n; i++) tab[i] = i; int cible = n - 1; // Recherche linéaire long t1 = System.nanoTime(); rechercheLineaire(tab, cible); long t2 = System.nanoTime(); System.out.println(\"Lineaire : \" + (t2 - t1) / 1_000_000.0 + \" ms\"); // Recherche binaire long t3 = System.nanoTime(); rechercheBinaire(tab, cible); long t4 = System.nanoTime(); System.out.println(\"Binaire : \" + (t4 - t3) / 1_000_000.0 + \" ms\"); } public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) if (x == val) return true; return false; } public static boolean rechercheBinaire(int[] tab, int val) { int g = 0, d = tab.length - 1; while (g \u003c= d) { int m = (g + d) / 2; if (tab[m] == val) return true; if (tab[m] \u003c val) g = m + 1; else d = m - 1; } return false; } }\rOn peut dire que :\nUn algorithme linéaire, qui met une seconde à traiter un tableau à 100 éléments, mettra 100 secondes à traiter un tableau à 10 000 éléments. Un algorithme quadratique qui met également une seconde à traiter le cas d’un tableau à 100 éléments mettra 10 000 secondes (soit près de trois heures) à traiter le cas du tableau à 10 000 éléments. Un algorithme en O(2n) qui mettrait aussi une seconde avec 100 éléments qui mettrait 2100 secondes à traiter ne serait-ce que 200 éléments, soit environ 4.1022 années (4000 milliards de milliards d’années). Analyse de boucles Boucle simple for (int i=0; i\u003cn; i++) → O(n). Boucles imbriquées for i, for j → O(n²). Boucle divisant par 2 while (n \u003e 1) n/=2 → O(log n). Complexité spatiale (mémoire) La complexité spatiale (ou complexité mémoire) mesure la quantité de mémoire nécessaire pour exécuter un algorithme en fonction de la taille de l’entrée (n).\n💡 On ne parle pas seulement de la mémoire des données initiales, mais aussi :\nde la mémoire supplémentaire utilisée par l’algorithme (variables, structures temporaires, pile d’appels).\nO(1) : pile, file, liste chaînée → mémoire proportionnelle aux données. O(n) : tableau de n éléments. O(n²) : matrice d’adjacence pour un graphe. Exemple 1 : Complexité spatiale O(1)\npublic static void afficheTableau(int[] tab) { // O(1) space for (int num : tab) { System.out.println(num); } }\rExemple 2 : Complexité spatiale O(n)\npublic static void afficheTableau(int[] tab) { // O(n) space (c'est l'espace qu'on a alloué à l'iterieur de cette méthode) int[] tabCopy = new int[tab.length]; for (int num : tab) { System.out.println(num); } }\rExemple 3 : Complexité spatiale O(n) (récursion)\npublic static int factoriel(int n) { // O(n) space if (n == 0) return 1; return n * factoriel(n - 1); }\rExercices Quelle est la complexité de :\nfor (int i=0; i\u003cn; i++) for (int j=0; j\u003cn; j++) System.out.println(i + \",\" + j);\rQuelle est la complexité de :\nfor (int i=0; i\u003cn; i*=2) System.out.println(i);\rQuelle est la complexité spatiale d’un tableau int[1000][1000] ?\nFiche synthèse Complexité temporelle → combien de temps ça prend.\nComplexité spatiale → combien de mémoire ça utilise.\nParfois, il faut choisir :\nMoins de temps mais plus de mémoire (ex. table de hachage).\nMoins de mémoire mais plus de temps (ex. recherche linéaire dans une liste).\nOn utilise la notion grand O (Big O) pour mesurer la complexité :\nO(1) : accès direct. O(log n) : recherche dichotomique, arbres équilibrés. O(n) : parcours d’une collection. O(n log n) : tris efficaces. O(n²) : algorithmes naïfs à doubles boucles. O(2^n) : problèmes combinatoires → à éviter.",
    "description": "Qu’est-ce que la complexité algorithmique ? La complexité algorithmique désigne en informatique la quantité de ressources qu’un algorithme consomme lors de son exécution (On utilise Grand O pour décrire la performance d’une algorithme). Elle se décline en deux dimensions principales :\nLa complexité temporelle, qui mesure le temps d’exécution. La complexité spatiale, qui évalue la mémoire supplémentaire requise en dehors des données d’entrée. Ces deux aspects sont indépendants : un algorithme peut être très rapide mais consommer beaucoup de mémoire, ou inversement.",
    "tags": [],
    "title": "Complexité algorithmique",
    "uri": "/420-311/complexalgo/complexalgo/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Ressources utiles",
    "content": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsqu’un contributeur a réalisé une modification qui est prête à l’envoyer, il pousse (push) celle-ci vers le dépôt. Le dépôt garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version décentralisé. Il y a 2 dépôts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez récupérer le code de votre repository (dépôt remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configuré la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de déposer les modifications sur une dépôt local. Il faut également être vigilant au niveau de la branche utilisé pour le commit. De plus, il est important de mettre souvent à jour la branche avant de procéder à un commit.\nLorsqu’on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour référer à la tâche en cours. Après cet identifiant, on peut y mettre une description. Par exemple:\n“PRJ-3428: Ajout de tests unitaires sur la méthode du service getClients”\nLorsqu’on relie l’identifiant et les commits, on peut alors connaître le travail effectué dans le code pour une tâche donnée dans le système de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandé de faire un git fetch / pull avant de procéder à celui-ci. À moins d’être seul dans ce repository et/ou la branche visée.\nGit Fetch, checkout, pull La commande git fetch permet de mettre à jour notre dépôt local en récupérant l’ état courant qui remote. La commande git checkout permet de les appliquer à la copie de travail (et donc de les voir).\nLa commande git pull fait les deux à la fois.\nPensez à vous mettre à jour avant chaque session de travail !\nC’est la première chose qu’un développeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaître l’état courant de vos copies locales (les modifications ont-elles été commitées, les fichiers ajoutés, les commit pushé).\nLes interface graphiques (dont intelliJ) vous l’indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectué. Ces commit peuvent être fort utili pour faire d’autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet d’appliquer les changements (fusionner) d’une autre branche à votre branche sélectionnée dans votre repository locale. Il y a souvent des conflits lors d’une fusion. Surtout si vous avez travailler dans un même fichier qu’un ou une de vos collègues.\nVous devez tenter de résoudre les conflits avec des outils en ligne de commande ou à l’aide d’un interface graphique. C’est une habilité à acquérir avec le temps. C’est parfois très complexe et si l’opération n’est pas effectée avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste à changer la base de votre branche d’un commit vers un autre, donnant l’illusion que vous avez créé votre branche à partir d’un commit différent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder l’état actuel de votre répertoire de travail. C’est possible de le faire avec git stash et de revenir à un répertoire de travail propre sans ces modifications. Vous pourrez ensuite récupérer ce travail en utilisant le nom que vous lui aurez donné. Vous pouvez en avoir plusieurs sauvegardés dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// Récupérer les changements précédents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalité si vous avez terminé.\nNe pas prendre les branches pour plusieurs fonctionnalités. Séparez vos tâches en plus petites et faites des commits plus souvent.\nRécupérer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre équipe vos intentions! Ne travaillez pas sur les mêmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillé sur une fonctionnalité ou un fix.\nAvant le jour de la mise en production. Vous devriez créer une branche à partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visée vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les éléments. Testez que votre branche fonctionne et qu’elle est bien compilée. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront déjà été résolus! Bingo.\nGitflow Pour maintenir une certain cohésion en entreprise, un modèle de branche a été proposé. Il implique de séparer les branches de développement et les branches primaires qui sont déployés dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRéférence Richard E. Silverman (2013), Git Pocket Guide, O’Reilly\nAlice Jacquot, Introduction à Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-311/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Complexité algorithmique",
    "content": "Exercices – Complexité temporelle 🔹 Exercice 1 : for (int i = 0; i \u003c n; i++) { System.out.println(i); }\r👉 Quelle est la complexité temporelle en fonction de n ?\n🔹 Exercice 2 while (n \u003e 1) { n = n / 2; }\r👉 Quelle est la complexité temporelle ?\n🔹 Exercice 3 public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) { if (x == val) return true; } return false; }\r👉 Quelle est la complexité temporelle dans le pire cas ?\n🔹Exercice 4 public static void insertionSort(int[] tab) { for (int i = 1; i \u003c tab.length; i++) { int cle = tab[i]; int j = i - 1; while (j \u003e= 0 \u0026\u0026 tab[j] \u003e cle) { tab[j+1] = tab[j]; j--; } tab[j+1] = cle; } }\r👉 Quelle est la complexité dans le meilleur cas et dans le pire cas ?\n🔹Exercice 5 Classez les algorithmes suivants du plus rapide au plus lent quand n devient très grand :\nO(n) O(n log n) O(n²) 🔹Exercice 6 Vous avez ce code :\nfor (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j *= 2) { System.out.println(i + \",\" + j); } }\r👉 Quelle est la complexité de cet algorithme ? Expliquez.\n🔹Exercice 7 public static int somme(int[] tab) { int total = 0; for (int n : tab) { total += n; } return total; }\r👉 Question : Quelle est la complexité spatiale de cette méthode ? Justifiez votre réponse.\n🔹Exercice 8 public static int[] doubleTableau(int[] tab) { int[] resultat = new int[tab.length]; for (int i = 0; i \u003c tab.length; i++) { resultat[i] = tab[i] * 2; } return resultat; }\r👉 Question : Combien de mémoire supplémentaire est utilisée par rapport à la taille de l’entrée n ?\n🔹Exercice 9 int[][] matrice = new int[n][n];\r👉 Question : Quelle est la complexité spatiale de cette structure ?\n🔹Exercice 10 On veut calculer la suite de Fibonacci :\nVersion récursive simple :\npublic static int fib(int n) { if (n \u003c= 1) return n; return fib(n - 1) + fib(n - 2); }\rVersion avec mémoïsation :\npublic static int fibMemo(int n, int[] memo) { if (memo[n] != 0) return memo[n]; if (n \u003c= 1) return n; memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo); return memo[n]; }\r👉 Questions :\nQuelle est la complexité spatiale des deux versions ? Pourquoi la version avec mémoïsation consomme plus de mémoire mais gagne en temps ? 🔹Exercice 11 : Écrivez un programme qui :\nCréez un tableau de 1 million d’entiers. Créez une LinkedList et un ArrayList chacun contenant 1 million d’entiers. Comparez la mémoire consommée (avec Runtime.getRuntime().totalMemory() - freeMemory()) pour chaque structure. Observer concrètement l’impact de la structure choisie sur la mémoire. Que remarquez vous ?",
    "description": "Exercices – Complexité temporelle 🔹 Exercice 1 : for (int i = 0; i \u003c n; i++) { System.out.println(i); }\r👉 Quelle est la complexité temporelle en fonction de n ?\n🔹 Exercice 2 while (n \u003e 1) { n = n / 2; }\r👉 Quelle est la complexité temporelle ?\n🔹 Exercice 3 public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) { if (x == val) return true; } return false; }\r👉 Quelle est la complexité temporelle dans le pire cas ?",
    "tags": [],
    "title": "📝 Exercices sur complexité algorithmique",
    "uri": "/420-311/complexalgo/exercices/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Objectifs généraux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de données.\nÉvaluer et comparer la complexité algorithmique des opérations (temps et mémoire).\nUtiliser des fils d’exécution (threads) pour exécuter plusieurs tâches en parallèle.\nDévelopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi étudier les structures de données ? Parce qu’elles sont au cœur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de données.\nParce qu’elles permettent de réduire le temps d’exécution et économiser de la mémoire.\nParce qu’elles développent la capacité à choisir la bonne approche selon un problème donné.\nParce qu’elles forment une base solide pour les cours ultérieurs et pour travailler dans des projets d’envergure.\nCitation classique : « Un bon algorithme mal implanté dans une mauvaise structure de données sera inefficace. Une bonne structure de données peut transformer un problème complexe en une solution élégante. »\n🌼 Notion de structure de données Le principe de base d’une structure de données, c’est de stocker des éléments auxquels le programmeur veut pouvoir accéder plus tard. On appelle les différentes utilisations possibles de la structure de données des opérations.\n🌼 Les structures de données en Java Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util).\nOn y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nNous commencerons par examiner les concepts communs qu’elles (structures de données) exploitent ainsi : généricité, itérateur, ordonnancement et relation d’ordre.\nNous verrons également quelles sont les opérations qui leur sont communes : ajout ou suppression d’éléments, construction à partir des éléments d’une autre collection…\nNous étudierons ensuite en détail chacune de ces structures, à savoir :\n🗝 Les listes, implémentées par la classe LinkedList;\r🗝 Les vecteurs dynamiques, implémentés par les classes ArrayList et Vector;\r🗝 Les ensembles, implémentés par les classes HashSet et TreeSet;\r🗝 Les queues avec priorité, implémentées par la classe PriorityQueue (introduite par le JDK 5.0) ;\r🗝 Les queues à double entrée, implémentées par la classe ArrayDeque (introduite par Java6).",
    "description": "Objectifs généraux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de données.\nÉvaluer et comparer la complexité algorithmique des opérations (temps et mémoire).\nUtiliser des fils d’exécution (threads) pour exécuter plusieurs tâches en parallèle.\nDévelopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi étudier les structures de données ? Parce qu’elles sont au cœur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de données.",
    "tags": [],
    "title": "Structures de donnée",
    "uri": "/420-311/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-311/categories/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-311/tags/index.html"
  }
]
