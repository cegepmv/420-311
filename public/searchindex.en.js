var relearn_searchindex = [
  {
    "breadcrumb": "Structures de donnée",
    "content": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte révision des notions essentielles au cours.",
    "tags": [],
    "title": "Préalables",
    "uri": "/420-311/intro/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "Dans ce chapitre nous allons découvrir quelques structures de données et apprendre à choisir la bonne structure selon le problème.\nⓂ️ Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util).\nⓂ️ On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nⓂ️ Nous commencerons par examiner les concepts communs qu’elles (structures de données) exploitent ainsi : généricité, itérateur, ordonnancement et relation d’ordre.\nⓂ️ Nous verrons également quelles sont les opérations qui leur sont communes : ajout ou suppression d’éléments, construction à partir des éléments d’une autre collection…\nⓂ️ Nous étudierons ensuite en détail chacune de ces structures, à savoir :\n🌱 Les listes, implémentées par la classe LinkedList;\r🌱 Les vecteurs dynamiques, implémentés par les classes ArrayList et Vector;\r🌱 Les ensembles, implémentés par les classes HashSet et TreeSet;\r🌱 Les queues avec priorité, implémentées par la classe PriorityQueue (introduite par le JDK 5.0) ;\r🌱 Les queues à double entrée, implémentées par la classe ArrayDeque (introduite par Java6).",
    "description": "Dans ce chapitre nous allons découvrir quelques structures de données et apprendre à choisir la bonne structure selon le problème.\nⓂ️ Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util).\nⓂ️ On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nⓂ️ Nous commencerons par examiner les concepts communs qu’elles (structures de données) exploitent ainsi : généricité, itérateur, ordonnancement et relation d’ordre.",
    "tags": [],
    "title": "Structure de données",
    "uri": "/420-311/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "Dans ce chapitre, nous allons voir ce que signifie la notation Big-O et analyser la complexité d’un algorithme simple, ainsi que comparer plusieurs approches pour résoudre un même problème. En fin, nous allons voir comment mesurer expérimentalement la performance d’un programme en Java.",
    "description": "Dans ce chapitre, nous allons voir ce que signifie la notation Big-O et analyser la complexité d’un algorithme simple, ainsi que comparer plusieurs approches pour résoudre un même problème. En fin, nous allons voir comment mesurer expérimentalement la performance d’un programme en Java.",
    "tags": [],
    "title": "Complexité algorithmique",
    "uri": "/420-311/complexalgo/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Rappel : Concepts de base Classe : Modèle définissant les attributs (variables) et comportements (méthodes).\nObjet : Instance concrète d’une classe.\nEncapsulation : Protéger les données via des modificateurs d’accès (private, public, protected) et exposer des méthodes d’accès (getters/setters).\nAbstraction : Masquer les détails d’implémentation et ne montrer que les fonctionnalités essentielles (via classes abstraites et interfaces).\nHéritage : Une classe peut hériter des attributs et méthodes d’une autre (mot-clé extends).\nPolymorphisme :\nSurcharge (overloading) : même nom de méthode, signatures différentes. Redéfinition (overriding) : une sous-classe redéfinit le comportement d’une méthode héritée. Constructeur : Méthode spéciale exécutée lors de la création d’un objet (new).\nModificateurs d’accès Modificateur Même classe Même package Sous-classe Partout public ✅ ✅ ✅ ✅ protected ✅ ✅ ✅ ❌ (default) ✅ ✅ ❌ ❌ private ✅ ❌ ❌ ❌ Syntaxe essentielle Définir une classe public class Voiture { private String marque; private int annee; public Voiture(String marque, int annee) { this.marque = marque; this.annee = annee; } public void demarrer() { System.out.println(marque + \" démarre !\"); } }\rCréer un objet Voiture v1 = new Voiture(\"Toyota\", 2022); v1.demarrer();\rHéritage et polymorphisme class Animal { public void parler() { System.out.println(\"??\"); } } class Chien extends Animal { @Override public void parler() { System.out.println(\"Woof\"); } } Animal a = new Chien(); // polymorphisme a.parler(); // \"Woof\"\rAbstraction et interfaces abstract class Forme { abstract double aire(); } class Cercle extends Forme { private double r; Cercle(double r) { this.r = r; } @Override double aire() { return Math.PI * r * r; } } interface Volant { void voler(); } class Avion implements Volant { public void voler() { System.out.println(\"En vol ✈️\"); } }\rClasses utiles Object : classe racine de toutes les classes Java. Méthodes importantes : toString(), equals(), hashCode(), clone().\nfinal :\nfinal class : non-héritée. final method : non-redéfinissable. final variable : constante. Gestion mémoire Les objets sont créés sur le tas (heap) via new. Le garbage collector libère automatiquement la mémoire des objets non référencés. Bonnes pratiques Utiliser private pour protéger les données. Toujours redéfinir toString() pour représenter un objet. Respecter la cohérence equals() / hashCode(). Favoriser la composition plutôt que l’héritage trop profond. Documenter avec JavaDoc (/** … */). Exemple : package s01; class Etudiant { private String nom; private int age; public Etudiant(String nom, int age) { this.nom = nom; this.age = age; } public void afficherInfos() { System.out.println(\"Nom : \" + nom + \", Âge : \" + age); } } class EtudiantRegulier extends Etudiant { private String programme; public EtudiantRegulier(String nom, int age, String programme) { super(nom, age); this.programme = programme; } @Override public void afficherInfos() { super.afficherInfos(); System.out.println(\"Programme : \" + programme); } } public class RappelPOO { public static void main(String[] args) { EtudiantRegulier e = new EtudiantRegulier(\"Alice\", 20, \"Informatique\"); e.afficherInfos(); } }\r📘 Résumé de révision – POO 🔹 1. Classes Une classe public est accessible depuis n’importe quel package. Une classe abstract sert de modèle, ne peut pas être instanciée et peut contenir des méthodes abstraites. Une classe final ne peut pas être héritée. Une classe private n’est possible qu’en classe interne (nested class). Toute classe hérite implicitement de Object → possède donc les méthodes toString(), equals(), hashCode(), etc. 🔹 2. Constructeurs Si aucune déclaration → le compilateur génère un constructeur par défaut (sans paramètres). Un constructeur peut être private (utilisé dans le pattern Singleton ou classes utilitaires). 🔹 3. Méthodes Les méthodes peuvent être surchargées (overloading) → même nom, paramètres différents. Les méthodes peuvent être surdéfinies (overriding) → même signature, dans une sous-classe. Une méthode final ne peut pas être redéfinie dans une sous-classe. Une méthode abstract est déclarée sans corps et doit être implémentée dans une sous-classe. abstract et final sont incompatibles (contradiction). 🔹 4. Attributs Un attribut final est une constante : doit être initialisé une seule fois (déclaration ou constructeur). 🔹 5. Interfaces Une interface ne peut pas être instanciée.\nUne interface n’est pas un objet, c’est un contrat.\nUne interface n’hérite pas d’Object, mais les classes qui l’implémentent héritent d’Object.\nUne interface peut hériter d’une ou plusieurs autres interfaces avec extends.\nUne interface ne peut pas hériter d’une classe.\nMéthodes dans une interface :\nAvant Java 8 → uniquement public abstract. Depuis Java 8 → méthodes default et static avec implémentation. Depuis Java 9 → méthodes private pour factoriser du code interne. 🔹 6. Comparable vs Comparator Comparable : définit l’ordre naturel d’une classe (méthode compareTo). Comparator : définit un ordre externe, peut être multiple et personnalisé (méthode compare). 🔹 7. Mots-clés spéciaux null → valeur littérale spéciale, pas un mot-clé. this → référence à l’instance courante. super → référence à la classe parente. Résumé Élément Description Exemple Classe abstract Non instanciable, modèle pour héritage abstract class Forme { abstract double aire(); } Classe final Ne peut pas être héritée final class Utilitaire {} Méthode final Ne peut pas être redéfinie public final void calcul() {} Méthode abstract Sans corps, à implémenter abstract void afficher(); Attribut final Constante, valeur fixée une seule fois final double PI = 3.14; Interface Contrat, non instanciable interface Vehicule { void rouler(); } Comparable Ordre naturel, compareTo class Etudiant implements Comparable\u003cEtudiant\u003e Comparator Ordre externe, compare Comparator\u003cEtudiant\u003e parNom = ...;",
    "description": "Rappel : Concepts de base Classe : Modèle définissant les attributs (variables) et comportements (méthodes).\nObjet : Instance concrète d’une classe.\nEncapsulation : Protéger les données via des modificateurs d’accès (private, public, protected) et exposer des méthodes d’accès (getters/setters).\nAbstraction : Masquer les détails d’implémentation et ne montrer que les fonctionnalités essentielles (via classes abstraites et interfaces).\nHéritage : Une classe peut hériter des attributs et méthodes d’une autre (mot-clé extends).",
    "tags": [],
    "title": "Révision",
    "uri": "/420-311/intro/revisionpoo/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Questions théoriques Question 1 : Quel est le résultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le résultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le résultat du code suivant:\npublic class Question3 { public static void main(String[]args) { int val1 = 9; int val2 = 9; String str = \"9\"; System.out.println(val1 + val2 + str);\t} }\rQuestion 4 : Quel est le résultat du code suivant:\npublic class Question4 { public static void main(String[]args) { try { int a, b; b = 0; a = 5 / b; System.out.print(\"A\"); } catch (Exception e) { System.out.print(\"B\"); } finally { System.out.print(\"C\"); }\t} }\rQuestion 5 : Quel est le résultat du code suivant:\npublic class Question5 { public static void main(String[]args) { String obj = \"Bonjour\"; String obj1 = \"Bonsoir\"; String obj2 = \"Bonjour\"; System.out.println(obj.equals(obj1) + \" \" + obj.equals(obj2)); } }\rQuestion 6 : Quel est le résultat du code suivant:\npublic class ClasseA { public int i; public int j; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.j = 3; System.out.println(i + \" \" + j); } } public class Question6 { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 7 : Quel est le résultat du code suivant:\npublic class ClasseA { public int i; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.i = j + 1; System.out.println ( j + \" \" + i); } } public class Main { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 8 : Quel est le résultat du code suivant:\npublic class Question8{ public static void main(String[] args) { String s = \"Hello World\"; int A = s.indexOf('o'); int B = s.lastIndexOf('l'); System.out.println(A + \" \" + B); } }\rQuestion 9 : Quel est le résultat du code suivant:\npublic class Question9{ public static void main(String[] args) { char ch; ch = \"hello\".charAt(1); System.out.println(ch); } }\rQuestion 10 : Quel est le résultat du code suivant:\npublic class Question10{ public static void main(String[] args) { String chars[] = {\"a\", \"b\", \"c\", \"a\", \"c\"}; for (int i = 0; i \u003c chars.length; ++i) for (int j = i + 1; j \u003c chars.length; ++j) if(chars[i].compareTo(chars[j]) == 0) System.out.print(chars[j]); } }\rQuestion 11 : Quel est le résultat du code suivant:\npublic class Question11{ public static void main(String[] args) { int a1[] = new int[10]; int a2[] = { 1, 2, 3, 4, 5 }; System.out.println(a1.length + \" \" + a2.length); } }\rQuestion 12 : Quel est le résultat du code suivant:\npublic class Question12{ public static void main(String[] args) { int arr[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i \u003c arr.length - 2; ++i) System.out.print(arr[i] + \" \"); } }\rQuestion 13 : Quel est le résultat du code suivant:\npublic class Question13{ public static int param1; public static int param2; public void add(int a, int b) { param1 = a + b; param2 = param1 + b; } public static void main(String args[]) { Question13 obj1 = new Question13(); Question13 obj2 = new Question13(); int a = 2; obj1.add(a, a + 1); obj2.add(5, a); System.out.println(obj1.param1 + \" \" + obj2.param2); } }\rQuestion 14 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question14{ public static void main(String[] args) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 15 : Quel est le résultat du code suivant:\npublic class Question15{ public static int param1; public void increment() { param1++; } public static void main(String args[]) { Question15 obj1 = new Question15(); Question15 obj2 = new Question15(); obj1.param1 = 0; obj1.increment(); obj2.increment(); System.out.println(obj1.param1 + \" \" + obj2.param1); } }\rQuestion 16 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question16 { public static void main(String args[]) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 17 : Quel est le résultat du code suivant:\npublic class Question17 { public static void main(String[] args) { ClasseB classeB = new ClasseB(); System.out.println(\"Valeur = \" + classeB.calculer(3, 6)); } } class ClassA { final public int calculer(int a, int b) { return 0; } } class ClasseB extends ClasseA { public int calculer(int a, int b) { return 1; } }\rQuestion 18 : Quel est le résultat du code suivant:\npublic class Question18 { public static void main (String args[]) { int param1, param2= 1; param1= 10; if (param1!= 10 \u0026\u0026 param1/ 0 == 0) { System.out.println(param2); } else { System.out.println(++param2); } } }\rQuestion 19 : Quel est le résultat du code suivant:\npublic class Question19 { public static int param1; public static int param2; public void add(int val1, int val2) { param1 = val1 + val2; param2 = param1 + val2; } public static void main(String[] args) { Question19 instance1 = new Question19 (); Question19 instance2 = new Question19 (); Question19 instance3 = new Question19 (); int abc = 2;\tinstance1.add(abc, abc-1); instance3.add(6, 6/abc); instance2.add(5, abc/2); System.out.println(instance1.param1); System.out.println(instance2.param2); } }\rQuestion 20 : Quel est le résultat du code suivant:\nimport java.util.Arrays; public class Question20 { public static void main(String args[]) { int array[] = new int [5]; for (int i = 5; i \u003e 0; i--) { array[5 - i] = i; } Arrays.sort(array); System.out.print(Arrays.toString(array)); } }\rQuestion 21 : Quel est le résultat du code suivant:\npublic class Question21 { public static void main(String [] args) { Question21 instance = new Question21(); instance.myMethod(); } public void myMethod(){ long [] tab1 = {6,8,9}; long []tab2 = affectation(tab1); System.out.print(tab1[0] + tab1[1] + tab1[2] + \" \"); System.out.println(tab2[0] + tab2[1] + tab2[2]); } public long[] affectation(long[] tab3){ tab3[1] = 7; return tab3; } }\rExercices pratiques Exercice 1 : Soit la String suivante: A-b-C-d-E-f-1234-***///-\u003e , écrire un programme en Java qui:\n👍 convertit chaque caractère alphabétique majuscule de la String en un caractère minuscule; 👍 Convertis chaque caractère alphabétique minuscule de la String en un caractère majuscule; 👍 Supprime tous les caractères spéciaux de la String; Exercice 2 : Soit le tableau suivant: String [] days = { \"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\", \"Dimanche\"}; Écrire un programme en Java qui:\n👍 choisi aléatoirement une journée du tableau et l’affiche; 👍 Tri le tableau; Exercice 3 : Soit le code Java suivant:\nString str1 = \"Bonjour\"; String str2 = new String (\"Bonjour\"); str1 == str2; //3 str1.equals(str2); //4\rExpliquez la différence entre les 02 lignes de code (ligne 3 et ligne 4)?\nExercice 4 : Soit la classe Compte bancaire avec les attributs suivants:\nidCpte (numéro unique: donc 2 comptes ne peuvent pas avoir le même ID); firstName; lastName; solde; En utilisant les collections Java (List, Set et Map) et en vous utilisant l’API Java, vous devez coder les méthodes suivantes:\n👍 addCompteToCollection (List | Set | Map)\r👍 serachCompteInCollection (List | Set | Map)\r👍 sortCollection (List | Set | Map)\r👍 removeCompteFromCollection (List | Set | Map)\r👍 emptyCollectionComptes (List | Set | Map)\rExercice 5 : Écrire un code Java qui convertit un tableau d’entiers (tableau à crochets) en une collection de type List.\nÉcrire un code Java qui convertit une collection de type List en un tableau à crochets.\nÉcrire un code Java qui convertit une collection de type List en une collection de Type Set.\nÉcrire un code Java qui convertit une collection de type Set en une collection de Type List.\nÉcrire un code Java qui convertit une collection de type List en une collection de Type Map.\nÉcrire un code Java qui convertit une collection de type Map en une collection de Type List.\nExercice 6 : Soit le tableau de conversion des devises suivant :\nDe Vers Taux Dollar canadien (CAD) Euro 1 CAD = 0.74 EURO Dollar canadien (CAD) Dollar américain (USD) 1 CAD = 0.69 USD Euro Dollar canadien (CAD) 1 EURO = 1.45 CAD Dollar américain (USD) Dollar canadien (CAD) 1 USD = 1.36 CAD Écrire un programme Java qui demande à un utilisateur de choisir un type conversion et saisir un montant à convertir. Le programme traitera la conversion et affichera le montant converti.\nCondition:\nLe programme n’acceptera que les montants entre 90 et 6500, cela dans chaque sorte de devises. Le programme ne doit pas s’arrêter tant que l’utilisateur n’aura pas choisi de quitter. Exercice 7 : Soit le système de notation universitaire :\nNote numérique Note littérale 90 et + A De 80 à 89 B De 70 à 79 C De 60 à 69 D De 50 à 59 E \u003c 50 F Écrire un programme Java qui demande à un utilisateur de saisir 4 notes numériques. Ensuite le programme calculera la moyenne et affichera la note littérale correspondante.\nCondition:\nLe programme n’acceptera que les notes entre 0 et 100.\nExemple\nLe programme demande les notes à l’utilisateur : Veuillez saisir vos notes Svp : L’utilisateur saisit les notes suivantes : 59, 72.5, 83.73, 45.5\nLe programme calculera la moyenne et affichera :\nVotre moyenne numérique est : 65,18 ce qui donnera en littérale la note de D.\nExercice 8 : Soit la liste des villes suivantes : Ottawa, Paris, Berne, Washington, Berlin, Madrid, Mexico.\n🌼 Écrire un programme Java qui génère aléatoirement 2 villes parmi la liste des villes et demandera à un utilisateur de deviner les 2 villes au bout de 3 tentatives.\nSi l’utilisateur arrive à deviner les 2 villes aléatoires, le programme affichera un message et quittera. Si l’utilisateur n’arrive pas à deviner les 2 villes aléatoires au bout de 3 tentatives, le programme affichera le résultat et quittera. Clarification\nModèle de message en cas de succès de devinette Bravo! Vous avez deviné les 2 villes : Ottawa et Paris. Modèle de message en cas d’échec de devinette Oups! En 3 tentatives, vous n’êtes pas arrivé à deviner les 2 villes : Ottawa et Paris. Exercice 9 : On souhaite gérer une liste de prénoms d’étudiants dans un cours. Réalise un programme Java qui :\nCrée une liste de type ArrayList. Ajoute les prénoms suivants : “Alice”, “Bob”, “Charlie”, “Diane”. Affiche la taille de la liste et son contenu. Demande à l’utilisateur d’entrer un prénom, puis : Vérifie s’il est présent dans la liste (affiche un message approprié). Si présent, affiche sa position dans la liste. Supprime un prénom donné par l’utilisateur et réaffiche la liste. Trie la liste par ordre alphabétique et affiche le résultat. Exercice 10 : Soit le diagramme de classes suivant :\nCréer les classes Java correspondant aux classes du diagramme. Il vous faudra respecter les attributs et les relations entre les différentes classes. Écrire une méthode de service qui permet de calculer le prix réel d’un produit suivant la règle suivante : a.\tSi le produit est biologique, « indiceBio » et le produit appartiennent à un fournisseur habitant la province du « Québec », alors le prix réel est :\ni.\tPrix réel = prix du produit + prix du produit*tps + prix du produit * tvq. b.\tSi le produit est biologique, « indiceBio » et le produit appartiennent à un fournisseur habitant le Canada (sauf la province du Québec) alors le prix réel est :\ni.\tPrix réel = prix du produit + prix du produit*tps. c.\tSi le produit est biologique « indiceBio » et le produit appartient à un fournisseur habitant les USA alors le prix réel est :\ni.\tPrix réel = prix du produit + prix du produit*usTax. Écrire une méthode de service qui permet de calculer le total prix (la somme totale) des produits de tous les fournisseurs américains. Exercice 11 : Soit la String suivante: String chaineDepart = “$_%4*1;-0er2bo%t?c(o(id\u003eer7dn1ev” écrire le programme qui traite l’algorithme suivant:\nLire la String « chaineDepart » Parcourir la String et appliquer le traitement suivant: Mettre les 04 premiers caractères dans une Stack (appelée stack01); Mettre les 04 caractères suivants dans une liste (appelée liste01); Mettre les 04 caractères suivants dans un vecteur (appelée vecteur01); Mettre le reste de la chaine dans une Queue (appelée queue01); Déclarer un String vide appelé resultat01; Déclarer un String vide appelé resultat02; Dépilez le premier élément de la stack01 et ajoutez-le à la String resultat01; Ajouter à la String resultat01, le 2e qui se trouve dans liste01; Parcourez le vecteur01, si l’élément est un chiffre, mettez-le dans la String resultat01, sinon mettez-le dans la String resultat02; Défiler la queue01, mettez seulement les lettres alphabétiques dans la String resultat02. Inversez les 02 Strings; Déclarer un String vide appelé resultatFinal; Copiez les 08 premiers caractères de la String resultat02 dans la String resultatFinal; Ajoutez un espace à la String resultatFinal; Copiez les 02 premiers éléments de la String resultat01 dans la String resultatFinal; Ajoutez un espace à la String resultatFinal; Copiez le reste des caractères de la String resultat02 dans la String resultatFinal; Ajoutez un espace à la String resultatFinal; Copiez le reste des caractères de la String resultat01 dans la String resultatFinal; Afficher le résultat;",
    "description": "Questions théoriques Question 1 : Quel est le résultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le résultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le résultat du code suivant:",
    "tags": [],
    "title": "Questions et exercices",
    "uri": "/420-311/intro/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Préalables",
    "content": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code d’événement dans le bandeau supérieur Quiz 2 : méthodes et interfaces Quiz Wooclap sur les méthodes et les interfaces",
    "description": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code d’événement dans le bandeau supérieur Quiz 2 : méthodes et interfaces Quiz Wooclap sur les méthodes et les interfaces",
    "tags": [],
    "title": "Quiz",
    "uri": "/420-311/intro/quiz/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "Tout au long du cours nous allons utiliser différents outils de développement logiciel largement employés dans l’industrie. Ces outils permettent de travailler de manière plus efficace, professionnelle et collaborative.\nGit : pour gérer les versions du code et collaborer en équipe.\nMaven : pour automatiser la gestion des dépendances et la compilation des projets Java.\nAutres outils : environnements de développement (IDE), plateformes de test, documentation et suivi de projet.\nCette section vous trouver des ressources qui vous aident à se familiariser avec ces outils.",
    "description": "Tout au long du cours nous allons utiliser différents outils de développement logiciel largement employés dans l’industrie. Ces outils permettent de travailler de manière plus efficace, professionnelle et collaborative.\nGit : pour gérer les versions du code et collaborer en équipe.\nMaven : pour automatiser la gestion des dépendances et la compilation des projets Java.\nAutres outils : environnements de développement (IDE), plateformes de test, documentation et suivi de projet.",
    "tags": [],
    "title": "Ressources utiles",
    "uri": "/420-311/ressourcesutiles/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "Notion de structure de données Ⓜ️ Le principe de base d’une structure de données, c’est de stocker des éléments auxquels le programmeur veut pouvoir accéder plus tard. On appelle les différentes utilisations possibles de la structure de données des opérations.\nClassification des structures de données 🔹 Structures de base Tableau (array) : Une collection d’éléments de même type stockés en mémoire de façon contiguë. Chaque élément est accessible par son index.\nSchéma Index : 0 1 2 3\rValeur: [10] [20] [30] [40]\rComplexité Accès direct : O(1) Recherche d’une valeur : O(n) Insertion/suppression : O(n) (décalage nécessaire) Avantages Accès rapide par index. Simple à utiliser. Inconvénients Taille fixe (souvent). Insertion/suppression coûteuses. Exemple réel Les sièges d’un avion numérotés → on sait directement où est le siège 25B.\nListe chaînée (linked list) : Une séquence de nœuds où chaque nœud contient une valeur et une référence vers le suivant (et parfois vers le précédent → liste doublement chaînée).\n* Liste simplement chaînée 🌼 Les listes simplement chaînées sont des structures de données semblables aux tableaux. Les éléments de la liste sont souvent appelés Liens ou Nœuds. 🌼 Un élément de la liste se compose : \tUn autre pointeur qui pointe vers l’élément suivant, \tLe pointeur suivant du dernier élément doit pointer vers NULL (la fin de la liste). \tEn plus un élément se compose d’une valeur 🌼 Pour accéder à un élément, la liste peut être parcourue dans les deux sens : 🌼 En commençant en tête de liste, le pointeur suivant permettra le déplacement vers le prochain élément. 🌼 En bref, le déplacement se fait dans une seule direction, du premier vers le dernier élément.\n* Liste doublement chaînée 🌼 Les listes doublement chaînées sont des structures de données semblables aux listes simplement chaînées. Les éléments de la liste sont souvent appelés Liens ou Nœuds. La classe LinkedList permet de manipuler des listes dites “doublement chaînées”. À chaque élément de la collection, on associe (de façon totalement transparente pour le programmeur) deux informations supplémentaires qui ne sont autres que les références à l’élément précédent et au suivant. Une telle collection peut ainsi être parcourue à l’aide d’un itérateur bidirectionnel de type ListIterator.\nLe grand avantage d’une telle structure est de permettre des ajouts ou des suppressions à une position donnée avec une efficacité en O (1) (ceci grâce à un simple jeu de modification de références).\nEn revanche, l’accès à un élément en fonction de sa valeur ou de sa position dans la liste sera peu efficace puisqu’il nécessitera obligatoirement de parcourir une partie de la liste. L’efficacité sera donc en moyenne en O (N).\nSchéma Tête → [10|•] → [20|•] → [30|null]\rListe simplement chaînée et liste doublement chaînée\nListe simplement chaînée circulaire\nComplexité Insertion/suppression en tête : O(1)\nInsertion :\nà la fin O(1) au début O(1) au milieu O(n) suppression :\nau début O(1) à la fin O(n) / O(1) dans les Listes doublement chaînées. au milieu O(n) Accès à un élément : O(n)\nAvantages Taille dynamique. Insertion/suppression rapides en tête/fin. Inconvénients Accès séquentiel (lent). Plus de mémoire (pointeurs). Exemple réel Un collier de perles où chaque perle est attachée à la suivante.\n🔹 Structures linéaires spécialisées Pile (Stack) Structure LIFO (Last In, First Out). Le dernier élément inséré est le premier retiré.\nSchéma Push(10) → Push(20) → Push(30)\rPile: [30] [20] [10]\rPop() → 30\rstack\nOpérations push(x) : ajouter en haut. pop() : retirer le dernier. peek() : lire le dernier sans le retirer. Complexité Insertion/retrait : O(1) Exemple réel Pile d’assiettes à laver à la main.\nFile (Queue) Structure FIFO (First In, First Out). Le premier élément inséré est le premier retiré.\nSchéma Enqueue(10) → Enqueue(20) → Enqueue(30)\rFile: [10] [20] [30]\rDequeue() → 10\rFile\nOpérations enqueue(x) : ajouter à la fin. dequeue() : retirer au début. peek() : lire le premier sans le retirer. Complexité Insertion/retrait : O(1) Exemple réel File d’attente à la caisse d’un magasin.\nFile de priorité (Priority Queue / Tas / Heap) Une file où chaque élément a une priorité. L’élément avec la plus haute priorité sort en premier. Souvent implémentée avec un tas binaire (heap).\nSchéma (tas min) 10\r/ \\\r20 15\r/ \\\r30 25\rExplication simple\nComplexité Insertion : O(log n) Extraction du min/max : O(log n) Exemple réel Service d’urgence à l’hôpital → les cas graves passent avant.\n🔹 Structures hiérarchiques Arbre (Tree) Une structure hiérarchique composée de nœuds reliés par des arêtes. Chaque nœud a :\nune valeur, des enfants. Schéma (arbre binaire) 10\r/ \\\r5 20\r/ \\ \\\r2 8 30\rTypes Arbre binaire : max 2 enfants. Arbre binaire de recherche (BST) : gauche \u003c racine \u003c droite. Arbres équilibrés (AVL, Red-Black). Complexité (BST équilibré) Recherche, insertion, suppression : O(log n) Exemple réel Arborescence des dossiers/fichiers dans un ordinateur.\nGraphe (Graph) Un ensemble de sommets (nœuds) reliés par des arêtes (liens). Peut être orienté ou non, pondéré ou non.\nSchéma A —— B —— C\r| \\\rD E\rReprésentations Liste d’adjacence. Matrice d’adjacence. Complexité Parcours BFS/DFS : O(V + E) (V = sommets, E = arêtes). Exemple réel Un réseau social (Facebook : personnes = sommets, amitiés = arêtes).\n🔹 Structures de recherche Table de hachage (Hash Table / HashMap) Associe une clé à une valeur via une fonction de hachage.\nSchéma Clé → Hachage → Index → Valeur\r\"Bob\" → h(\"Bob\")=2 → table[2] = 90\rComplexité Insertion/recherche/suppression : O(1) en moyenne. Avantages Accès très rapide. Inconvénients Collisions possibles (deux clés pour le même index). Consomme plus de mémoire. Exemple réel Annuaire téléphonique (nom → numéro).\n📌 Tableau récapitulatif Structure Accès Insertion Suppression Exemple concret Tableau O(1) (index) / O(n) (valeur) O(n) O(n) Sièges d’avion Liste chaînée O(n) O(1) en tête ou fin O(1) en tête Collier de perles Pile (Stack) O(n) O(1) O(1) Pile d’assiettes File (Queue) O(n) O(1) O(1) File d’attente Tas (Heap) O(n) O(log n) O(log n) Urgences hôpital Arbre (BST) O(log n) O(log n) O(log n) Arborescence fichiers Graphe O(V+E) O(1) O(1) Réseau social Hash Table O(1) O(1) O(1) Dictionnaire Dictionnaire et table associative (l’interface Map) 🌼 Une table associative permet de conserver une information associant deux parties nommées clé et valeur. 🌼 Elle est principalement destinée à retrouver la valeur associée à une clé donnée. Les exemples les plus caractéristiques de telles tables sont :\n\t👍 Le dictionnaire : à un mot (clé), on associe une valeur qui est sa définition,\n\t👍 L’annuaire usuel : à un nom (clé), on associe une valeur comportant le numéro de téléphone et, éventuellement, une adresse, \t👍 L’annuaire inversé : à un numéro de téléphone (qui devient la clé), on associe une valeur comportant le nom et, éventuellement, une adresse.",
    "description": "Notion de structure de données Ⓜ️ Le principe de base d’une structure de données, c’est de stocker des éléments auxquels le programmeur veut pouvoir accéder plus tard. On appelle les différentes utilisations possibles de la structure de données des opérations.\nClassification des structures de données 🔹 Structures de base Tableau (array) : Une collection d’éléments de même type stockés en mémoire de façon contiguë. Chaque élément est accessible par son index.",
    "tags": [],
    "title": "Les structures de données",
    "uri": "/420-311/sdd/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util). On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nStructure générale des collections en Java Une collection représente un groupe d’objets, connu par ses éléments. Certaines collections acceptent les doublons, d’autres pas. Certaines sont ordonnées, d’autres pas.\nInterface Collection Depuis la version 1.6 de Java, il y a un changement dans la structure des collections. Il y a eu l’ajout du package java.util.concurrent\nExemples : Besoin d’accès rapide par clé ? → HashMap. Besoin de garder l’ordre trié ? → Arbre. Besoin d’un traitement dans l’ordre d’arrivée ? → File. Vous pourrez généralement vous contenter de connaître les fonctionnalités supplémentaires qu’offre chacune des classes LinkedList, ArrayList, Vector, HashSet, TreeSet, PriorityQueue et ArrayDeque. Mais, dans certains cas, vous devrez avoir quelques notions sur l’architecture d’interfaces employée par les concepteurs de la librairie. Elle se présente comme suit :\nCollection\nList implémentée par LinkedList, ArrayList et Vector Set implémentée par HashSet SortedSet implémentée par TreeSet NavigableSet implémentée par TreeSet (Java 6) Queue (JDK 5.0) implémentée par LinkedList, PriorityQueue Deque (Java 6) implémentée par ArrayDeque, LinkedList L’interface Iterable public interface \u003cE\u003e Collection extends Iterable \u003cE\u003e\rCollection est l’interface racine dans la hiérarchie des collections. Une collection représente un groupe d’objets, connu sous le nom de ses éléments. Certaines collections :\nPermettent de dupliquer les éléments et d’autres pas. Elles sont ordonnées et d’autres pas. Le JDK ne fournit pas directement les implémentations de cette interface : il fournit des implémentations de sous-interfaces plus spécifiques telles que Set et List.\nL’interface List public interface List\u003cE\u003e extends Collection\u003cE\u003e\rUne liste est une collection ordonnée (également connu sous le nom de séquence).\nL’utilisateur de cette interface à un contrôle précis sur l’endroit où est inséré chaque élément dans la liste. L’utilisateur peut accéder aux éléments par leur index (position dans la liste), et rechercher des éléments dans la liste. Les listes permettent généralement les éléments dupliqués. Les listes permettent de multiples éléments nuls. Il n’est pas inconcevable que quelqu’un puisse vouloir mettre en place une liste qui interdit les doublons, par exemple : en lançant des exceptions d’exécution lorsque l’utilisateur tente de les insérer, cet usage est rare.\n🔹 Les listes chaînées - classe LinkedList Exemple\nLinkedList nombres = new LinkedList\u003c\u003e(); // =\u003e // LinkedList\u003cInteger\u003e nombres = new LinkedList\u003c\u003e(); nombres.addFirst(10); nombres.addLast(20); nombres.addLast(30); nombres.addLast(40); nombres.addFirst(50); nombres.removeLast(); nombres.removeFirst(); System.out.println(nombres); System.out.println(nombres.size()); System.out.println(nombres.contains(20)); System.out.println(nombres.indexOf(20)); var tab = nombres.toArray(); System.out.println(Arrays.toString(tab)); //Iterating LinkedList Iterator\u003cInteger\u003e iterator = nombres.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); }\r🔹 ArrayDeque File à deux extrémités (FIFO ou LIFO).\nExemple : File d’impression. import java.util.ArrayDeque; public class ExempleArrayDeque { public static void main(String[] args) { ArrayDeque\u003cString\u003e file = new ArrayDeque\u003c\u003e(); file.add(\"Doc1\"); file.add(\"Doc2\"); file.add(\"Doc3\"); System.out.println(\"Déqueue : \" + file.poll()); } }\rComplexité :\nInsertion/suppression en tête ou fin : O(1). Accès index : O(n). Mémoire : O(n). 🔹 Vector Est un tableau dynamique comme ArrayList, mais synchronisé (donc plus sûr en environnement multithread).\nExemple : Une liste partagée entre plusieurs threads où la sécurité des accès est importante.\nComplexité :\nAccès par index : O(1). Insertion fin : O(1) amorti (redimensionnement si plein). Insertion/suppression au milieu : O(n). Mémoire : O(n) (+ espace supplémentaire pour redimensionnement). import java.util.Vector; public class ExempleVector { public static void main(String[] args) { Vector\u003cString\u003e vecteur = new Vector\u003c\u003e(); vecteur.add(\"Alice\"); vecteur.add(\"Bob\"); vecteur.add(\"Charlie\"); System.out.println(\"Élément à l’index 1 : \" + vecteur.get(1)); vecteur.remove(\"Alice\"); System.out.println(\"Après suppression : \" + vecteur); } }\rComplexité :\nAccès par index : O(1). Insertion fin : O(1) amorti (redimensionnement si plein). Insertion/suppression au milieu : O(n). Mémoire : O(n) (+ espace supplémentaire pour redimensionnement). 🔹 Stack Structure LIFO (dernier entré, premier sorti).\nExemple : Pile d’assiettes. import java.util.Stack; public class ExempleStack { public static void main(String[] args) { Stack\u003cString\u003e pile = new Stack\u003c\u003e(); pile.push(\"A\"); pile.push(\"B\"); pile.push(\"C\"); System.out.println(\"Pop : \" + pile.pop()); System.out.println(\"Sommet : \" + pile.peek()); } }\rComplexité :\nAjout : O(1). Suppression : O(1). lecture sommet : O(1). Mémoire : O(n). Les ensembles (Interface Set) Deux classes principales permettent d’implémenter la notion d’ensemble en Java : HashSet et TreeSet.\nQu’est-ce qu’un ensemble ? Théoriquement, un ensemble est une collection d’éléments uniques, où :\naucun élément ne peut apparaître plusieurs fois, l’ordre des éléments n’a pas d’importance. Ainsi, à chaque fois qu’on insère un nouvel élément dans un HashSet ou un TreeSet, Java vérifie automatiquement que l’élément n’existe pas déjà.\nL’importance de equals, hashCode et compareTo Pour des types simples comme String, File ou les types numériques (Integer, Double…), tout fonctionne naturellement : l’égalité est déjà bien définie.\nEn revanche, pour des objets définis par l’utilisateur, il est souvent nécessaire de redéfinir correctement :\nla méthode equals() (et hashCode()) → pour les ensembles basés sur le hachage, la méthode compareTo() (ou fournir un Comparator) → pour les ensembles basés sur les arbres. 👉 Sans cette redéfinition, deux objets représentant la même valeur mais ayant des références différentes seront considérés comme distincts.\nPourquoi un ordre interne ? Même si, en théorie, un ensemble est “non ordonné”, les concepteurs des collections Java ont dû organiser les données pour rendre les tests d’appartenance (ex. set.contains(x)) efficaces. Sinon, il faudrait parcourir tous les éléments un par un, ce qui coûterait O(n).\nDeux stratégies ont donc été retenues :\n🔹 HashSet Définition : Ensemble non ordonné, sans doublons. Utilise une fonction de hachage pour répartir les éléments dans des cases. Avantage : test d’appartenance, insertion et suppression très rapides → O(1) en moyenne. Inconvénient : les éléments n’ont aucun ordre visible. Exemple : Liste d’étudiants inscrits (pas de doublons). import java.util.HashSet; public class ExempleHashSet { public static void main(String[] args) { HashSet\u003cString\u003e etudiants = new HashSet\u003c\u003e(); etudiants.add(\"Alice\"); etudiants.add(\"Bob\"); etudiants.add(\"Alice\"); // ignoré System.out.println(\"Étudiants : \" + etudiants); } }\rComplexité :\nRecherche : O(1). Insertion : O(1). Suppression : O(1). Mémoire : O(n). 🔹 TreeSet 🌼 La classe TreeSet propose une autre organisation utilisant un “arbre binaire” (arbre binaire de recherche équilibré), lequel permet d’ordonner totalement les éléments. On y utilise, cette fois, la relation d’ordre naturel induite par la méthode compareTo des objets ou par un comparateur (qu’on peut fournir à la construction de l’ensemble).\n🌼 Dans ces conditions, la recherche dans cet arbre d’un élément de valeur donnée est généralement moins rapide que dans une table de hachage, mais plus rapide qu’une recherche séquentielle. On peut montrer que son efficacité est en O(log n). Il est légèrement plus lent qu’un HashSet.\n🌼 Par ailleurs, l’utilisation d’un arbre binaire permet de disposer en permanence d’un ensemble totalement ordonné (trié). On notera d’ailleurs que la classe TreeSet dispose de deux méthodes spécifiques first et last fournissant respectivement le premier et le dernier élément de l’ensemble.\nExemple : Classement des notes. import java.util.TreeSet; public class ExempleTreeSet { public static void main(String[] args) { TreeSet\u003cInteger\u003e notes = new TreeSet\u003c\u003e(); notes.add(85); notes.add(90); notes.add(70); System.out.println(\"Notes triées : \" + notes); } }\rComplexité :\nRecherche : O(log n). Insertion : O(log n). Suppression : O(log n). Mémoire : O(n). Comparaison HashSet : rapide, sans ordre → parfait pour vérifier l’appartenance rapidement. TreeSet : plus lent, mais les éléments sont triés → utile si on veut parcourir l’ensemble dans un ordre précis. Dictionnaire et table associative (l’interface Map) 🌼 Depuis le JDK 5.0, les tables associatives sont génériques, au même titre que les collections, mais elles sont définies par deux paramètres de type (celui des clés, noté généralement K, celui des valeurs, noté généralement V) au lieu d’un.\nImplémentation des Map 🌼 Comme pour les ensembles, l’intérêt des tables associatives est de pouvoir y retrouver rapidement une clé donnée pour en obtenir l’information associée. On va donc tout naturellement retrouver les deux types d’organisation rencontrés pour les ensembles :\n👍 Table de hachage : classe HashMap, 👍 Arbre binaire : classe TreeMap. 🌼 Dans les deux cas, seule la clé sera utilisée pour ordonnancer les informations. 🌼 Dans le premier cas, on se servira du code de hachage des objets formant les clés ; dans le second cas, on se servira de la relation d’ordre induite par compareTo ou par un comparateur fixé à la construction. 🌼 L’accès à un élément d’un HashMap sera en O (1) tandis que celle à un élément d’un TreeMap sera en O (Log N).\n🌼 En contrepartie de leur accès moins rapide, les TreeMap seront (comme les TreeSet) ordonnés en permanence suivant leurs clés.\nPrésentation générale des classes HashMap et TreeMap 🌼 Comme nous l’avons signalé, les classes HashMap et TreeMap n’implémentent plus l’interface Collection, mais une autre interface nommée Map. Ceci provient essentiellement du fait que leurs éléments ne sont plus à proprement parler des objets, mais des “paires” d’objets c’est-à-dire une association entre deux objets.\n👍 Ajout d’information 🌼 La plupart des constructeurs créent une table vide. Pour ajouter une clé à une table, on utilise la méthode put à laquelle on fournit la clé et la valeur associée ; par exemple, si K désigne le type des clés et V celui des valeurs :\n/* création d’une table vide */ HashMap \u003cK, V\u003e m = new HashMap \u003cK, V\u003e () ; /* ajoute à m, un élément associant la clé \"m\" (String) à la valeur 3 (Integer) */ m.put (\"m\", 3) ;\r🌼 Si la clé fournie à put existe déjà, la valeur associée remplacera l’ancienne (une clé donnée ne pouvant figurer qu’une seule fois dans une table). D’ailleurs, put fournit en retour soit l’ancienne valeur si la clé existait déjà, soit nul.\n🌼 Notez que, comme pour les autres collections, les clés et les valeurs doivent être des objets. Il n’est théoriquement pas nécessaire que toutes les clés soient de même type, pas plus que les éléments. En pratique, ce sera presque toujours le cas pour des questions évidentes de facilité d’exploitation de la table.\n👍 Recherche d’information 🌼 On obtient la valeur associée à une clé donnée à l’aide de la méthode get, laquelle fournit nulle si la clé cherchée n’est pas présente (V représente le type de la valeur) :\nV o = get (\"x\") ; // fournit la valeur associée à la clé \"x\" // if (o == null) System.out.println (\"Aucune valeur associée à la clé x\") ;\r🌼 L’efficacité de cette recherche est en O (1) pour HashMap et en O(Log N) pour TreeMap.\n🌼 La méthode containsKey permet de savoir si une clé donnée est présente avec la même efficacité.\n👍 Suppression d’information 🌼 On peut supprimer un élément d’une table en utilisant la méthode remove, laquelle fournit en retour l’ancienne valeur associée si la clé existe ou la valeur null dans le cas contraire :\nV val = remove (cle) ;\t// supprime l’élément (clé + valeur) de clé \"x\" if (val != null) System.out.println (\"On a supprimé l’élément de clé \" + cle + \" et de valeur\" + val);\r🔹 HashMap Associe une clé à une valeur, accès rapide.\nExemple : Dictionnaire (mot → définition). import java.util.HashMap; public class ExempleHashMap { public static void main(String[] args) { Map\u003cString, Integer\u003e notes = new HashMap\u003c\u003e(); notes.put(\"Alice\", 85); notes.put(\"Bob\", 90); System.out.println(\"Note de Bob : \" + notes.get(\"Bob\")); // Parcours des clés/valeurs for (Map.Entry\u003cString, Integer\u003e e : notes.entrySet()) { System.out.println(e.getKey() + \" → \" + e.getValue()); } } }\rComplexité :\nRecherche : O(1) (moyenne), O(n) (pire cas si collisions). Insertion : O(1).* Suppression : O(1). Mémoire : O(n) + surcharge pour les tables de hachage. 🔹 TreeMap Map triée par clés.\nExemple : Carnet d’adresses trié par nom. import java.util.TreeMap; public class ExempleTreeMap { public static void main(String[] args) { TreeMap\u003cString, Integer\u003e carnet = new TreeMap\u003c\u003e(); carnet.put(\"Charlie\", 555123); carnet.put(\"Alice\", 555789); carnet.put(\"Bob\", 555456); System.out.println(\"Carnet trié : \" + carnet); System.out.println(\"Premier : \" + arbre.firstEntry()); System.out.println(\"Dernier : \" + arbre.lastEntry()); } }\rComplexité :\nRecherche : O(log n). Insertion : O(log n). Suppression : O(log n). Mémoire : O(n). 🔹 LinkedHashMap Map qui garde l’ordre d’insertion.\nExemple : Historique de navigation. import java.util.LinkedHashMap; public class ExempleLinkedHashMap { public static void main(String[] args) { LinkedHashMap\u003cInteger, String\u003e historique = new LinkedHashMap\u003c\u003e(); historique.put(1, \"Google\"); historique.put(2, \"YouTube\"); historique.put(3, \"Wikipedia\"); System.out.println(\"Historique : \" + historique); } }\rComplexité :\nRecherche : O(log n). Insertion : O(log n). Suppression : O(log n). Mémoire : O(n). 🔹 LinkedHashSet Définition : Ensemble qui garde l’ordre d’insertion. Exemple : Liste d’achats sans doublons. import java.util.LinkedHashSet; public class ExempleLinkedHashSet { public static void main(String[] args) { LinkedHashSet\u003cString\u003e courses = new LinkedHashSet\u003c\u003e(); courses.add(\"Lait\"); courses.add(\"Pain\"); courses.add(\"Lait\"); // ignoré courses.add(\"Oeufs\"); System.out.println(\"Liste d’achats : \" + courses); } }\rTableau des complexités Structure Accès Insertion Suppression Mémoire HashMap O(1) O(1) O(1) O(n) TreeMap O(log n) O(log n) O(log n) O(n) LinkedHashMap O(1) O(1) O(1) O(n) LinkedList O(n) O(1) tête/fin O(1) tête/fin O(n) ArrayList O(1) index O(1) fin amorti O(n) O(n) Vector O(1) index O(1) fin amorti O(n) O(n) Stack O(n) accès O(1) push O(1) pop O(n) ArrayDeque O(n) accès O(1) tête/fin O(1) tête/fin O(n) HashSet O(1) O(1) O(1) O(n) TreeSet O(log n) O(log n) O(log n) O(n) LinkedHashSet O(1) O(1) O(1) O(n) 🔹 Tas (Heap) (PriorityQueue) import java.util.*; public class ExempleTas { public static void main(String[] args) { PriorityQueue\u003cInteger\u003e tas = new PriorityQueue\u003c\u003e(); tas.add(30); tas.add(10); tas.add(20); // Extrait toujours le plus petit élément System.out.println(\"Min : \" + tas.poll()); // 10 System.out.println(\"Min suivant : \" + tas.poll()); // 20 } }",
    "description": "Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util). On y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.",
    "tags": [],
    "title": "Les structures de données en Java ",
    "uri": "/420-311/sdd/javasdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "🌼 Pour coder une liste doublement chaînée en orientée objet, on doit coder :\nLa classe Lien ou Nœud Nous n’allons pas utiliser la notion de générique. La classe Lien ou nœud possède les champs suivants : Suivant de type Lien ou Nœud; Précédent de type Lien ou Nœud; Valeur de type entier. La classe Lien ou nœud possède les méthodes suivantes: Constructeur avec un paramètre qui sera la valeur; Getter/Setter pour les champs; Méthode d’affichage de la valeur. La classe ListeDoublementChainee Les champs de la classe : Premier de type Lien ou Nœud; Dernier de type Lien ou Nœud. Les méthodes: Un constructeur sans paramètres : ou il faut mettre Premier et Dernier à NULL; Une méthode booléenne estVide () : qui teste si Premier est NULL; Une méthode : public void insererEnDebutListe (int valeur) { Déclarer un nouveau Lien et lui passer la valeur en paramètres de la méthode; Si la liste estVide (){ Dernier = nouveauLien; } Sinon { Premier.Precedent = nouveauLien; nouveauLien.suivant = Premier; } Premier = nouveauLien; }\rUne méthode : public void insererEnFinDeListe (int valeur) { Déclarer un nouveauLien et lui passer la valeur en paramètres de la méthode; Si la liste estVide (){ Premier = nouveauLien; } Sinon { Dernier.suivant = nouveauLien; nouveauLien.precedent = Dernier; } Dernier = nouveauLien; }\rpublic boolean insererApresValeur (int valeurPosition, int valeurAInserer) { Lien courant = premier; Tant que (courant.valeur n’est pas égale à valeurPosition){ courant = courant.suivant; si (courant est NULL) { retourner FALSE; } Déclarer un nouveauLien et lui passer la valeurAInserer en paramètres de la méthode; Si (courant = Dernier){ nouveauLien.suivant = null; dernier = nouveauLien; } Sinon { nouveauLien.suivant = courant.suivant; courant.suivant.precedent = nouveauLien; } nouveauLien.precedent = courant; courant.suivant = nouveauLien; retourner true; // on a trouvé, on insére \"valeurAInserer\" } }",
    "description": "🌼 Pour coder une liste doublement chaînée en orientée objet, on doit coder :\nLa classe Lien ou Nœud Nous n’allons pas utiliser la notion de générique. La classe Lien ou nœud possède les champs suivants : Suivant de type Lien ou Nœud; Précédent de type Lien ou Nœud; Valeur de type entier. La classe Lien ou nœud possède les méthodes suivantes: Constructeur avec un paramètre qui sera la valeur; Getter/Setter pour les champs; Méthode d’affichage de la valeur. La classe ListeDoublementChainee Les champs de la classe : Premier de type Lien ou Nœud; Dernier de type Lien ou Nœud. Les méthodes: Un constructeur sans paramètres : ou il faut mettre Premier et Dernier à NULL; Une méthode booléenne estVide () : qui teste si Premier est NULL; Une méthode : public void insererEnDebutListe (int valeur) { Déclarer un nouveau Lien et lui passer la valeur en paramètres de la méthode; Si la liste estVide (){ Dernier = nouveauLien; } Sinon { Premier.Precedent = nouveauLien; nouveauLien.suivant = Premier; } Premier = nouveauLien; }\rUne méthode : public void insererEnFinDeListe (int valeur) { Déclarer un nouveauLien et lui passer la valeur en paramètres de la méthode; Si la liste estVide (){ Premier = nouveauLien; } Sinon { Dernier.suivant = nouveauLien; nouveauLien.precedent = Dernier; } Dernier = nouveauLien; }\rpublic boolean insererApresValeur (int valeurPosition, int valeurAInserer) { Lien courant = premier; Tant que (courant.valeur n’est pas égale à valeurPosition){ courant = courant.suivant; si (courant est NULL) { retourner FALSE; } Déclarer un nouveauLien et lui passer la valeurAInserer en paramètres de la méthode; Si (courant = Dernier){ nouveauLien.suivant = null; dernier = nouveauLien; } Sinon { nouveauLien.suivant = courant.suivant; courant.suivant.precedent = nouveauLien; } nouveauLien.precedent = courant; courant.suivant = nouveauLien; retourner true; // on a trouvé, on insére \"valeurAInserer\" } }",
    "tags": [],
    "title": "Algorithmes codage de la liste doublement chaînée",
    "uri": "/420-311/sdd/linkedlist/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Structure de données",
    "content": "Étude de cas 1 Étude de cas Soit les classes suivantes avec leurs attributs successives : Classe Compagnie assurance :\nnuméro de la compagnie (unique), nom de compagnie, liste assurances : une collection d’assurances de type List. Classe Assurance : code d’assurance (unique), nom de l’assurance, prix de l’assurance, type d’assurance (Habitation, Auto ou Vie). Écrire en Java un programme qui permet la gestion de la compagnie d’assurance. Dans ce programme vous devez coder les méthodes suivantes: Afficher le chiffre d’affaires total de la compagnie (somme totale des assurances). Afficher l’inventaire (la liste des assurances) de la compagnie triée en ordre décroissant de prix d’assurance (du plus grand vers le plus petit). Convertir la liste lue en une collection de type Map (Integer, Assurance). Trier la Map par clé (numéro d’assurance). Parcourir la liste des assurances et modifier les prix des assurances comme suit : Augmenter le prix de l’assurance habitation de 10% Diminuer le prix d’assurance auto de 8% Diviser le prix de l’assurance vie par : 3 si le code d’assurance est impair. 4 si le code d’assurance est pair. Étude de cas 2 La classe Compte possède les attributs suivants :\nnumCompte nom solde Objectif Mettre en pratique les notions liées aux collections Java :\nList Set Map Vous devez coder les méthodes suivantes :\n🔹 List Nom de la méthode Description addCompteToList Permet de rajouter une instance de la classe Compte dans une collection de type List. findCompte Permet de rechercher une instance de la classe Compte dans une collection de type List. deleteCompte Permet de supprimer une instance de la classe Compte dans une collection de type List. emptyList Permet de vider complètement une collection de type List. sortList Permet de trier une collection de type List. 🔹 Set Nom de la méthode Description addCompteToSet Permet de rajouter une instance de la classe Compte dans une collection de type Set. findCompte Permet de rechercher une instance de la classe Compte dans une collection de type Set. deleteCompte Permet de supprimer une instance de la classe Compte dans une collection de type Set. emptySet Permet de vider complètement une collection de type Set. sortSet Permet de trier une collection de type Set. 🔹 Map Nom de la méthode Description addCompteToMap Permet de rajouter une instance de la classe Compte dans une collection de type Map. findCompte Permet de rechercher une instance de la classe Compte dans une collection de type Map. deleteCompte Permet de supprimer une instance de la classe Compte dans une collection de type Map. emptyMap Permet de vider complètement une collection de type Map. sortMap Permet de trier une collection de type Map. ✅ À faire Coder les méthodes précédentes. Utiliser JUnit pour tester toutes les méthodes.",
    "description": "Étude de cas 1 Étude de cas Soit les classes suivantes avec leurs attributs successives : Classe Compagnie assurance :\nnuméro de la compagnie (unique), nom de compagnie, liste assurances : une collection d’assurances de type List. Classe Assurance : code d’assurance (unique), nom de l’assurance, prix de l’assurance, type d’assurance (Habitation, Auto ou Vie). Écrire en Java un programme qui permet la gestion de la compagnie d’assurance. Dans ce programme vous devez coder les méthodes suivantes: Afficher le chiffre d’affaires total de la compagnie (somme totale des assurances). Afficher l’inventaire (la liste des assurances) de la compagnie triée en ordre décroissant de prix d’assurance (du plus grand vers le plus petit). Convertir la liste lue en une collection de type Map (Integer, Assurance). Trier la Map par clé (numéro d’assurance). Parcourir la liste des assurances et modifier les prix des assurances comme suit : Augmenter le prix de l’assurance habitation de 10% Diminuer le prix d’assurance auto de 8% Diviser le prix de l’assurance vie par : 3 si le code d’assurance est impair. 4 si le code d’assurance est pair. Étude de cas 2 La classe Compte possède les attributs suivants :",
    "tags": [],
    "title": "📝 Exercices : Collections en Java",
    "uri": "/420-311/sdd/exercicessdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Complexité algorithmique",
    "content": "Qu’est-ce que la complexité algorithmique ? La complexité algorithmique désigne en informatique la quantité de ressources qu’un algorithme consomme lors de son exécution (On utilise Grand O pour décrire la performance d’une algorithme). Elle se décline en deux dimensions principales :\nLa complexité temporelle, qui mesure le temps d’exécution. La complexité spatiale, qui évalue la mémoire supplémentaire requise en dehors des données d’entrée. Ces deux aspects sont indépendants : un algorithme peut être très rapide mais consommer beaucoup de mémoire, ou inversement.\nPour bien évaluer un algorithme, il faut examiner son comportement dans différents contextes :\nle meilleur cas, le pire cas (souvent privilégié pour anticiper les situations extrêmes), et le cas moyen, qui reflète son usage habituel. Comparer la complexité de plusieurs algorithmes résolvant le même problème permet ainsi de choisir la solution la plus adaptée en fonction des contraintes de performance.\nComment et pourquoi mesurer la complexité ? Pour mesurer la complexité d’un algorithme, on utilise la notation Big O, écrite sous la forme O(f(n)). Elle exprime la croissance du temps ou de la mémoire nécessaires en fonction de la taille de l’entrée, généralement notée n.\nLe but de cette notation est de mettre en évidence le comportement asymptotique : comment l’algorithme évolue lorsque n devient très grand. On ignore donc les détails secondaires (constantes et termes mineurs) pour ne retenir que le terme dominant. Par exemple, une complexité exacte de 3n² + 5n + 7 se résume en O(n²), puisque n² domine pour de grandes valeurs de n.\nUn programme qui fonctionne n’est pas forcément efficace.\nExemple concret :\nRechercher un mot dans un dictionnaire papier (O(log n)). Rechercher une photo dans une pile désordonnée (O(n)). Plus les données sont grosses, plus le choix de l’algorithme est critique.\nNotation Big-O (pire cas) La notation Big-O décrit comment le temps d’exécution évolue en fonction de la taille de l’entrée (n).\nComplexité Exemple Interprétation O(1) Accès à un tableau par index Constant O(log n) Recherche binaire Logarithmique : croissance lente O(n) Parcours d’une liste Linéaire O(n log n) Tri rapide/merge sort Plus rapide que O(n²) O(n²) Doubles boucles imbriquées Quadratique : explose vite O(2^n) Problèmes combinatoires Exponentielle : impraticable 💡 Règle d’or :\nPour n petit, toutes les méthodes semblent rapides. Pour n grand, seules les bonnes structures/algorithmes tiennent la route. Exemples en Java 🔹 O(1) – Affichage simple public static void affiche(int[] tab) { // O(1) System.out.println(tab[0]); }\rAussi :\npublic static void affiche(int[] tab) { // O(2) qui sera simplifée à O(1) System.out.println(tab[0]); System.out.println(tab[1]); }\r🔹 O(n) – Boucle (itération sur tous les élements) public static void afficheTableau(int[] tab) { // O(n) for (int num : tab) { System.out.println(num); } }\rMême chose pour les boucles for, while et do while\n🔹 O(n ^ 2) – Boucle inbriquée public static void afficheTableau2D(int[] tab) { // O(n ^ 2) for (int num1 : tab) { for (int num2 : tab) { System.out.println(num1 * num2); } } }\r🔹 O(log n) – Recherche binaire ⚠️ Nécessite un tableau trié.\npublic static boolean rechercheBinaire(int[] tab, int val) { int g = 0, d = tab.length - 1; while (g \u003c= d) { int m = (g + d) / 2; if (tab[m] == val) return true; if (tab[m] \u003c val) g = m + 1; else d = m - 1; } return false; }\rSi nous cherchant dans un tableau d’un million d’éléments, 19 comparaisons seront suffusantes pour trouver l’élément recherché.\n🔹 Comparaison avec des exemples import java.util.*; public class Bench { public static void main(String[] args) { int n = 1_000_000; int[] tab = new int[n]; for (int i = 0; i \u003c n; i++) tab[i] = i; int cible = n - 1; // Recherche linéaire long t1 = System.nanoTime(); rechercheLineaire(tab, cible); long t2 = System.nanoTime(); System.out.println(\"Lineaire : \" + (t2 - t1) / 1_000_000.0 + \" ms\"); // Recherche binaire long t3 = System.nanoTime(); rechercheBinaire(tab, cible); long t4 = System.nanoTime(); System.out.println(\"Binaire : \" + (t4 - t3) / 1_000_000.0 + \" ms\"); } public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) if (x == val) return true; return false; } public static boolean rechercheBinaire(int[] tab, int val) { int g = 0, d = tab.length - 1; while (g \u003c= d) { int m = (g + d) / 2; if (tab[m] == val) return true; if (tab[m] \u003c val) g = m + 1; else d = m - 1; } return false; } }\rOn peut dire que :\nUn algorithme linéaire, qui met une seconde à traiter un tableau à 100 éléments, mettra 100 secondes à traiter un tableau à 10 000 éléments. Un algorithme quadratique qui met également une seconde à traiter le cas d’un tableau à 100 éléments mettra 10 000 secondes (soit près de trois heures) à traiter le cas du tableau à 10 000 éléments. Un algorithme en O(2n) qui mettrait aussi une seconde avec 100 éléments qui mettrait 2100 secondes à traiter ne serait-ce que 200 éléments, soit environ 4.1022 années (4000 milliards de milliards d’années). Analyse de boucles Boucle simple for (int i=0; i\u003cn; i++) → O(n). Boucles imbriquées for i, for j → O(n²). Boucle divisant par 2 while (n \u003e 1) n/=2 → O(log n). Complexité spatiale (mémoire) La complexité spatiale (ou complexité mémoire) mesure la quantité de mémoire nécessaire pour exécuter un algorithme en fonction de la taille de l’entrée (n).\n💡 On ne parle pas seulement de la mémoire des données initiales, mais aussi :\nde la mémoire supplémentaire utilisée par l’algorithme (variables, structures temporaires, pile d’appels).\nO(1) : pile, file, liste chaînée → mémoire proportionnelle aux données. O(n) : tableau de n éléments. O(n²) : matrice d’adjacence pour un graphe. Exemple 1 : Complexité spatiale O(1)\npublic static void afficheTableau(int[] tab) { // O(1) space for (int num : tab) { System.out.println(num); } }\rExemple 2 : Complexité spatiale O(n)\npublic static void afficheTableau(int[] tab) { // O(n) space (c'est l'espace qu'on a alloué à l'iterieur de cette méthode) int[] tabCopy = new int[tab.length]; for (int num : tab) { System.out.println(num); } }\rExemple 3 : Complexité spatiale O(n) (récursion)\npublic static int factoriel(int n) { // O(n) space if (n == 0) return 1; return n * factoriel(n - 1); }\rExercices Quelle est la complexité de :\nfor (int i=0; i\u003cn; i++) for (int j=0; j\u003cn; j++) System.out.println(i + \",\" + j);\rQuelle est la complexité de :\nfor (int i=0; i\u003cn; i*=2) System.out.println(i);\rQuelle est la complexité spatiale d’un tableau int[1000][1000] ?\nFiche synthèse Complexité temporelle → combien de temps ça prend.\nComplexité spatiale → combien de mémoire ça utilise.\nParfois, il faut choisir :\nMoins de temps mais plus de mémoire (ex. table de hachage).\nMoins de mémoire mais plus de temps (ex. recherche linéaire dans une liste).\nOn utilise la notion grand O (Big O) pour mesurer la complexité :\nO(1) : accès direct. O(log n) : recherche dichotomique, arbres équilibrés. O(n) : parcours d’une collection. O(n log n) : tris efficaces. O(n²) : algorithmes naïfs à doubles boucles. O(2^n) : problèmes combinatoires → à éviter.",
    "description": "Qu’est-ce que la complexité algorithmique ? La complexité algorithmique désigne en informatique la quantité de ressources qu’un algorithme consomme lors de son exécution (On utilise Grand O pour décrire la performance d’une algorithme). Elle se décline en deux dimensions principales :\nLa complexité temporelle, qui mesure le temps d’exécution. La complexité spatiale, qui évalue la mémoire supplémentaire requise en dehors des données d’entrée. Ces deux aspects sont indépendants : un algorithme peut être très rapide mais consommer beaucoup de mémoire, ou inversement.",
    "tags": [],
    "title": "Complexité algorithmique",
    "uri": "/420-311/complexalgo/complexalgo/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Ressources utiles",
    "content": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsqu’un contributeur a réalisé une modification qui est prête à l’envoyer, il pousse (push) celle-ci vers le dépôt. Le dépôt garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version décentralisé. Il y a 2 dépôts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez récupérer le code de votre repository (dépôt remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configuré la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de déposer les modifications sur une dépôt local. Il faut également être vigilant au niveau de la branche utilisé pour le commit. De plus, il est important de mettre souvent à jour la branche avant de procéder à un commit.\nLorsqu’on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour référer à la tâche en cours. Après cet identifiant, on peut y mettre une description. Par exemple:\n“PRJ-3428: Ajout de tests unitaires sur la méthode du service getClients”\nLorsqu’on relie l’identifiant et les commits, on peut alors connaître le travail effectué dans le code pour une tâche donnée dans le système de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandé de faire un git fetch / pull avant de procéder à celui-ci. À moins d’être seul dans ce repository et/ou la branche visée.\nGit Fetch, checkout, pull La commande git fetch permet de mettre à jour notre dépôt local en récupérant l’ état courant qui remote. La commande git checkout permet de les appliquer à la copie de travail (et donc de les voir).\nLa commande git pull fait les deux à la fois.\nPensez à vous mettre à jour avant chaque session de travail !\nC’est la première chose qu’un développeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaître l’état courant de vos copies locales (les modifications ont-elles été commitées, les fichiers ajoutés, les commit pushé).\nLes interface graphiques (dont intelliJ) vous l’indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectué. Ces commit peuvent être fort utili pour faire d’autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet d’appliquer les changements (fusionner) d’une autre branche à votre branche sélectionnée dans votre repository locale. Il y a souvent des conflits lors d’une fusion. Surtout si vous avez travailler dans un même fichier qu’un ou une de vos collègues.\nVous devez tenter de résoudre les conflits avec des outils en ligne de commande ou à l’aide d’un interface graphique. C’est une habilité à acquérir avec le temps. C’est parfois très complexe et si l’opération n’est pas effectée avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste à changer la base de votre branche d’un commit vers un autre, donnant l’illusion que vous avez créé votre branche à partir d’un commit différent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder l’état actuel de votre répertoire de travail. C’est possible de le faire avec git stash et de revenir à un répertoire de travail propre sans ces modifications. Vous pourrez ensuite récupérer ce travail en utilisant le nom que vous lui aurez donné. Vous pouvez en avoir plusieurs sauvegardés dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// Récupérer les changements précédents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalité si vous avez terminé.\nNe pas prendre les branches pour plusieurs fonctionnalités. Séparez vos tâches en plus petites et faites des commits plus souvent.\nRécupérer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre équipe vos intentions! Ne travaillez pas sur les mêmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillé sur une fonctionnalité ou un fix.\nAvant le jour de la mise en production. Vous devriez créer une branche à partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visée vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les éléments. Testez que votre branche fonctionne et qu’elle est bien compilée. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront déjà été résolus! Bingo.\nGitflow Pour maintenir une certain cohésion en entreprise, un modèle de branche a été proposé. Il implique de séparer les branches de développement et les branches primaires qui sont déployés dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRéférence Richard E. Silverman (2013), Git Pocket Guide, O’Reilly\nAlice Jacquot, Introduction à Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction à Git Git est un logiciel de contrôle de version. Il permet de gérer des fichiers et leur évolution dans le temps.\nIl permet de retracer l’origine de chaque modification, de rétablir des versions précédentes et permet l’intégration de modifications effectuées en parallèle.\nConcept Le principe d’un gestionnaire de version est qu’il gère un document comme “une base” à laquelle est ajouté une suite de modifications.\nIl y a un dépôt commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-311/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Objectifs généraux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de données.\nÉvaluer et comparer la complexité algorithmique des opérations (temps et mémoire).\nUtiliser des fils d’exécution (threads) pour exécuter plusieurs tâches en parallèle.\nDévelopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi étudier les structures de données ? Parce qu’elles sont au cœur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de données.\nParce qu’elles permettent de réduire le temps d’exécution et économiser de la mémoire.\nParce qu’elles développent la capacité à choisir la bonne approche selon un problème donné.\nParce qu’elles forment une base solide pour les cours ultérieurs et pour travailler dans des projets d’envergure.\nCitation classique : « Un bon algorithme mal implanté dans une mauvaise structure de données sera inefficace. Une bonne structure de données peut transformer un problème complexe en une solution élégante. »\n🌼 Notion de structure de données Le principe de base d’une structure de données, c’est de stocker des éléments auxquels le programmeur veut pouvoir accéder plus tard. On appelle les différentes utilisations possibles de la structure de données des opérations.\n🌼 Les structures de données en Java Le langage Java a élargi et harmonisé la bibliothèque de classes utilitaires (java.util).\nOn y trouve désormais des classes permettant de manipuler les principales structures de données, c’est-à-dire les vecteurs dynamiques, les ensembles, les listes chaînées, les queues et les tables associatives.\nNous commencerons par examiner les concepts communs qu’elles (structures de données) exploitent ainsi : généricité, itérateur, ordonnancement et relation d’ordre.\nNous verrons également quelles sont les opérations qui leur sont communes : ajout ou suppression d’éléments, construction à partir des éléments d’une autre collection…\nNous étudierons ensuite en détail chacune de ces structures, à savoir :\n🗝 Les listes, implémentées par la classe LinkedList;\r🗝 Les vecteurs dynamiques, implémentés par les classes ArrayList et Vector;\r🗝 Les ensembles, implémentés par les classes HashSet et TreeSet;\r🗝 Les queues avec priorité, implémentées par la classe PriorityQueue (introduite par le JDK 5.0) ;\r🗝 Les queues à double entrée, implémentées par la classe ArrayDeque (introduite par Java6).",
    "description": "Objectifs généraux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de données.\nÉvaluer et comparer la complexité algorithmique des opérations (temps et mémoire).\nUtiliser des fils d’exécution (threads) pour exécuter plusieurs tâches en parallèle.\nDévelopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi étudier les structures de données ? Parce qu’elles sont au cœur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de données.",
    "tags": [],
    "title": "Structures de donnée",
    "uri": "/420-311/index.html"
  },
  {
    "breadcrumb": "Structures de donnée \u003e Complexité algorithmique",
    "content": "🔹 Exercice 1 : for (int i = 0; i \u003c n; i++) { System.out.println(i); }\r👉 Quelle est la complexité temporelle en fonction de n ?\n🔹 Exercice 2 while (n \u003e 1) { n = n / 2; }\r👉 Quelle est la complexité temporelle ?\n🔹 Exercice 3 public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) { if (x == val) return true; } return false; }\r👉 Quelle est la complexité temporelle dans le pire cas ?\n🔹Exercice 4 public static void insertionSort(int[] tab) { for (int i = 1; i \u003c tab.length; i++) { int cle = tab[i]; int j = i - 1; while (j \u003e= 0 \u0026\u0026 tab[j] \u003e cle) { tab[j+1] = tab[j]; j--; } tab[j+1] = cle; } }\r👉 Quelle est la complexité dans le meilleur cas et dans le pire cas ?\n🔹Exercice 5 Classez les algorithmes suivants du plus rapide au plus lent quand n devient très grand :\nO(n²) O(n log n) O(n) O(log n) 🔹Exercice 6 Vous avez ce code :\nfor (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j *= 2) { System.out.println(i + \",\" + j); } }\r👉 Quelle est la complexité de cet algorithme ? Expliquez.\n🔹Exercice 7 public static int somme(int[] tab) { int total = 0; for (int n : tab) { total += n; } return total; }\r👉 Question : Quelle est la complexité spatiale de cette méthode ? Justifiez votre réponse.\n🔹Exercice 8 public static int[] doubleTableau(int[] tab) { int[] resultat = new int[tab.length]; for (int i = 0; i \u003c tab.length; i++) { resultat[i] = tab[i] * 2; } return resultat; }\r👉 Question : Combien de mémoire supplémentaire est utilisée par rapport à la taille de l’entrée n ?\n🔹Exercice 9 int[][] matrice = new int[n][n];\r👉 Question : Quelle est la complexité spatiale de cette structure ?\n🔹Exercice 10 On veut calculer la suite de Fibonacci :\nVersion récursive simple :\npublic static int fib(int n) { if (n \u003c= 1) return n; return fib(n - 1) + fib(n - 2); }\rVersion avec mémoïsation :\npublic static int fibMemo(int n, int[] memo) { if (memo[n] != 0) return memo[n]; if (n \u003c= 1) return n; memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo); return memo[n]; }\r👉 Questions :\nQuelle est la complexité spatiale des deux versions ? Pourquoi la version avec mémoïsation consomme plus de mémoire mais gagne en temps ? 🔹Exercice 11 : Écrivez un programme qui :\nCréez un tableau de 1 million d’entiers. Créez une LinkedList et un ArrayList chacun contenant 1 million d’entiers. Comparez la mémoire consommée (avec Runtime.getRuntime().totalMemory() - freeMemory()) pour chaque structure. Observer concrètement l’impact de la structure choisie sur la mémoire. Que remarquez vous ?",
    "description": "🔹 Exercice 1 : for (int i = 0; i \u003c n; i++) { System.out.println(i); }\r👉 Quelle est la complexité temporelle en fonction de n ?\n🔹 Exercice 2 while (n \u003e 1) { n = n / 2; }\r👉 Quelle est la complexité temporelle ?\n🔹 Exercice 3 public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) { if (x == val) return true; } return false; }\r👉 Quelle est la complexité temporelle dans le pire cas ?",
    "tags": [],
    "title": "📝 Exercices sur complexité algorithmique",
    "uri": "/420-311/complexalgo/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-311/categories/index.html"
  },
  {
    "breadcrumb": "Structures de donnée",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-311/tags/index.html"
  }
]
