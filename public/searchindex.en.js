var relearn_searchindex = [
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Dans ce module nous ferons une courte rÃ©vision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte rÃ©vision des notions essentielles au cours.",
    "tags": [],
    "title": "PrÃ©alables",
    "uri": "/420-311/intro/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Dans ce chapitre nous allons dÃ©couvrir quelques structures de donnÃ©es et apprendre Ã  choisir la bonne structure selon le problÃ¨me.\nâ“‚ï¸ Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util).\nâ“‚ï¸ On y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nâ“‚ï¸ Nous commencerons par examiner les concepts communs quâ€™elles (structures de donnÃ©es) exploitent ainsi : gÃ©nÃ©ricitÃ©, itÃ©rateur, ordonnancement et relation dâ€™ordre.\nâ“‚ï¸ Nous verrons Ã©galement quelles sont les opÃ©rations qui leur sont communes : ajout ou suppression dâ€™Ã©lÃ©ments, construction Ã  partir des Ã©lÃ©ments dâ€™une autre collectionâ€¦\nâ“‚ï¸ Nous Ã©tudierons ensuite en dÃ©tail chacune de ces structures, Ã  savoir :\nğŸŒ± Les listes, implÃ©mentÃ©es par la classe LinkedList;\rğŸŒ± Les vecteurs dynamiques, implÃ©mentÃ©s par les classes ArrayList et Vector;\rğŸŒ± Les ensembles, implÃ©mentÃ©s par les classes HashSet et TreeSet;\rğŸŒ± Les queues avec prioritÃ©, implÃ©mentÃ©es par la classe PriorityQueue (introduite par le JDK 5.0) ;\rğŸŒ± Les queues Ã  double entrÃ©e, implÃ©mentÃ©es par la classe ArrayDeque (introduite par Java6).",
    "description": "Dans ce chapitre nous allons dÃ©couvrir quelques structures de donnÃ©es et apprendre Ã  choisir la bonne structure selon le problÃ¨me.\nâ“‚ï¸ Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util).\nâ“‚ï¸ On y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nâ“‚ï¸ Nous commencerons par examiner les concepts communs quâ€™elles (structures de donnÃ©es) exploitent ainsi : gÃ©nÃ©ricitÃ©, itÃ©rateur, ordonnancement et relation dâ€™ordre.",
    "tags": [],
    "title": "Structure de donnÃ©es",
    "uri": "/420-311/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Dans ce chapitre, nous allons voir ce que signifie la notation Big-O et analyser la complexitÃ© dâ€™un algorithme simple, ainsi que comparer plusieurs approches pour rÃ©soudre un mÃªme problÃ¨me. En fin, nous allons voir comment mesurer expÃ©rimentalement la performance dâ€™un programme en Java.",
    "description": "Dans ce chapitre, nous allons voir ce que signifie la notation Big-O et analyser la complexitÃ© dâ€™un algorithme simple, ainsi que comparer plusieurs approches pour rÃ©soudre un mÃªme problÃ¨me. En fin, nous allons voir comment mesurer expÃ©rimentalement la performance dâ€™un programme en Java.",
    "tags": [],
    "title": "ComplexitÃ© algorithmique",
    "uri": "/420-311/complexalgo/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Les entrÃ©es/sorties (IO) en Java regroupent lâ€™ensemble des mÃ©canismes permettant de lire et dâ€™Ã©crire des donnÃ©es, que ce soit dans un fichier, sur la console, Ã  travers le rÃ©seau ou en mÃ©moire. Le langage propose une riche bibliothÃ¨que (java.io et java.nio) avec des classes spÃ©cialisÃ©es pour traiter les flux de caractÃ¨res (texte) et les flux binaires (octets). Comprendre ces outils est essentiel pour manipuler efficacement les donnÃ©es.",
    "description": "Les entrÃ©es/sorties (IO) en Java regroupent lâ€™ensemble des mÃ©canismes permettant de lire et dâ€™Ã©crire des donnÃ©es, que ce soit dans un fichier, sur la console, Ã  travers le rÃ©seau ou en mÃ©moire. Le langage propose une riche bibliothÃ¨que (java.io et java.nio) avec des classes spÃ©cialisÃ©es pour traiter les flux de caractÃ¨res (texte) et les flux binaires (octets). Comprendre ces outils est essentiel pour manipuler efficacement les donnÃ©es.",
    "tags": [],
    "title": "IO",
    "uri": "/420-311/io/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "La gÃ©nÃ©ricitÃ© est un mÃ©canisme qui permet dâ€™Ã©crire du code flexible et rÃ©utilisable en dÃ©finissant des classes, interfaces ou mÃ©thodes paramÃ©trÃ©es par des types. Dans ce chapitre nous allons voir comment la gÃ©nÃ©ricitÃ© renforce la sÃ©curitÃ© de typage et son utilisation avec les collections (List, Map, Set).",
    "description": "La gÃ©nÃ©ricitÃ© est un mÃ©canisme qui permet dâ€™Ã©crire du code flexible et rÃ©utilisable en dÃ©finissant des classes, interfaces ou mÃ©thodes paramÃ©trÃ©es par des types. Dans ce chapitre nous allons voir comment la gÃ©nÃ©ricitÃ© renforce la sÃ©curitÃ© de typage et son utilisation avec les collections (List, Map, Set).",
    "tags": [],
    "title": "Genericity",
    "uri": "/420-311/genericity/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Les tests unitaires sont des tests permettant de tester de toutes petites unitÃ©s dâ€™un logiciel. Ils sont notamment dÃ©diÃ©s Ã  des tests de mÃ©thodes.\nLes tests unitaires doivent Ãªtre lancÃ©s aussi souvent que possibles, notamment Ã  chaque modification du code source ; ils faut donc quâ€™ils soient exÃ©cutables automatiquement. Ils sont donc Ã©crits dans le mÃªme langage de programmation que le logiciel.\nJUnit 5 est un framework de test unitaire populaire en Java qui permet dâ€™Ã©crire et dâ€™exÃ©cuter des tests automatisÃ©s pour vÃ©rifier des unitÃ©s de code individuelles comme des mÃ©thodes ou des classes. Il est compatible avec la plateforme Java 8 et versions ultÃ©rieures et se distingue par sa nouvelle architecture modulaire, son support des tests paramÃ©trÃ©s et dynamiques, ainsi que de nouvelles annotations comme @Timeout pour fixer une durÃ©e dâ€™exÃ©cution maximale.",
    "description": "Les tests unitaires sont des tests permettant de tester de toutes petites unitÃ©s dâ€™un logiciel. Ils sont notamment dÃ©diÃ©s Ã  des tests de mÃ©thodes.\nLes tests unitaires doivent Ãªtre lancÃ©s aussi souvent que possibles, notamment Ã  chaque modification du code source ; ils faut donc quâ€™ils soient exÃ©cutables automatiquement. Ils sont donc Ã©crits dans le mÃªme langage de programmation que le logiciel.\nJUnit 5 est un framework de test unitaire populaire en Java qui permet dâ€™Ã©crire et dâ€™exÃ©cuter des tests automatisÃ©s pour vÃ©rifier des unitÃ©s de code individuelles comme des mÃ©thodes ou des classes. Il est compatible avec la plateforme Java 8 et versions ultÃ©rieures et se distingue par sa nouvelle architecture modulaire, son support des tests paramÃ©trÃ©s et dynamiques, ainsi que de nouvelles annotations comme @Timeout pour fixer une durÃ©e dâ€™exÃ©cution maximale.",
    "tags": [],
    "title": "UnitTests",
    "uri": "/420-311/unittests/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Ã€ la fin de cette section, vous serez capable de :\nComprendre la diffÃ©rence entre recherche linÃ©aire et recherche binaire. Ã‰valuer la complexitÃ© temporelle de chaque approche. ImplÃ©menter les deux algorithmes en Java. Choisir lâ€™algorithme le plus adaptÃ© selon la situation (tableau triÃ© ou non triÃ©).",
    "description": "Ã€ la fin de cette section, vous serez capable de :\nComprendre la diffÃ©rence entre recherche linÃ©aire et recherche binaire. Ã‰valuer la complexitÃ© temporelle de chaque approche. ImplÃ©menter les deux algorithmes en Java. Choisir lâ€™algorithme le plus adaptÃ© selon la situation (tableau triÃ© ou non triÃ©).",
    "tags": [],
    "title": "Algorithmes de recherche et de tri",
    "uri": "/420-311/algosearchsort/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Dans ce chapitre nous allons dÃ©couvrir concepts fondamentaux de la programmation concurrente, notamment la notion de processus et de threads dans les systÃ¨mes informatiques. Il explique le multitÃ¢che et le multithread, dÃ©crivant comment les systÃ¨mes dâ€™exploitation simulent le parallÃ©lisme sur des machines monoprocesseurs ou lâ€™exÃ©cutent rÃ©ellement sur des architectures multicÅ“urs. Une partie importante est consacrÃ©e aux threads Java, y compris leur cycle de vie, les mÃ©thodes pour les crÃ©er et les gÃ©rer, ainsi que la maniÃ¨re dâ€™assurer la coordination des threads par lâ€™exclusion mutuelle, les verrous et les sÃ©maphores.",
    "description": "Dans ce chapitre nous allons dÃ©couvrir concepts fondamentaux de la programmation concurrente, notamment la notion de processus et de threads dans les systÃ¨mes informatiques. Il explique le multitÃ¢che et le multithread, dÃ©crivant comment les systÃ¨mes dâ€™exploitation simulent le parallÃ©lisme sur des machines monoprocesseurs ou lâ€™exÃ©cutent rÃ©ellement sur des architectures multicÅ“urs. Une partie importante est consacrÃ©e aux threads Java, y compris leur cycle de vie, les mÃ©thodes pour les crÃ©er et les gÃ©rer, ainsi que la maniÃ¨re dâ€™assurer la coordination des threads par lâ€™exclusion mutuelle, les verrous et les sÃ©maphores.",
    "tags": [],
    "title": "Threads",
    "uri": "/420-311/threads/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Rappel : Concepts de base Classe : ModÃ¨le dÃ©finissant les attributs (variables) et comportements (mÃ©thodes).\nObjet : Instance concrÃ¨te dâ€™une classe.\nEncapsulation : ProtÃ©ger les donnÃ©es via des modificateurs dâ€™accÃ¨s (private, public, protected) et exposer des mÃ©thodes dâ€™accÃ¨s (getters/setters).\nAbstraction : Masquer les dÃ©tails dâ€™implÃ©mentation et ne montrer que les fonctionnalitÃ©s essentielles (via classes abstraites et interfaces).\nHÃ©ritage : Une classe peut hÃ©riter des attributs et mÃ©thodes dâ€™une autre (mot-clÃ© extends).\nPolymorphisme :\nSurcharge (overloading) : mÃªme nom de mÃ©thode, signatures diffÃ©rentes. RedÃ©finition (overriding) : une sous-classe redÃ©finit le comportement dâ€™une mÃ©thode hÃ©ritÃ©e. Constructeur : MÃ©thode spÃ©ciale exÃ©cutÃ©e lors de la crÃ©ation dâ€™un objet (new).\nModificateurs dâ€™accÃ¨s Modificateur MÃªme classe MÃªme package Sous-classe Partout public âœ… âœ… âœ… âœ… protected âœ… âœ… âœ… âŒ (default) âœ… âœ… âŒ âŒ private âœ… âŒ âŒ âŒ Syntaxe essentielle DÃ©finir une classe public class Voiture { private String marque; private int annee; public Voiture(String marque, int annee) { this.marque = marque; this.annee = annee; } public void demarrer() { System.out.println(marque + \" dÃ©marre !\"); } }\rCrÃ©er un objet Voiture v1 = new Voiture(\"Toyota\", 2022); v1.demarrer();\rHÃ©ritage et polymorphisme class Animal { public void parler() { System.out.println(\"??\"); } } class Chien extends Animal { @Override public void parler() { System.out.println(\"Woof\"); } } Animal a = new Chien(); // polymorphisme a.parler(); // \"Woof\"\rAbstraction et interfaces abstract class Forme { abstract double aire(); } class Cercle extends Forme { private double r; Cercle(double r) { this.r = r; } @Override double aire() { return Math.PI * r * r; } } interface Volant { void voler(); } class Avion implements Volant { public void voler() { System.out.println(\"En vol âœˆï¸\"); } }\rClasses utiles Object : classe racine de toutes les classes Java. MÃ©thodes importantes : toString(), equals(), hashCode(), clone().\nfinal :\nfinal class : non-hÃ©ritÃ©e. final method : non-redÃ©finissable. final variable : constante. Gestion mÃ©moire Les objets sont crÃ©Ã©s sur le tas (heap) via new. Le garbage collector libÃ¨re automatiquement la mÃ©moire des objets non rÃ©fÃ©rencÃ©s. Bonnes pratiques Utiliser private pour protÃ©ger les donnÃ©es. Toujours redÃ©finir toString() pour reprÃ©senter un objet. Respecter la cohÃ©rence equals() / hashCode(). Favoriser la composition plutÃ´t que lâ€™hÃ©ritage trop profond. Documenter avec JavaDoc (/** â€¦ */). Exemple : package s01; class Etudiant { private String nom; private int age; public Etudiant(String nom, int age) { this.nom = nom; this.age = age; } public void afficherInfos() { System.out.println(\"Nom : \" + nom + \", Ã‚ge : \" + age); } } class EtudiantRegulier extends Etudiant { private String programme; public EtudiantRegulier(String nom, int age, String programme) { super(nom, age); this.programme = programme; } @Override public void afficherInfos() { super.afficherInfos(); System.out.println(\"Programme : \" + programme); } } public class RappelPOO { public static void main(String[] args) { EtudiantRegulier e = new EtudiantRegulier(\"Alice\", 20, \"Informatique\"); e.afficherInfos(); } }\rğŸ“˜ RÃ©sumÃ© de rÃ©vision â€“ POO ğŸ”¹ 1. Classes Une classe public est accessible depuis nâ€™importe quel package. Une classe abstract sert de modÃ¨le, ne peut pas Ãªtre instanciÃ©e et peut contenir des mÃ©thodes abstraites. Une classe final ne peut pas Ãªtre hÃ©ritÃ©e. Une classe private nâ€™est possible quâ€™en classe interne (nested class). Toute classe hÃ©rite implicitement de Object â†’ possÃ¨de donc les mÃ©thodes toString(), equals(), hashCode(), etc. ğŸ”¹ 2. Constructeurs Si aucune dÃ©claration â†’ le compilateur gÃ©nÃ¨re un constructeur par dÃ©faut (sans paramÃ¨tres). Un constructeur peut Ãªtre private (utilisÃ© dans le pattern Singleton ou classes utilitaires). ğŸ”¹ 3. MÃ©thodes Les mÃ©thodes peuvent Ãªtre surchargÃ©es (overloading) â†’ mÃªme nom, paramÃ¨tres diffÃ©rents. Les mÃ©thodes peuvent Ãªtre surdÃ©finies (overriding) â†’ mÃªme signature, dans une sous-classe. Une mÃ©thode final ne peut pas Ãªtre redÃ©finie dans une sous-classe. Une mÃ©thode abstract est dÃ©clarÃ©e sans corps et doit Ãªtre implÃ©mentÃ©e dans une sous-classe. abstract et final sont incompatibles (contradiction). ğŸ”¹ 4. Attributs Un attribut final est une constante : doit Ãªtre initialisÃ© une seule fois (dÃ©claration ou constructeur). ğŸ”¹ 5. Interfaces Une interface ne peut pas Ãªtre instanciÃ©e.\nUne interface nâ€™est pas un objet, câ€™est un contrat.\nUne interface nâ€™hÃ©rite pas dâ€™Object, mais les classes qui lâ€™implÃ©mentent hÃ©ritent dâ€™Object.\nUne interface peut hÃ©riter dâ€™une ou plusieurs autres interfaces avec extends.\nUne interface ne peut pas hÃ©riter dâ€™une classe.\nMÃ©thodes dans une interface :\nAvant Java 8 â†’ uniquement public abstract. Depuis Java 8 â†’ mÃ©thodes default et static avec implÃ©mentation. Depuis Java 9 â†’ mÃ©thodes private pour factoriser du code interne. ğŸ”¹ 6. Comparable vs Comparator Comparable : dÃ©finit lâ€™ordre naturel dâ€™une classe (mÃ©thode compareTo). Comparator : dÃ©finit un ordre externe, peut Ãªtre multiple et personnalisÃ© (mÃ©thode compare). ğŸ”¹ 7. Mots-clÃ©s spÃ©ciaux null â†’ valeur littÃ©rale spÃ©ciale, pas un mot-clÃ©. this â†’ rÃ©fÃ©rence Ã  lâ€™instance courante. super â†’ rÃ©fÃ©rence Ã  la classe parente. RÃ©sumÃ© Ã‰lÃ©ment Description Exemple Classe abstract Non instanciable, modÃ¨le pour hÃ©ritage abstract class Forme { abstract double aire(); } Classe final Ne peut pas Ãªtre hÃ©ritÃ©e final class Utilitaire {} MÃ©thode final Ne peut pas Ãªtre redÃ©finie public final void calcul() {} MÃ©thode abstract Sans corps, Ã  implÃ©menter abstract void afficher(); Attribut final Constante, valeur fixÃ©e une seule fois final double PI = 3.14; Interface Contrat, non instanciable interface Vehicule { void rouler(); } Comparable Ordre naturel, compareTo class Etudiant implements Comparable\u003cEtudiant\u003e Comparator Ordre externe, compare Comparator\u003cEtudiant\u003e parNom = ...;",
    "description": "Rappel : Concepts de base Classe : ModÃ¨le dÃ©finissant les attributs (variables) et comportements (mÃ©thodes).\nObjet : Instance concrÃ¨te dâ€™une classe.\nEncapsulation : ProtÃ©ger les donnÃ©es via des modificateurs dâ€™accÃ¨s (private, public, protected) et exposer des mÃ©thodes dâ€™accÃ¨s (getters/setters).\nAbstraction : Masquer les dÃ©tails dâ€™implÃ©mentation et ne montrer que les fonctionnalitÃ©s essentielles (via classes abstraites et interfaces).\nHÃ©ritage : Une classe peut hÃ©riter des attributs et mÃ©thodes dâ€™une autre (mot-clÃ© extends).",
    "tags": [],
    "title": "RÃ©vision",
    "uri": "/420-311/intro/revisionpoo/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Questions thÃ©oriques Question 1 : Quel est le rÃ©sultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le rÃ©sultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le rÃ©sultat du code suivant:\npublic class Question3 { public static void main(String[]args) { int val1 = 9; int val2 = 9; String str = \"9\"; System.out.println(val1 + val2 + str);\t} }\rQuestion 4 : Quel est le rÃ©sultat du code suivant:\npublic class Question4 { public static void main(String[]args) { try { int a, b; b = 0; a = 5 / b; System.out.print(\"A\"); } catch (Exception e) { System.out.print(\"B\"); } finally { System.out.print(\"C\"); }\t} }\rQuestion 5 : Quel est le rÃ©sultat du code suivant:\npublic class Question5 { public static void main(String[]args) { String obj = \"Bonjour\"; String obj1 = \"Bonsoir\"; String obj2 = \"Bonjour\"; System.out.println(obj.equals(obj1) + \" \" + obj.equals(obj2)); } }\rQuestion 6 : Quel est le rÃ©sultat du code suivant:\npublic class ClasseA { public int i; public int j; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.j = 3; System.out.println(i + \" \" + j); } } public class Question6 { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 7 : Quel est le rÃ©sultat du code suivant:\npublic class ClasseA { public int i; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.i = j + 1; System.out.println ( j + \" \" + i); } } public class Main { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 8 : Quel est le rÃ©sultat du code suivant:\npublic class Question8{ public static void main(String[] args) { String s = \"Hello World\"; int A = s.indexOf('o'); int B = s.lastIndexOf('l'); System.out.println(A + \" \" + B); } }\rQuestion 9 : Quel est le rÃ©sultat du code suivant:\npublic class Question9{ public static void main(String[] args) { char ch; ch = \"hello\".charAt(1); System.out.println(ch); } }\rQuestion 10 : Quel est le rÃ©sultat du code suivant:\npublic class Question10{ public static void main(String[] args) { String chars[] = {\"a\", \"b\", \"c\", \"a\", \"c\"}; for (int i = 0; i \u003c chars.length; ++i) for (int j = i + 1; j \u003c chars.length; ++j) if(chars[i].compareTo(chars[j]) == 0) System.out.print(chars[j]); } }\rQuestion 11 : Quel est le rÃ©sultat du code suivant:\npublic class Question11{ public static void main(String[] args) { int a1[] = new int[10]; int a2[] = { 1, 2, 3, 4, 5 }; System.out.println(a1.length + \" \" + a2.length); } }\rQuestion 12 : Quel est le rÃ©sultat du code suivant:\npublic class Question12{ public static void main(String[] args) { int arr[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i \u003c arr.length - 2; ++i) System.out.print(arr[i] + \" \"); } }\rQuestion 13 : Quel est le rÃ©sultat du code suivant:\npublic class Question13{ public static int param1; public static int param2; public void add(int a, int b) { param1 = a + b; param2 = param1 + b; } public static void main(String args[]) { Question13 obj1 = new Question13(); Question13 obj2 = new Question13(); int a = 2; obj1.add(a, a + 1); obj2.add(5, a); System.out.println(obj1.param1 + \" \" + obj2.param2); } }\rQuestion 14 : Quel est le rÃ©sultat du code suivant:\nimport java.util.Arrays; public class Question14{ public static void main(String[] args) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 15 : Quel est le rÃ©sultat du code suivant:\npublic class Question15{ public static int param1; public void increment() { param1++; } public static void main(String args[]) { Question15 obj1 = new Question15(); Question15 obj2 = new Question15(); obj1.param1 = 0; obj1.increment(); obj2.increment(); System.out.println(obj1.param1 + \" \" + obj2.param1); } }\rQuestion 16 : Quel est le rÃ©sultat du code suivant:\nimport java.util.Arrays; public class Question16 { public static void main(String args[]) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 17 : Quel est le rÃ©sultat du code suivant:\npublic class Question17 { public static void main(String[] args) { ClasseB classeB = new ClasseB(); System.out.println(\"Valeur = \" + classeB.calculer(3, 6)); } } class ClassA { final public int calculer(int a, int b) { return 0; } } class ClasseB extends ClasseA { public int calculer(int a, int b) { return 1; } }\rQuestion 18 : Quel est le rÃ©sultat du code suivant:\npublic class Question18 { public static void main (String args[]) { int param1, param2= 1; param1= 10; if (param1!= 10 \u0026\u0026 param1/ 0 == 0) { System.out.println(param2); } else { System.out.println(++param2); } } }\rQuestion 19 : Quel est le rÃ©sultat du code suivant:\npublic class Question19 { public static int param1; public static int param2; public void add(int val1, int val2) { param1 = val1 + val2; param2 = param1 + val2; } public static void main(String[] args) { Question19 instance1 = new Question19 (); Question19 instance2 = new Question19 (); Question19 instance3 = new Question19 (); int abc = 2;\tinstance1.add(abc, abc-1); instance3.add(6, 6/abc); instance2.add(5, abc/2); System.out.println(instance1.param1); System.out.println(instance2.param2); } }\rQuestion 20 : Quel est le rÃ©sultat du code suivant:\nimport java.util.Arrays; public class Question20 { public static void main(String args[]) { int array[] = new int [5]; for (int i = 5; i \u003e 0; i--) { array[5 - i] = i; } Arrays.sort(array); System.out.print(Arrays.toString(array)); } }\rQuestion 21 : Quel est le rÃ©sultat du code suivant:\npublic class Question21 { public static void main(String [] args) { Question21 instance = new Question21(); instance.myMethod(); } public void myMethod(){ long [] tab1 = {6,8,9}; long []tab2 = affectation(tab1); System.out.print(tab1[0] + tab1[1] + tab1[2] + \" \"); System.out.println(tab2[0] + tab2[1] + tab2[2]); } public long[] affectation(long[] tab3){ tab3[1] = 7; return tab3; } }\rExercices pratiques Exercice 1 : Soit la String suivante: A-b-C-d-E-f-1234-***///-\u003e , Ã©crire un programme en Java qui:\nğŸ‘ convertit chaque caractÃ¨re alphabÃ©tique majuscule de la String en un caractÃ¨re minuscule; ğŸ‘ Convertis chaque caractÃ¨re alphabÃ©tique minuscule de la String en un caractÃ¨re majuscule; ğŸ‘ Supprime tous les caractÃ¨res spÃ©ciaux de la String; Exercice 2 : Soit le tableau suivant: String [] days = { \"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\", \"Dimanche\"}; Ã‰crire un programme en Java qui:\nğŸ‘ choisi alÃ©atoirement une journÃ©e du tableau et lâ€™affiche; ğŸ‘ Tri le tableau; Exercice 3 : Soit le code Java suivant:\nString str1 = \"Bonjour\"; String str2 = new String (\"Bonjour\"); str1 == str2; //3 str1.equals(str2); //4\rExpliquez la diffÃ©rence entre les 02 lignes de code (ligne 3 et ligne 4)?\nExercice 4 : Soit la classe Compte bancaire avec les attributs suivants:\nidCpte (numÃ©ro unique: donc 2 comptes ne peuvent pas avoir le mÃªme ID); firstName; lastName; solde; En utilisant les collections Java (List, Set et Map) et en vous utilisant lâ€™API Java, vous devez coder les mÃ©thodes suivantes:\nğŸ‘ addCompteToCollection (List | Set | Map)\rğŸ‘ serachCompteInCollection (List | Set | Map)\rğŸ‘ sortCollection (List | Set | Map)\rğŸ‘ removeCompteFromCollection (List | Set | Map)\rğŸ‘ emptyCollectionComptes (List | Set | Map)\rExercice 5 : Ã‰crire un code Java qui convertit un tableau dâ€™entiers (tableau Ã  crochets) en une collection de type List.\nÃ‰crire un code Java qui convertit une collection de type List en un tableau Ã  crochets.\nÃ‰crire un code Java qui convertit une collection de type List en une collection de Type Set.\nÃ‰crire un code Java qui convertit une collection de type Set en une collection de Type List.\nÃ‰crire un code Java qui convertit une collection de type List en une collection de Type Map.\nÃ‰crire un code Java qui convertit une collection de type Map en une collection de Type List.\nExercice 6 : Soit le tableau de conversion des devises suivant :\nDe Vers Taux Dollar canadien (CAD) Euro 1 CAD = 0.74 EURO Dollar canadien (CAD) Dollar amÃ©ricain (USD) 1 CAD = 0.69 USD Euro Dollar canadien (CAD) 1 EURO = 1.45 CAD Dollar amÃ©ricain (USD) Dollar canadien (CAD) 1 USD = 1.36 CAD Ã‰crire un programme Java qui demande Ã  un utilisateur de choisir un type conversion et saisir un montant Ã  convertir. Le programme traitera la conversion et affichera le montant converti.\nCondition:\nLe programme nâ€™acceptera que les montants entre 90 et 6500, cela dans chaque sorte de devises. Le programme ne doit pas sâ€™arrÃªter tant que lâ€™utilisateur nâ€™aura pas choisi de quitter. Exercice 7 : Soit le systÃ¨me de notation universitaire :\nNote numÃ©rique Note littÃ©rale 90 et + A De 80 Ã  89 B De 70 Ã  79 C De 60 Ã  69 D De 50 Ã  59 E \u003c 50 F Ã‰crire un programme Java qui demande Ã  un utilisateur de saisir 4 notes numÃ©riques. Ensuite le programme calculera la moyenne et affichera la note littÃ©rale correspondante.\nCondition:\nLe programme nâ€™acceptera que les notes entre 0 et 100.\nExemple\nLe programme demande les notes Ã  lâ€™utilisateur : Veuillez saisir vos notes Svp : Lâ€™utilisateur saisit les notes suivantes : 59, 72.5, 83.73, 45.5\nLe programme calculera la moyenne et affichera :\nVotre moyenne numÃ©rique est : 65,18 ce qui donnera en littÃ©rale la note de D.\nExercice 8 : Soit la liste des villes suivantes : Ottawa, Paris, Berne, Washington, Berlin, Madrid, Mexico.\nğŸŒ¼ Ã‰crire un programme Java qui gÃ©nÃ¨re alÃ©atoirement 2 villes parmi la liste des villes et demandera Ã  un utilisateur de deviner les 2 villes au bout de 3 tentatives.\nSi lâ€™utilisateur arrive Ã  deviner les 2 villes alÃ©atoires, le programme affichera un message et quittera. Si lâ€™utilisateur nâ€™arrive pas Ã  deviner les 2 villes alÃ©atoires au bout de 3 tentatives, le programme affichera le rÃ©sultat et quittera. Clarification\nModÃ¨le de message en cas de succÃ¨s de devinette Bravo! Vous avez devinÃ© les 2 villes : Ottawa et Paris. ModÃ¨le de message en cas dâ€™Ã©chec de devinette Oups! En 3 tentatives, vous nâ€™Ãªtes pas arrivÃ© Ã  deviner les 2 villes : Ottawa et Paris. Exercice 9 : On souhaite gÃ©rer une liste de prÃ©noms dâ€™Ã©tudiants dans un cours. RÃ©alise un programme Java qui :\nCrÃ©e une liste de type ArrayList. Ajoute les prÃ©noms suivants : â€œAliceâ€, â€œBobâ€, â€œCharlieâ€, â€œDianeâ€. Affiche la taille de la liste et son contenu. Demande Ã  lâ€™utilisateur dâ€™entrer un prÃ©nom, puis : VÃ©rifie sâ€™il est prÃ©sent dans la liste (affiche un message appropriÃ©). Si prÃ©sent, affiche sa position dans la liste. Supprime un prÃ©nom donnÃ© par lâ€™utilisateur et rÃ©affiche la liste. Trie la liste par ordre alphabÃ©tique et affiche le rÃ©sultat. Exercice 10 : Soit le diagramme de classes suivant :\nCrÃ©er les classes Java correspondant aux classes du diagramme. Il vous faudra respecter les attributs et les relations entre les diffÃ©rentes classes. Ã‰crire une mÃ©thode de service qui permet de calculer le prix rÃ©el dâ€™un produit suivant la rÃ¨gle suivante : a.\tSi le produit est biologique, Â« indiceBio Â» et le produit appartiennent Ã  un fournisseur habitant la province du Â« QuÃ©bec Â», alors le prix rÃ©el est :\ni.\tPrix rÃ©el = prix du produit + prix du produit*tps + prix du produit * tvq. b.\tSi le produit est biologique, Â« indiceBio Â» et le produit appartiennent Ã  un fournisseur habitant le Canada (sauf la province du QuÃ©bec) alors le prix rÃ©el est :\ni.\tPrix rÃ©el = prix du produit + prix du produit*tps. c.\tSi le produit est biologique Â« indiceBio Â» et le produit appartient Ã  un fournisseur habitant les USA alors le prix rÃ©el est :\ni.\tPrix rÃ©el = prix du produit + prix du produit*usTax. Ã‰crire une mÃ©thode de service qui permet de calculer le total prix (la somme totale) des produits de tous les fournisseurs amÃ©ricains. Exercice 11 : Soit la String suivante: String chaineDepart = â€œ$_%4*1;-0er2bo%t?c(o(id\u003eer7dn1evâ€ Ã©crire le programme qui traite lâ€™algorithme suivant:\nLire la String Â« chaineDepart Â» Parcourir la String et appliquer le traitement suivant: Mettre les 04 premiers caractÃ¨res dans une Stack (appelÃ©e stack01); Mettre les 04 caractÃ¨res suivants dans une liste (appelÃ©e liste01); Mettre les 04 caractÃ¨res suivants dans un vecteur (appelÃ©e vecteur01); Mettre le reste de la chaine dans une Queue (appelÃ©e queue01); DÃ©clarer un String vide appelÃ© resultat01; DÃ©clarer un String vide appelÃ© resultat02; DÃ©pilez le premier Ã©lÃ©ment de la stack01 et ajoutez-le Ã  la String resultat01; Ajouter Ã  la String resultat01, le 2e qui se trouve dans liste01; Parcourez le vecteur01, si lâ€™Ã©lÃ©ment est un chiffre, mettez-le dans la String resultat01, sinon mettez-le dans la String resultat02; DÃ©filer la queue01, mettez seulement les lettres alphabÃ©tiques dans la String resultat02. Inversez les 02 Strings; DÃ©clarer un String vide appelÃ© resultatFinal; Copiez les 08 premiers caractÃ¨res de la String resultat02 dans la String resultatFinal; Ajoutez un espace Ã  la String resultatFinal; Copiez les 02 premiers Ã©lÃ©ments de la String resultat01 dans la String resultatFinal; Ajoutez un espace Ã  la String resultatFinal; Copiez le reste des caractÃ¨res de la String resultat02 dans la String resultatFinal; Ajoutez un espace Ã  la String resultatFinal; Copiez le reste des caractÃ¨res de la String resultat01 dans la String resultatFinal; Afficher le rÃ©sultat;",
    "description": "Questions thÃ©oriques Question 1 : Quel est le rÃ©sultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le rÃ©sultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le rÃ©sultat du code suivant:",
    "tags": [],
    "title": "Questions et exercices",
    "uri": "/420-311/intro/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code dâ€™Ã©vÃ©nement dans le bandeau supÃ©rieur Quiz 2 : mÃ©thodes et interfaces Quiz Wooclap sur les mÃ©thodes et les interfaces",
    "description": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code dâ€™Ã©vÃ©nement dans le bandeau supÃ©rieur Quiz 2 : mÃ©thodes et interfaces Quiz Wooclap sur les mÃ©thodes et les interfaces",
    "tags": [],
    "title": "Quiz",
    "uri": "/420-311/intro/quiz/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Tout au long du cours nous allons utiliser diffÃ©rents outils de dÃ©veloppement logiciel largement employÃ©s dans lâ€™industrie. Ces outils permettent de travailler de maniÃ¨re plus efficace, professionnelle et collaborative.\nGit : pour gÃ©rer les versions du code et collaborer en Ã©quipe.\nMaven : pour automatiser la gestion des dÃ©pendances et la compilation des projets Java.\nAutres outils : environnements de dÃ©veloppement (IDE), plateformes de test, documentation et suivi de projet.\nCette section vous trouver des ressources qui vous aident Ã  se familiariser avec ces outils.",
    "description": "Tout au long du cours nous allons utiliser diffÃ©rents outils de dÃ©veloppement logiciel largement employÃ©s dans lâ€™industrie. Ces outils permettent de travailler de maniÃ¨re plus efficace, professionnelle et collaborative.\nGit : pour gÃ©rer les versions du code et collaborer en Ã©quipe.\nMaven : pour automatiser la gestion des dÃ©pendances et la compilation des projets Java.\nAutres outils : environnements de dÃ©veloppement (IDE), plateformes de test, documentation et suivi de projet.",
    "tags": [],
    "title": "Ressources utiles",
    "uri": "/420-311/ressourcesutiles/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Structure de donnÃ©es",
    "content": "Notion de structure de donnÃ©es â“‚ï¸ Le principe de base dâ€™une structure de donnÃ©es, câ€™est de stocker des Ã©lÃ©ments auxquels le programmeur veut pouvoir accÃ©der plus tard. On appelle les diffÃ©rentes utilisations possibles de la structure de donnÃ©es des opÃ©rations.\nClassification des structures de donnÃ©es ğŸ”¹ Structures de base Tableau (array) : Une collection dâ€™Ã©lÃ©ments de mÃªme type stockÃ©s en mÃ©moire de faÃ§on contiguÃ«. Chaque Ã©lÃ©ment est accessible par son index.\nSchÃ©ma Index : 0 1 2 3\rValeur: [10] [20] [30] [40]\rComplexitÃ© AccÃ¨s direct : O(1) Recherche dâ€™une valeur : O(n) Insertion/suppression : O(n) (dÃ©calage nÃ©cessaire) Avantages AccÃ¨s rapide par index. Simple Ã  utiliser. InconvÃ©nients Taille fixe (souvent). Insertion/suppression coÃ»teuses. Exemple rÃ©el Les siÃ¨ges dâ€™un avion numÃ©rotÃ©s â†’ on sait directement oÃ¹ est le siÃ¨ge 25B.\nListe chaÃ®nÃ©e (linked list) : Une sÃ©quence de nÅ“uds oÃ¹ chaque nÅ“ud contient une valeur et une rÃ©fÃ©rence vers le suivant (et parfois vers le prÃ©cÃ©dent â†’ liste doublement chaÃ®nÃ©e).\n* Liste simplement chaÃ®nÃ©e ğŸŒ¼ Les listes simplement chaÃ®nÃ©es sont des structures de donnÃ©es semblables aux tableaux. Les Ã©lÃ©ments de la liste sont souvent appelÃ©s Liens ou NÅ“uds. ğŸŒ¼ Un Ã©lÃ©ment de la liste se compose : ï‚§\tUn autre pointeur qui pointe vers lâ€™Ã©lÃ©ment suivant, ï‚§\tLe pointeur suivant du dernier Ã©lÃ©ment doit pointer vers NULL (la fin de la liste). ï‚§\tEn plus un Ã©lÃ©ment se compose dâ€™une valeur ğŸŒ¼ Pour accÃ©der Ã  un Ã©lÃ©ment, la liste peut Ãªtre parcourue dans les deux sens : ğŸŒ¼ En commenÃ§ant en tÃªte de liste, le pointeur suivant permettra le dÃ©placement vers le prochain Ã©lÃ©ment. ğŸŒ¼ En bref, le dÃ©placement se fait dans une seule direction, du premier vers le dernier Ã©lÃ©ment.\n* Liste doublement chaÃ®nÃ©e ğŸŒ¼ Les listes doublement chaÃ®nÃ©es sont des structures de donnÃ©es semblables aux listes simplement chaÃ®nÃ©es. Les Ã©lÃ©ments de la liste sont souvent appelÃ©s Liens ou NÅ“uds. La classe LinkedList permet de manipuler des listes dites â€œdoublement chaÃ®nÃ©esâ€. Ã€ chaque Ã©lÃ©ment de la collection, on associe (de faÃ§on totalement transparente pour le programmeur) deux informations supplÃ©mentaires qui ne sont autres que les rÃ©fÃ©rences Ã  lâ€™Ã©lÃ©ment prÃ©cÃ©dent et au suivant. Une telle collection peut ainsi Ãªtre parcourue Ã  lâ€™aide dâ€™un itÃ©rateur bidirectionnel de type ListIterator.\nLe grand avantage dâ€™une telle structure est de permettre des ajouts ou des suppressions Ã  une position donnÃ©e avec une efficacitÃ© en O (1) (ceci grÃ¢ce Ã  un simple jeu de modification de rÃ©fÃ©rences).\nEn revanche, lâ€™accÃ¨s Ã  un Ã©lÃ©ment en fonction de sa valeur ou de sa position dans la liste sera peu efficace puisquâ€™il nÃ©cessitera obligatoirement de parcourir une partie de la liste. Lâ€™efficacitÃ© sera donc en moyenne en O (N).\nSchÃ©ma TÃªte â†’ [10|â€¢] â†’ [20|â€¢] â†’ [30|null]\rListe simplement chaÃ®nÃ©e et liste doublement chaÃ®nÃ©e\nListe simplement chaÃ®nÃ©e circulaire\nComplexitÃ© Insertion/suppression en tÃªte : O(1)\nInsertion :\nÃ  la fin O(1) au dÃ©but O(1) au milieu O(n) suppression :\nau dÃ©but O(1) Ã  la fin O(n) / O(1) dans les Listes doublement chaÃ®nÃ©es. au milieu O(n) AccÃ¨s Ã  un Ã©lÃ©ment : O(n)\nAvantages Taille dynamique. Insertion/suppression rapides en tÃªte/fin. InconvÃ©nients AccÃ¨s sÃ©quentiel (lent). Plus de mÃ©moire (pointeurs). Exemple rÃ©el Un collier de perles oÃ¹ chaque perle est attachÃ©e Ã  la suivante.\nğŸ”¹ Structures linÃ©aires spÃ©cialisÃ©es Pile (Stack) Structure LIFO (Last In, First Out). Le dernier Ã©lÃ©ment insÃ©rÃ© est le premier retirÃ©.\nSchÃ©ma Push(10) â†’ Push(20) â†’ Push(30)\rPile: [30] [20] [10]\rPop() â†’ 30\rstack\nOpÃ©rations push(x) : ajouter en haut. pop() : retirer le dernier. peek() : lire le dernier sans le retirer. ComplexitÃ© Insertion/retrait : O(1) Exemple rÃ©el Pile dâ€™assiettes Ã  laver Ã  la main.\nFile (Queue) Structure FIFO (First In, First Out). Le premier Ã©lÃ©ment insÃ©rÃ© est le premier retirÃ©.\nSchÃ©ma Enqueue(10) â†’ Enqueue(20) â†’ Enqueue(30)\rFile: [10] [20] [30]\rDequeue() â†’ 10\rFile\nOpÃ©rations enqueue(x) : ajouter Ã  la fin. dequeue() : retirer au dÃ©but. peek() : lire le premier sans le retirer. ComplexitÃ© Insertion/retrait : O(1) Exemple rÃ©el File dâ€™attente Ã  la caisse dâ€™un magasin.\nFile de prioritÃ© (Priority Queue / Tas / Heap) Une file oÃ¹ chaque Ã©lÃ©ment a une prioritÃ©. Lâ€™Ã©lÃ©ment avec la plus haute prioritÃ© sort en premier. Souvent implÃ©mentÃ©e avec un tas binaire (heap).\nSchÃ©ma (tas min) 10\r/ \\\r20 15\r/ \\\r30 25\rExplication simple\nComplexitÃ© Insertion : O(log n) Extraction du min/max : O(log n) Exemple rÃ©el Service dâ€™urgence Ã  lâ€™hÃ´pital â†’ les cas graves passent avant.\nğŸ”¹ Structures hiÃ©rarchiques Arbre (Tree) Une structure hiÃ©rarchique composÃ©e de nÅ“uds reliÃ©s par des arÃªtes. Chaque nÅ“ud a :\nune valeur, des enfants. SchÃ©ma (arbre binaire) 10\r/ \\\r5 20\r/ \\ \\\r2 8 30\rTypes Arbre binaire : max 2 enfants. Arbre binaire de recherche (BST) : gauche \u003c racine \u003c droite. Arbres Ã©quilibrÃ©s (AVL, Red-Black). ComplexitÃ© (BST Ã©quilibrÃ©) Recherche, insertion, suppression : O(log n) Exemple rÃ©el Arborescence des dossiers/fichiers dans un ordinateur.\nGraphe (Graph) Un ensemble de sommets (nÅ“uds) reliÃ©s par des arÃªtes (liens). Peut Ãªtre orientÃ© ou non, pondÃ©rÃ© ou non.\nSchÃ©ma A â€”â€” B â€”â€” C\r| \\\rD E\rReprÃ©sentations Liste dâ€™adjacence. Matrice dâ€™adjacence. ComplexitÃ© Parcours BFS/DFS : O(V + E) (V = sommets, E = arÃªtes). Exemple rÃ©el Un rÃ©seau social (Facebook : personnes = sommets, amitiÃ©s = arÃªtes).\nğŸ”¹ Structures de recherche Table de hachage (Hash Table / HashMap) Associe une clÃ© Ã  une valeur via une fonction de hachage.\nSchÃ©ma ClÃ© â†’ Hachage â†’ Index â†’ Valeur\r\"Bob\" â†’ h(\"Bob\")=2 â†’ table[2] = 90\rComplexitÃ© Insertion/recherche/suppression : O(1) en moyenne. Avantages AccÃ¨s trÃ¨s rapide. InconvÃ©nients Collisions possibles (deux clÃ©s pour le mÃªme index). Consomme plus de mÃ©moire. Exemple rÃ©el Annuaire tÃ©lÃ©phonique (nom â†’ numÃ©ro).\nğŸ“Œ Tableau rÃ©capitulatif Structure AccÃ¨s Insertion Suppression Exemple concret Tableau O(1) (index) / O(n) (valeur) O(n) O(n) SiÃ¨ges dâ€™avion Liste chaÃ®nÃ©e O(n) O(1) en tÃªte ou fin O(1) en tÃªte Collier de perles Pile (Stack) O(n) O(1) O(1) Pile dâ€™assiettes File (Queue) O(n) O(1) O(1) File dâ€™attente Tas (Heap) O(n) O(log n) O(log n) Urgences hÃ´pital Arbre (BST) O(log n) O(log n) O(log n) Arborescence fichiers Graphe O(V+E) O(1) O(1) RÃ©seau social Hash Table O(1) O(1) O(1) Dictionnaire Dictionnaire et table associative (lâ€™interface Map) ğŸŒ¼ Une table associative permet de conserver une information associant deux parties nommÃ©es clÃ© et valeur. ğŸŒ¼ Elle est principalement destinÃ©e Ã  retrouver la valeur associÃ©e Ã  une clÃ© donnÃ©e. Les exemples les plus caractÃ©ristiques de telles tables sont :\nï‚§\tğŸ‘ Le dictionnaire : Ã  un mot (clÃ©), on associe une valeur qui est sa dÃ©finition,\nï‚§\tğŸ‘ Lâ€™annuaire usuel : Ã  un nom (clÃ©), on associe une valeur comportant le numÃ©ro de tÃ©lÃ©phone et, Ã©ventuellement, une adresse, ï‚§\tğŸ‘ Lâ€™annuaire inversÃ© : Ã  un numÃ©ro de tÃ©lÃ©phone (qui devient la clÃ©), on associe une valeur comportant le nom et, Ã©ventuellement, une adresse.",
    "description": "Notion de structure de donnÃ©es â“‚ï¸ Le principe de base dâ€™une structure de donnÃ©es, câ€™est de stocker des Ã©lÃ©ments auxquels le programmeur veut pouvoir accÃ©der plus tard. On appelle les diffÃ©rentes utilisations possibles de la structure de donnÃ©es des opÃ©rations.\nClassification des structures de donnÃ©es ğŸ”¹ Structures de base Tableau (array) : Une collection dâ€™Ã©lÃ©ments de mÃªme type stockÃ©s en mÃ©moire de faÃ§on contiguÃ«. Chaque Ã©lÃ©ment est accessible par son index.",
    "tags": [],
    "title": "Les structures de donnÃ©es",
    "uri": "/420-311/sdd/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Structure de donnÃ©es",
    "content": "Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util). On y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nStructure gÃ©nÃ©rale des collections en Java Une collection reprÃ©sente un groupe dâ€™objets, connu par ses Ã©lÃ©ments. Certaines collections acceptent les doublons, dâ€™autres pas. Certaines sont ordonnÃ©es, dâ€™autres pas.\nInterface Collection Depuis la version 1.6 de Java, il y a un changement dans la structure des collections. Il y a eu lâ€™ajout du package java.util.concurrent\nExemples : Besoin dâ€™accÃ¨s rapide par clÃ© ? â†’ HashMap. Besoin de garder lâ€™ordre triÃ© ? â†’ Arbre. Besoin dâ€™un traitement dans lâ€™ordre dâ€™arrivÃ©e ? â†’ File. Vous pourrez gÃ©nÃ©ralement vous contenter de connaÃ®tre les fonctionnalitÃ©s supplÃ©mentaires quâ€™offre chacune des classes LinkedList, ArrayList, Vector, HashSet, TreeSet, PriorityQueue et ArrayDeque. Mais, dans certains cas, vous devrez avoir quelques notions sur lâ€™architecture dâ€™interfaces employÃ©e par les concepteurs de la librairie. Elle se prÃ©sente comme suit :\nCollection\nList implÃ©mentÃ©e par LinkedList, ArrayList et Vector Set implÃ©mentÃ©e par HashSet SortedSet implÃ©mentÃ©e par TreeSet NavigableSet implÃ©mentÃ©e par TreeSet (Java 6) Queue (JDK 5.0) implÃ©mentÃ©e par LinkedList, PriorityQueue Deque (Java 6) implÃ©mentÃ©e par ArrayDeque, LinkedList Lâ€™interface Iterable public interface \u003cE\u003e Collection extends Iterable \u003cE\u003e\rCollection est lâ€™interface racine dans la hiÃ©rarchie des collections. Une collection reprÃ©sente un groupe dâ€™objets, connu sous le nom de ses Ã©lÃ©ments. Certaines collections :\nPermettent de dupliquer les Ã©lÃ©ments et dâ€™autres pas. Elles sont ordonnÃ©es et dâ€™autres pas. Le JDK ne fournit pas directement les implÃ©mentations de cette interface : il fournit des implÃ©mentations de sous-interfaces plus spÃ©cifiques telles que Set et List.\nLâ€™interface List public interface List\u003cE\u003e extends Collection\u003cE\u003e\rUne liste est une collection ordonnÃ©e (Ã©galement connu sous le nom de sÃ©quence).\nLâ€™utilisateur de cette interface Ã  un contrÃ´le prÃ©cis sur lâ€™endroit oÃ¹ est insÃ©rÃ© chaque Ã©lÃ©ment dans la liste. Lâ€™utilisateur peut accÃ©der aux Ã©lÃ©ments par leur index (position dans la liste), et rechercher des Ã©lÃ©ments dans la liste. Les listes permettent gÃ©nÃ©ralement les Ã©lÃ©ments dupliquÃ©s. Les listes permettent de multiples Ã©lÃ©ments nuls. Il nâ€™est pas inconcevable que quelquâ€™un puisse vouloir mettre en place une liste qui interdit les doublons, par exemple : en lanÃ§ant des exceptions dâ€™exÃ©cution lorsque lâ€™utilisateur tente de les insÃ©rer, cet usage est rare.\nğŸ”¹ Les listes chaÃ®nÃ©es - classe LinkedList Exemple\nLinkedList nombres = new LinkedList\u003c\u003e(); // =\u003e // LinkedList\u003cInteger\u003e nombres = new LinkedList\u003c\u003e(); nombres.addFirst(10); nombres.addLast(20); nombres.addLast(30); nombres.addLast(40); nombres.addFirst(50); nombres.removeLast(); nombres.removeFirst(); System.out.println(nombres); System.out.println(nombres.size()); System.out.println(nombres.contains(20)); System.out.println(nombres.indexOf(20)); var tab = nombres.toArray(); System.out.println(Arrays.toString(tab)); //Iterating LinkedList Iterator\u003cInteger\u003e iterator = nombres.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); }\rğŸ”¹ ArrayDeque File Ã  deux extrÃ©mitÃ©s (FIFO ou LIFO).\nExemple : File dâ€™impression. import java.util.ArrayDeque; public class ExempleArrayDeque { public static void main(String[] args) { ArrayDeque\u003cString\u003e file = new ArrayDeque\u003c\u003e(); file.add(\"Doc1\"); file.add(\"Doc2\"); file.add(\"Doc3\"); System.out.println(\"DÃ©queue : \" + file.poll()); } }\rComplexitÃ© :\nInsertion/suppression en tÃªte ou fin : O(1). AccÃ¨s index : O(n). MÃ©moire : O(n). ğŸ”¹ Vector Est un tableau dynamique comme ArrayList, mais synchronisÃ© (donc plus sÃ»r en environnement multithread).\nExemple : Une liste partagÃ©e entre plusieurs threads oÃ¹ la sÃ©curitÃ© des accÃ¨s est importante.\nComplexitÃ© :\nAccÃ¨s par index : O(1). Insertion fin : O(1) amorti (redimensionnement si plein). Insertion/suppression au milieu : O(n). MÃ©moire : O(n) (+ espace supplÃ©mentaire pour redimensionnement). import java.util.Vector; public class ExempleVector { public static void main(String[] args) { Vector\u003cString\u003e vecteur = new Vector\u003c\u003e(); vecteur.add(\"Alice\"); vecteur.add(\"Bob\"); vecteur.add(\"Charlie\"); System.out.println(\"Ã‰lÃ©ment Ã  lâ€™index 1 : \" + vecteur.get(1)); vecteur.remove(\"Alice\"); System.out.println(\"AprÃ¨s suppression : \" + vecteur); } }\rComplexitÃ© :\nAccÃ¨s par index : O(1). Insertion fin : O(1) amorti (redimensionnement si plein). Insertion/suppression au milieu : O(n). MÃ©moire : O(n) (+ espace supplÃ©mentaire pour redimensionnement). ğŸ”¹ Stack Structure LIFO (dernier entrÃ©, premier sorti).\nExemple : Pile dâ€™assiettes. import java.util.Stack; public class ExempleStack { public static void main(String[] args) { Stack\u003cString\u003e pile = new Stack\u003c\u003e(); pile.push(\"A\"); pile.push(\"B\"); pile.push(\"C\"); System.out.println(\"Pop : \" + pile.pop()); System.out.println(\"Sommet : \" + pile.peek()); } }\rComplexitÃ© :\nAjout : O(1). Suppression : O(1). lecture sommet : O(1). MÃ©moire : O(n). Les ensembles (Interface Set) Deux classes principales permettent dâ€™implÃ©menter la notion dâ€™ensemble en Java : HashSet et TreeSet.\nQuâ€™est-ce quâ€™un ensemble ? ThÃ©oriquement, un ensemble est une collection dâ€™Ã©lÃ©ments uniques, oÃ¹ :\naucun Ã©lÃ©ment ne peut apparaÃ®tre plusieurs fois, lâ€™ordre des Ã©lÃ©ments nâ€™a pas dâ€™importance. Ainsi, Ã  chaque fois quâ€™on insÃ¨re un nouvel Ã©lÃ©ment dans un HashSet ou un TreeSet, Java vÃ©rifie automatiquement que lâ€™Ã©lÃ©ment nâ€™existe pas dÃ©jÃ .\nLâ€™importance de equals, hashCode et compareTo Pour des types simples comme String, File ou les types numÃ©riques (Integer, Doubleâ€¦), tout fonctionne naturellement : lâ€™Ã©galitÃ© est dÃ©jÃ  bien dÃ©finie.\nEn revanche, pour des objets dÃ©finis par lâ€™utilisateur, il est souvent nÃ©cessaire de redÃ©finir correctement :\nla mÃ©thode equals() (et hashCode()) â†’ pour les ensembles basÃ©s sur le hachage, la mÃ©thode compareTo() (ou fournir un Comparator) â†’ pour les ensembles basÃ©s sur les arbres. ğŸ‘‰ Sans cette redÃ©finition, deux objets reprÃ©sentant la mÃªme valeur mais ayant des rÃ©fÃ©rences diffÃ©rentes seront considÃ©rÃ©s comme distincts.\nPourquoi un ordre interne ? MÃªme si, en thÃ©orie, un ensemble est â€œnon ordonnÃ©â€, les concepteurs des collections Java ont dÃ» organiser les donnÃ©es pour rendre les tests dâ€™appartenance (ex. set.contains(x)) efficaces. Sinon, il faudrait parcourir tous les Ã©lÃ©ments un par un, ce qui coÃ»terait O(n).\nDeux stratÃ©gies ont donc Ã©tÃ© retenues :\nğŸ”¹ HashSet DÃ©finition : Ensemble non ordonnÃ©, sans doublons. Utilise une fonction de hachage pour rÃ©partir les Ã©lÃ©ments dans des cases. Avantage : test dâ€™appartenance, insertion et suppression trÃ¨s rapides â†’ O(1) en moyenne. InconvÃ©nient : les Ã©lÃ©ments nâ€™ont aucun ordre visible. Exemple : Liste dâ€™Ã©tudiants inscrits (pas de doublons). import java.util.HashSet; public class ExempleHashSet { public static void main(String[] args) { HashSet\u003cString\u003e etudiants = new HashSet\u003c\u003e(); etudiants.add(\"Alice\"); etudiants.add(\"Bob\"); etudiants.add(\"Alice\"); // ignorÃ© System.out.println(\"Ã‰tudiants : \" + etudiants); } }\rComplexitÃ© :\nRecherche : O(1). Insertion : O(1). Suppression : O(1). MÃ©moire : O(n). ğŸ”¹ TreeSet ğŸŒ¼ La classe TreeSet propose une autre organisation utilisant un â€œarbre binaireâ€ (arbre binaire de recherche Ã©quilibrÃ©), lequel permet dâ€™ordonner totalement les Ã©lÃ©ments. On y utilise, cette fois, la relation dâ€™ordre naturel induite par la mÃ©thode compareTo des objets ou par un comparateur (quâ€™on peut fournir Ã  la construction de lâ€™ensemble).\nğŸŒ¼ Dans ces conditions, la recherche dans cet arbre dâ€™un Ã©lÃ©ment de valeur donnÃ©e est gÃ©nÃ©ralement moins rapide que dans une table de hachage, mais plus rapide quâ€™une recherche sÃ©quentielle. On peut montrer que son efficacitÃ© est en O(log n). Il est lÃ©gÃ¨rement plus lent quâ€™un HashSet.\nğŸŒ¼ Par ailleurs, lâ€™utilisation dâ€™un arbre binaire permet de disposer en permanence dâ€™un ensemble totalement ordonnÃ© (triÃ©). On notera dâ€™ailleurs que la classe TreeSet dispose de deux mÃ©thodes spÃ©cifiques first et last fournissant respectivement le premier et le dernier Ã©lÃ©ment de lâ€™ensemble.\nExemple : Classement des notes. import java.util.TreeSet; public class ExempleTreeSet { public static void main(String[] args) { TreeSet\u003cInteger\u003e notes = new TreeSet\u003c\u003e(); notes.add(85); notes.add(90); notes.add(70); System.out.println(\"Notes triÃ©es : \" + notes); } }\rComplexitÃ© :\nRecherche : O(log n). Insertion : O(log n). Suppression : O(log n). MÃ©moire : O(n). Comparaison HashSet : rapide, sans ordre â†’ parfait pour vÃ©rifier lâ€™appartenance rapidement. TreeSet : plus lent, mais les Ã©lÃ©ments sont triÃ©s â†’ utile si on veut parcourir lâ€™ensemble dans un ordre prÃ©cis. Dictionnaire et table associative (lâ€™interface Map) ğŸŒ¼ Depuis le JDK 5.0, les tables associatives sont gÃ©nÃ©riques, au mÃªme titre que les collections, mais elles sont dÃ©finies par deux paramÃ¨tres de type (celui des clÃ©s, notÃ© gÃ©nÃ©ralement K, celui des valeurs, notÃ© gÃ©nÃ©ralement V) au lieu dâ€™un.\nImplÃ©mentation des Map ğŸŒ¼ Comme pour les ensembles, lâ€™intÃ©rÃªt des tables associatives est de pouvoir y retrouver rapidement une clÃ© donnÃ©e pour en obtenir lâ€™information associÃ©e. On va donc tout naturellement retrouver les deux types dâ€™organisation rencontrÃ©s pour les ensembles :\nğŸ‘ Table de hachage : classe HashMap, ğŸ‘ Arbre binaire : classe TreeMap. ğŸŒ¼ Dans les deux cas, seule la clÃ© sera utilisÃ©e pour ordonnancer les informations. ğŸŒ¼ Dans le premier cas, on se servira du code de hachage des objets formant les clÃ©s ; dans le second cas, on se servira de la relation dâ€™ordre induite par compareTo ou par un comparateur fixÃ© Ã  la construction. ğŸŒ¼ Lâ€™accÃ¨s Ã  un Ã©lÃ©ment dâ€™un HashMap sera en O (1) tandis que celle Ã  un Ã©lÃ©ment dâ€™un TreeMap sera en O (Log N).\nğŸŒ¼ En contrepartie de leur accÃ¨s moins rapide, les TreeMap seront (comme les TreeSet) ordonnÃ©s en permanence suivant leurs clÃ©s.\nPrÃ©sentation gÃ©nÃ©rale des classes HashMap et TreeMap ğŸŒ¼ Comme nous lâ€™avons signalÃ©, les classes HashMap et TreeMap nâ€™implÃ©mentent plus lâ€™interface Collection, mais une autre interface nommÃ©e Map. Ceci provient essentiellement du fait que leurs Ã©lÃ©ments ne sont plus Ã  proprement parler des objets, mais des â€œpairesâ€ dâ€™objets câ€™est-Ã -dire une association entre deux objets.\nğŸ‘ Ajout dâ€™information ğŸŒ¼ La plupart des constructeurs crÃ©ent une table vide. Pour ajouter une clÃ© Ã  une table, on utilise la mÃ©thode put Ã  laquelle on fournit la clÃ© et la valeur associÃ©e ; par exemple, si K dÃ©signe le type des clÃ©s et V celui des valeurs :\n/* crÃ©ation dâ€™une table vide */ HashMap \u003cK, V\u003e m = new HashMap \u003cK, V\u003e () ; /* ajoute Ã  m, un Ã©lÃ©ment associant la clÃ© \"m\" (String) Ã  la valeur 3 (Integer) */ m.put (\"m\", 3) ;\rğŸŒ¼ Si la clÃ© fournie Ã  put existe dÃ©jÃ , la valeur associÃ©e remplacera lâ€™ancienne (une clÃ© donnÃ©e ne pouvant figurer quâ€™une seule fois dans une table). Dâ€™ailleurs, put fournit en retour soit lâ€™ancienne valeur si la clÃ© existait dÃ©jÃ , soit nul.\nğŸŒ¼ Notez que, comme pour les autres collections, les clÃ©s et les valeurs doivent Ãªtre des objets. Il nâ€™est thÃ©oriquement pas nÃ©cessaire que toutes les clÃ©s soient de mÃªme type, pas plus que les Ã©lÃ©ments. En pratique, ce sera presque toujours le cas pour des questions Ã©videntes de facilitÃ© dâ€™exploitation de la table.\nğŸ‘ Recherche dâ€™information ğŸŒ¼ On obtient la valeur associÃ©e Ã  une clÃ© donnÃ©e Ã  lâ€™aide de la mÃ©thode get, laquelle fournit nulle si la clÃ© cherchÃ©e nâ€™est pas prÃ©sente (V reprÃ©sente le type de la valeur) :\nV o = get (\"x\") ; // fournit la valeur associÃ©e Ã  la clÃ© \"x\" // if (o == null) System.out.println (\"Aucune valeur associÃ©e Ã  la clÃ© x\") ;\rğŸŒ¼ Lâ€™efficacitÃ© de cette recherche est en O (1) pour HashMap et en O(Log N) pour TreeMap.\nğŸŒ¼ La mÃ©thode containsKey permet de savoir si une clÃ© donnÃ©e est prÃ©sente avec la mÃªme efficacitÃ©.\nğŸ‘ Suppression dâ€™information ğŸŒ¼ On peut supprimer un Ã©lÃ©ment dâ€™une table en utilisant la mÃ©thode remove, laquelle fournit en retour lâ€™ancienne valeur associÃ©e si la clÃ© existe ou la valeur null dans le cas contraire :\nV val = remove (cle) ;\t// supprime lâ€™Ã©lÃ©ment (clÃ© + valeur) de clÃ© \"x\" if (val != null) System.out.println (\"On a supprimÃ© lâ€™Ã©lÃ©ment de clÃ© \" + cle + \" et de valeur\" + val);\rğŸ”¹ HashMap Associe une clÃ© Ã  une valeur, accÃ¨s rapide.\nExemple : Dictionnaire (mot â†’ dÃ©finition). import java.util.HashMap; public class ExempleHashMap { public static void main(String[] args) { Map\u003cString, Integer\u003e notes = new HashMap\u003c\u003e(); notes.put(\"Alice\", 85); notes.put(\"Bob\", 90); System.out.println(\"Note de Bob : \" + notes.get(\"Bob\")); // Parcours des clÃ©s/valeurs for (Map.Entry\u003cString, Integer\u003e e : notes.entrySet()) { System.out.println(e.getKey() + \" â†’ \" + e.getValue()); } } }\rComplexitÃ© :\nRecherche : O(1) (moyenne), O(n) (pire cas si collisions). Insertion : O(1).* Suppression : O(1). MÃ©moire : O(n) + surcharge pour les tables de hachage. ğŸ”¹ TreeMap Map triÃ©e par clÃ©s.\nExemple : Carnet dâ€™adresses triÃ© par nom. import java.util.TreeMap; public class ExempleTreeMap { public static void main(String[] args) { TreeMap\u003cString, Integer\u003e carnet = new TreeMap\u003c\u003e(); carnet.put(\"Charlie\", 555123); carnet.put(\"Alice\", 555789); carnet.put(\"Bob\", 555456); System.out.println(\"Carnet triÃ© : \" + carnet); System.out.println(\"Premier : \" + arbre.firstEntry()); System.out.println(\"Dernier : \" + arbre.lastEntry()); } }\rComplexitÃ© :\nRecherche : O(log n). Insertion : O(log n). Suppression : O(log n). MÃ©moire : O(n). ğŸ”¹ LinkedHashMap Map qui garde lâ€™ordre dâ€™insertion.\nExemple : Historique de navigation. import java.util.LinkedHashMap; public class ExempleLinkedHashMap { public static void main(String[] args) { LinkedHashMap\u003cInteger, String\u003e historique = new LinkedHashMap\u003c\u003e(); historique.put(1, \"Google\"); historique.put(2, \"YouTube\"); historique.put(3, \"Wikipedia\"); System.out.println(\"Historique : \" + historique); } }\rComplexitÃ© :\nRecherche : O(log n). Insertion : O(log n). Suppression : O(log n). MÃ©moire : O(n). ğŸ”¹ LinkedHashSet DÃ©finition : Ensemble qui garde lâ€™ordre dâ€™insertion. Exemple : Liste dâ€™achats sans doublons. import java.util.LinkedHashSet; public class ExempleLinkedHashSet { public static void main(String[] args) { LinkedHashSet\u003cString\u003e courses = new LinkedHashSet\u003c\u003e(); courses.add(\"Lait\"); courses.add(\"Pain\"); courses.add(\"Lait\"); // ignorÃ© courses.add(\"Oeufs\"); System.out.println(\"Liste dâ€™achats : \" + courses); } }\rTableau des complexitÃ©s Structure AccÃ¨s Insertion Suppression MÃ©moire HashMap O(1) O(1) O(1) O(n) TreeMap O(log n) O(log n) O(log n) O(n) LinkedHashMap O(1) O(1) O(1) O(n) LinkedList O(n) O(1) tÃªte/fin O(1) tÃªte/fin O(n) ArrayList O(1) index O(1) fin amorti O(n) O(n) Vector O(1) index O(1) fin amorti O(n) O(n) Stack O(n) accÃ¨s O(1) push O(1) pop O(n) ArrayDeque O(n) accÃ¨s O(1) tÃªte/fin O(1) tÃªte/fin O(n) HashSet O(1) O(1) O(1) O(n) TreeSet O(log n) O(log n) O(log n) O(n) LinkedHashSet O(1) O(1) O(1) O(n) ğŸ”¹ Tas (Heap) (PriorityQueue) import java.util.*; public class ExempleTas { public static void main(String[] args) { PriorityQueue\u003cInteger\u003e tas = new PriorityQueue\u003c\u003e(); tas.add(30); tas.add(10); tas.add(20); // Extrait toujours le plus petit Ã©lÃ©ment System.out.println(\"Min : \" + tas.poll()); // 10 System.out.println(\"Min suivant : \" + tas.poll()); // 20 } }",
    "description": "Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util). On y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.",
    "tags": [],
    "title": "Les structures de donnÃ©es en Java ",
    "uri": "/420-311/sdd/javasdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Structure de donnÃ©es",
    "content": "ğŸŒ¼ DiffÃ©rence entre Lâ€™interface Comparator et Comparable\nğŸŒ¼ Comparator et comparable sont deux interfaces de lâ€™API Java.\nğŸŒ¼ Il est souvent nÃ©cessaire de trier les objets stockÃ©s dans des collections ou tableaux (Array). En utilisant ces 02 interfaces, objets Java peuvent Ãªtre triÃ©s dans un ordre prÃ©dÃ©fini .\nComparator est dÃ©fini dans le package java.util Comparable est dÃ©fini dans le paquet java.lang Comparable ğŸ§­ Un objet implÃ©mentant Comparable est capable de se comparer avec un autre objet . La classe elle-mÃªme doit implÃ©mente lâ€™interface java.lang.Comparable afin de comparer ses instances.\nâ“ Quand utiliser lâ€™interface Comparable?\nğŸ§­ Si vous voulez trier une collection dâ€™objets par une propriÃ©tÃ© particuliÃ¨re par dÃ©faut - par exemple: Vous avez une liste dâ€™objets EmployÃ© et que vous voulez trier les objets par EmpID par dÃ©faut, vous pouvez utiliser comparable .\njava.lang.Comparable: int compareTo(Object obj1) ğŸ¥¥ Cette mÃ©thode compare lâ€™objet en cours Ã  obj1 et retour un entier.\nPositive: lâ€™objet courant est supÃ©rieur Ã  obj1 ZÃ©ro: lâ€™objet courant est Ã©gal Ã  obj1 NÃ©gative: lâ€™objet courant est infÃ©rieur Ã  obj1 Comparator ğŸ¸ Un objet implÃ©mentant lâ€™interface Comparator est capable de comparer deux objets diffÃ©rents. La classe ne compare pas ses instances, mais les instances dâ€™autres classes.\nâ“ Quand utiliser interface Comparator?\nğŸ¸ Si vous voulez trier un objet suivant une propriÃ©tÃ© autre que celle par dÃ©faut, vous pouvez utiliser comparateur.\njava.util.Comparator: int compare(Object o1, Object o2) ğŸ¥¥ Cette mÃ©thode compare o1 Ã  o2 et retour un entier.\nPositive: o1 est supÃ©rieur Ã  o2 ZÃ©ro: o1 est Ã©gal Ã  o2 NÃ©gative: o1 est infÃ©rieur Ã  o2",
    "description": "ğŸŒ¼ DiffÃ©rence entre Lâ€™interface Comparator et Comparable\nğŸŒ¼ Comparator et comparable sont deux interfaces de lâ€™API Java.\nğŸŒ¼ Il est souvent nÃ©cessaire de trier les objets stockÃ©s dans des collections ou tableaux (Array). En utilisant ces 02 interfaces, objets Java peuvent Ãªtre triÃ©s dans un ordre prÃ©dÃ©fini .\nComparator est dÃ©fini dans le package java.util Comparable est dÃ©fini dans le paquet java.lang Comparable ğŸ§­ Un objet implÃ©mentant Comparable est capable de se comparer avec un autre objet . La classe elle-mÃªme doit implÃ©mente lâ€™interface java.lang.Comparable afin de comparer ses instances.",
    "tags": [],
    "title": "Comparable Vs Comparator",
    "uri": "/420-311/sdd/compare/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Structure de donnÃ©es",
    "content": "DÃ©finition Le hachage est une technique qui consiste Ã  transformer une donnÃ©e (clÃ©) en un nombre entier appelÃ© code de hachage (hash code). â¡ï¸ Ce nombre sert dâ€™adresse pour placer ou retrouver rapidement la donnÃ©e dans une table.\nğŸ‘‰ Exemple simple :\nClÃ© = \"Alice\" Fonction de hachage â†’ produit un entier 12345 Cet entier est utilisÃ© comme position pour stocker la valeur associÃ©e. La mÃ©thode hashCode() en Java Dans Java, chaque objet hÃ©rite de la mÃ©thode :\npublic int hashCode()\rCette mÃ©thode retourne un entier qui reprÃ©sente lâ€™objet.\nPour que le hachage fonctionne correctement, il faut respecter le contrat :\nSi deux objets sont Ã©gaux (equals), ils doivent avoir le mÃªme hashCode. Si deux objets ont des hashCode diffÃ©rents â†’ ils sont forcÃ©ment diffÃ©rents. Si deux objets ont le mÃªme hashCode â†’ ils peuvent Ãªtre Ã©gaux ou diffÃ©rents (câ€™est une collision). Exemple avec HashMap import java.util.HashMap; public class ExempleHashage { public static void main(String[] args) { HashMap\u003cString, Integer\u003e notes = new HashMap\u003c\u003e(); notes.put(\"Alice\", 85); notes.put(\"Bob\", 90); System.out.println(\"Note de Bob : \" + notes.get(\"Bob\")); } }\râ¡ï¸ Ici :\n\"Bob\" est passÃ© Ã  une fonction de hachage (hashCode()). Le rÃ©sultat dÃ©termine dans quel compartiment de la HashMap lâ€™Ã©lÃ©ment est stockÃ©. Lorsquâ€™on fait notes.get(\"Bob\"), Java recalcule le hash et retrouve la valeur. Gestion des collisions Une collision arrive quand deux clÃ©s diffÃ©rentes produisent le mÃªme hashCode. ğŸ‘‰ Exemple :\n\"AB\" â†’ hashCode = 123 \"BA\" â†’ hashCode = 123 Java doit alors stocker les deux valeurs dans le mÃªme compartiment et vÃ©rifier avec equals() pour distinguer les objets.\nEfficacitÃ© Recherche, insertion, suppression dans une HashMap ou HashSet : O(1) en moyenne. Mais en cas de nombreuses collisions, cela peut devenir O(n) (rare si la fonction de hachage est bien conÃ§ue). Exemple personnalisÃ© : redÃ©finir hashCode() et equals() class Etudiant { String nom; int id; Etudiant(String nom, int id) { this.nom = nom; this.id = id; } @Override public int hashCode() { return id; // simplification } @Override public boolean equals(Object obj) { if (this == obj) return true; if (!(obj instanceof Etudiant)) return false; Etudiant autre = (Etudiant) obj; return this.id == autre.id \u0026\u0026 this.nom.equals(autre.nom); } } public class TestHash { public static void main(String[] args) { HashSet\u003cEtudiant\u003e set = new HashSet\u003c\u003e(); set.add(new Etudiant(\"Alice\", 1)); set.add(new Etudiant(\"Alice\", 1)); // considÃ©rÃ© comme identique System.out.println(set.size()); // 1 } }\rComment Ã©viter (ou limiter) les collisions en Java 1. Bien redÃ©finir hashCode() et equals() Quand on crÃ©e ses propres classes (ex. Etudiant, Livreâ€¦), il faut sâ€™assurer que :\nhashCode() distribue les objets de maniÃ¨re uniforme dans lâ€™espace des entiers. equals() est cohÃ©rent avec hashCode(). ğŸ‘‰ Mauvais exemple (cause de collisions frÃ©quentes) :\n@Override public int hashCode() { return 1; // tous les objets ont le mÃªme hash ! }\rğŸ‘‰ Bon exemple :\n@Override public int hashCode() { return Objects.hash(nom, id); }\rDans cet exemple, Objects.hash() combine les champs en gÃ©nÃ©rant un hash plus Ã©quilibrÃ©.\n2. Choisir des champs pertinents Un hashCode() doit utiliser les attributs discriminants de lâ€™objet :\nExemple : pour un Ã©tudiant â†’ id et nom. Ne pas se baser sur des valeurs qui changent souvent (risque dâ€™incohÃ©rence). 3. Utiliser des nombres premiers Dans lâ€™implÃ©mentation manuelle, on recommande souvent de :\nMultiplier par un nombre premier (souvent 31) pour gÃ©nÃ©rer un hash plus variÃ©. ğŸ‘‰ Exemple classique :\n@Override public int hashCode() { int result = 17; // nombre premier result = 31 * result + id; result = 31 * result + (nom == null ? 0 : nom.hashCode()); return result; }\r4. Maintenir une bonne taille de table Dans une HashMap, la taille du tableau interne influe sur les collisions :\nTrop petite â†’ collisions frÃ©quentes. Trop grande â†’ gaspillage de mÃ©moire. Java redimensionne automatiquement la HashMap quand elle dÃ©passe un seuil (load factor, par dÃ©faut 0.75). Si on compte stocker beaucoup dâ€™Ã©lÃ©ments, il serait mieux dâ€™initialiser la HashMap avec une capacitÃ© suffisante :\nHashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e(10_000);\r5. Utiliser TreeMap ou TreeSet si lâ€™ordre est utile Si lâ€™Ã©galitÃ© entre les Ã©lÃ©ments peut Ãªtre testÃ©e efficacement avec un ordre (compareTo), un TreeSet ou un TreeMap rÃ©duit le risque de collisions car ils sâ€™appuient sur des arbres Ã©quilibrÃ©s (O(log n)) au lieu dâ€™un hash.\nComment Java gÃ¨re les collisions Avant Java 8 : collisions stockÃ©es dans une liste chaÃ®nÃ©e dans chaque compartiment â†’ O(n) dans le pire cas. Depuis Java 8 : quand une case contient beaucoup dâ€™Ã©lÃ©ments, la liste devient un arbre rouge-noir â†’ O(log n) dans le pire cas. RÃ©sumÃ© (Ã  retenir) Le hachage transforme une clÃ© en un entier (hashCode). UtilisÃ© par HashMap, HashSet, Hashtable. Doit Ãªtre couplÃ© avec equals() pour distinguer les objets. TrÃ¨s efficace â†’ O(1) en moyenne pour les opÃ©rations de recherche et dâ€™insertion. Les collisions sont gÃ©rÃ©es par des structures internes (listes chaÃ®nÃ©es, puis arbres rouges-noirs depuis Java 8). Avec le mauvais hashCode, toutes les donnÃ©es vont dans le mÃªme compartiment â†’ le HashSet devient une liste chaÃ®nÃ©e â†’ temps dâ€™insertion beaucoup plus long.\nAvec le bon hashCode, les donnÃ©es sont bien rÃ©parties â†’ temps dâ€™insertion rapide (O(1) en moyenne).\nPour Ã©viter les collisions : Toujours redÃ©finir hashCode() et equals() correctement. Utiliser des champs discriminants et stables. Combiner les champs avec des nombres premiers. Ajuster la capacitÃ© initiale de la HashMap si besoin. Sâ€™appuyer sur les collections triÃ©es (TreeSet, TreeMap) si un ordre est prÃ©fÃ©rable.",
    "description": "DÃ©finition Le hachage est une technique qui consiste Ã  transformer une donnÃ©e (clÃ©) en un nombre entier appelÃ© code de hachage (hash code). â¡ï¸ Ce nombre sert dâ€™adresse pour placer ou retrouver rapidement la donnÃ©e dans une table.\nğŸ‘‰ Exemple simple :\nClÃ© = \"Alice\" Fonction de hachage â†’ produit un entier 12345 Cet entier est utilisÃ© comme position pour stocker la valeur associÃ©e. La mÃ©thode hashCode() en Java Dans Java, chaque objet hÃ©rite de la mÃ©thode :",
    "tags": [],
    "title": "ğŸ“– Le hachage",
    "uri": "/420-311/sdd/hachage/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Structure de donnÃ©es",
    "content": "Ã‰tude de cas 1 Ã‰tude de cas Soit les classes suivantes avec leurs attributs successives :\nClasse Compagnie assurance :\nnumÃ©ro de la compagnie (unique), nom de compagnie, liste assurances : une collection dâ€™assurances de type List. Classe Assurance :\ncode dâ€™assurance (unique), nom de lâ€™assurance, prix de lâ€™assurance, type dâ€™assurance (Habitation, Auto ou Vie). Ã‰crire en Java un programme qui permet la gestion de la compagnie dâ€™assurance. Dans ce programme vous devez coder les mÃ©thodes suivantes:\nAfficher le chiffre dâ€™affaires total de la compagnie (somme totale des assurances). Afficher lâ€™inventaire (la liste des assurances) de la compagnie triÃ©e en ordre dÃ©croissant de prix dâ€™assurance (du plus grand vers le plus petit). Convertir la liste lue en une collection de type Map (Integer, Assurance). Trier la Map par clÃ© (numÃ©ro dâ€™assurance). Parcourir la liste des assurances et modifier les prix des assurances comme suit : Augmenter le prix de lâ€™assurance habitation de 10% Diminuer le prix dâ€™assurance auto de 8% Diviser le prix de lâ€™assurance vie par : 3 si le code dâ€™assurance est impair. 4 si le code dâ€™assurance est pair. Ã‰tude de cas 2 La classe Compte possÃ¨de les attributs suivants :\nnumCompte nom solde Objectif Mettre en pratique les notions liÃ©es aux collections Java :\nList Set Map Vous devez coder les mÃ©thodes suivantes :\nğŸ”¹ List Nom de la mÃ©thode Description addCompteToList Permet de rajouter une instance de la classe Compte dans une collection de type List. findCompte Permet de rechercher une instance de la classe Compte dans une collection de type List. deleteCompte Permet de supprimer une instance de la classe Compte dans une collection de type List. emptyList Permet de vider complÃ¨tement une collection de type List. sortList Permet de trier une collection de type List. ğŸ”¹ Set Nom de la mÃ©thode Description addCompteToSet Permet de rajouter une instance de la classe Compte dans une collection de type Set. findCompte Permet de rechercher une instance de la classe Compte dans une collection de type Set. deleteCompte Permet de supprimer une instance de la classe Compte dans une collection de type Set. emptySet Permet de vider complÃ¨tement une collection de type Set. sortSet Permet de trier une collection de type Set. ğŸ”¹ Map Nom de la mÃ©thode Description addCompteToMap Permet de rajouter une instance de la classe Compte dans une collection de type Map. findCompte Permet de rechercher une instance de la classe Compte dans une collection de type Map. deleteCompte Permet de supprimer une instance de la classe Compte dans une collection de type Map. emptyMap Permet de vider complÃ¨tement une collection de type Map. sortMap Permet de trier une collection de type Map. âœ… Ã€ faire Coder les mÃ©thodes prÃ©cÃ©dentes. Utiliser JUnit pour tester toutes les mÃ©thodes.",
    "description": "Ã‰tude de cas 1 Ã‰tude de cas Soit les classes suivantes avec leurs attributs successives :\nClasse Compagnie assurance :\nnumÃ©ro de la compagnie (unique), nom de compagnie, liste assurances : une collection dâ€™assurances de type List. Classe Assurance :\ncode dâ€™assurance (unique), nom de lâ€™assurance, prix de lâ€™assurance, type dâ€™assurance (Habitation, Auto ou Vie). Ã‰crire en Java un programme qui permet la gestion de la compagnie dâ€™assurance. Dans ce programme vous devez coder les mÃ©thodes suivantes:",
    "tags": [],
    "title": "ğŸ“ Exercices : Collections en Java",
    "uri": "/420-311/sdd/exercicessdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Structure de donnÃ©es",
    "content": "ğŸŒ¼ Pour coder une liste doublement chaÃ®nÃ©e en orientÃ©e objet, on doit coder :\nLa classe Lien ou NÅ“ud Nous nâ€™allons pas utiliser la notion de gÃ©nÃ©rique. La classe Lien ou nÅ“ud possÃ¨de les champs suivants : Suivant de type Lien ou NÅ“ud; PrÃ©cÃ©dent de type Lien ou NÅ“ud; Valeur de type entier. La classe Lien ou nÅ“ud possÃ¨de les mÃ©thodes suivantes: Constructeur avec un paramÃ¨tre qui sera la valeur; Getter/Setter pour les champs; MÃ©thode dâ€™affichage de la valeur. La classe ListeDoublementChainee Les champs de la classe : Premier de type Lien ou NÅ“ud; Dernier de type Lien ou NÅ“ud. Les mÃ©thodes: Un constructeur sans paramÃ¨tres : ou il faut mettre Premier et Dernier Ã  NULL; Une mÃ©thode boolÃ©enne estVide () : qui teste si Premier est NULL; Une mÃ©thode : public void insererEnDebutListe (int valeur) { DÃ©clarer un nouveau Lien et lui passer la valeur en paramÃ¨tres de la mÃ©thode; Si la liste estVide (){ Dernier = nouveauLien; } Sinon { Premier.Precedent = nouveauLien; nouveauLien.suivant = Premier; } Premier = nouveauLien; }\rUne mÃ©thode : public void insererEnFinDeListe (int valeur) { DÃ©clarer un nouveauLien et lui passer la valeur en paramÃ¨tres de la mÃ©thode; Si la liste estVide (){ Premier = nouveauLien; } Sinon { Dernier.suivant = nouveauLien; nouveauLien.precedent = Dernier; } Dernier = nouveauLien; }\rpublic boolean insererApresValeur (int valeurPosition, int valeurAInserer) { Lien courant = premier; Tant que (courant.valeur nâ€™est pas Ã©gale Ã  valeurPosition){ courant = courant.suivant; si (courant est NULL) { retourner FALSE; } DÃ©clarer un nouveauLien et lui passer la valeurAInserer en paramÃ¨tres de la mÃ©thode; Si (courant = Dernier){ nouveauLien.suivant = null; dernier = nouveauLien; } Sinon { nouveauLien.suivant = courant.suivant; courant.suivant.precedent = nouveauLien; } nouveauLien.precedent = courant; courant.suivant = nouveauLien; retourner true; // on a trouvÃ©, on insÃ©re \"valeurAInserer\" } }",
    "description": "ğŸŒ¼ Pour coder une liste doublement chaÃ®nÃ©e en orientÃ©e objet, on doit coder :\nLa classe Lien ou NÅ“ud Nous nâ€™allons pas utiliser la notion de gÃ©nÃ©rique. La classe Lien ou nÅ“ud possÃ¨de les champs suivants : Suivant de type Lien ou NÅ“ud; PrÃ©cÃ©dent de type Lien ou NÅ“ud; Valeur de type entier. La classe Lien ou nÅ“ud possÃ¨de les mÃ©thodes suivantes: Constructeur avec un paramÃ¨tre qui sera la valeur; Getter/Setter pour les champs; MÃ©thode dâ€™affichage de la valeur. La classe ListeDoublementChainee Les champs de la classe : Premier de type Lien ou NÅ“ud; Dernier de type Lien ou NÅ“ud. Les mÃ©thodes: Un constructeur sans paramÃ¨tres : ou il faut mettre Premier et Dernier Ã  NULL; Une mÃ©thode boolÃ©enne estVide () : qui teste si Premier est NULL; Une mÃ©thode : public void insererEnDebutListe (int valeur) { DÃ©clarer un nouveau Lien et lui passer la valeur en paramÃ¨tres de la mÃ©thode; Si la liste estVide (){ Dernier = nouveauLien; } Sinon { Premier.Precedent = nouveauLien; nouveauLien.suivant = Premier; } Premier = nouveauLien; }\rUne mÃ©thode : public void insererEnFinDeListe (int valeur) { DÃ©clarer un nouveauLien et lui passer la valeur en paramÃ¨tres de la mÃ©thode; Si la liste estVide (){ Premier = nouveauLien; } Sinon { Dernier.suivant = nouveauLien; nouveauLien.precedent = Dernier; } Dernier = nouveauLien; }\rpublic boolean insererApresValeur (int valeurPosition, int valeurAInserer) { Lien courant = premier; Tant que (courant.valeur nâ€™est pas Ã©gale Ã  valeurPosition){ courant = courant.suivant; si (courant est NULL) { retourner FALSE; } DÃ©clarer un nouveauLien et lui passer la valeurAInserer en paramÃ¨tres de la mÃ©thode; Si (courant = Dernier){ nouveauLien.suivant = null; dernier = nouveauLien; } Sinon { nouveauLien.suivant = courant.suivant; courant.suivant.precedent = nouveauLien; } nouveauLien.precedent = courant; courant.suivant = nouveauLien; retourner true; // on a trouvÃ©, on insÃ©re \"valeurAInserer\" } }",
    "tags": [],
    "title": "Algorithmes codage de la liste doublement chaÃ®nÃ©e",
    "uri": "/420-311/sdd/linkedlist/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ ComplexitÃ© algorithmique",
    "content": "Quâ€™est-ce que la complexitÃ© algorithmique ? La complexitÃ© algorithmique dÃ©signe en informatique la quantitÃ© de ressources quâ€™un algorithme consomme lors de son exÃ©cution (On utilise Grand O pour dÃ©crire la performance dâ€™une algorithme). Elle se dÃ©cline en deux dimensions principales :\nLa complexitÃ© temporelle, qui mesure le temps dâ€™exÃ©cution. La complexitÃ© spatiale, qui Ã©value la mÃ©moire supplÃ©mentaire requise en dehors des donnÃ©es dâ€™entrÃ©e. Ces deux aspects sont indÃ©pendants : un algorithme peut Ãªtre trÃ¨s rapide mais consommer beaucoup de mÃ©moire, ou inversement.\nPour bien Ã©valuer un algorithme, il faut examiner son comportement dans diffÃ©rents contextes :\nle meilleur cas, le pire cas (souvent privilÃ©giÃ© pour anticiper les situations extrÃªmes), et le cas moyen, qui reflÃ¨te son usage habituel. Comparer la complexitÃ© de plusieurs algorithmes rÃ©solvant le mÃªme problÃ¨me permet ainsi de choisir la solution la plus adaptÃ©e en fonction des contraintes de performance.\nComment et pourquoi mesurer la complexitÃ© ? Pour mesurer la complexitÃ© dâ€™un algorithme, on utilise la notation Big O, Ã©crite sous la forme O(f(n)). Elle exprime la croissance du temps ou de la mÃ©moire nÃ©cessaires en fonction de la taille de lâ€™entrÃ©e, gÃ©nÃ©ralement notÃ©e n.\nLe but de cette notation est de mettre en Ã©vidence le comportement asymptotique : comment lâ€™algorithme Ã©volue lorsque n devient trÃ¨s grand. On ignore donc les dÃ©tails secondaires (constantes et termes mineurs) pour ne retenir que le terme dominant. Par exemple, une complexitÃ© exacte de 3nÂ² + 5n + 7 se rÃ©sume en O(nÂ²), puisque nÂ² domine pour de grandes valeurs de n.\nUn programme qui fonctionne nâ€™est pas forcÃ©ment efficace.\nExemple concret :\nRechercher un mot dans un dictionnaire papier (O(log n)). Rechercher une photo dans une pile dÃ©sordonnÃ©e (O(n)). Plus les donnÃ©es sont grosses, plus le choix de lâ€™algorithme est critique.\nNotation Big-O (pire cas) La notation Big-O dÃ©crit comment le temps dâ€™exÃ©cution Ã©volue en fonction de la taille de lâ€™entrÃ©e (n).\nComplexitÃ© Exemple InterprÃ©tation O(1) AccÃ¨s Ã  un tableau par index Constant O(log n) Recherche binaire Logarithmique : croissance lente O(n) Parcours dâ€™une liste LinÃ©aire O(n log n) Tri rapide/merge sort Plus rapide que O(nÂ²) O(nÂ²) Doubles boucles imbriquÃ©es Quadratique : explose vite O(2^n) ProblÃ¨mes combinatoires Exponentielle : impraticable ğŸ’¡ RÃ¨gle dâ€™or :\nPour n petit, toutes les mÃ©thodes semblent rapides. Pour n grand, seules les bonnes structures/algorithmes tiennent la route. Exemples en Java ğŸ”¹ O(1) â€“ Affichage simple public static void affiche(int[] tab) { // O(1) System.out.println(tab[0]); }\rAussi :\npublic static void affiche(int[] tab) { // O(2) qui sera simplifÃ©e Ã  O(1) System.out.println(tab[0]); System.out.println(tab[1]); }\rğŸ”¹ O(n) â€“ Boucle (itÃ©ration sur tous les Ã©lements) public static void afficheTableau(int[] tab) { // O(n) for (int num : tab) { System.out.println(num); } }\rMÃªme chose pour les boucles for, while et do while\nğŸ”¹ O(n ^ 2) â€“ Boucle inbriquÃ©e public static void afficheTableau2D(int[] tab) { // O(n ^ 2) for (int num1 : tab) { for (int num2 : tab) { System.out.println(num1 * num2); } } }\rğŸ”¹ O(log n) â€“ Recherche binaire âš ï¸ NÃ©cessite un tableau triÃ©.\npublic static boolean rechercheBinaire(int[] tab, int val) { int g = 0, d = tab.length - 1; while (g \u003c= d) { int m = (g + d) / 2; if (tab[m] == val) return true; if (tab[m] \u003c val) g = m + 1; else d = m - 1; } return false; }\rSi nous cherchant dans un tableau dâ€™un million dâ€™Ã©lÃ©ments, 19 comparaisons seront suffusantes pour trouver lâ€™Ã©lÃ©ment recherchÃ©.\nğŸ”¹ Comparaison avec des exemples import java.util.*; public class Bench { public static void main(String[] args) { int n = 1_000_000; int[] tab = new int[n]; for (int i = 0; i \u003c n; i++) tab[i] = i; int cible = n - 1; // Recherche linÃ©aire long t1 = System.nanoTime(); rechercheLineaire(tab, cible); long t2 = System.nanoTime(); System.out.println(\"Lineaire : \" + (t2 - t1) / 1_000_000.0 + \" ms\"); // Recherche binaire long t3 = System.nanoTime(); rechercheBinaire(tab, cible); long t4 = System.nanoTime(); System.out.println(\"Binaire : \" + (t4 - t3) / 1_000_000.0 + \" ms\"); } public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) if (x == val) return true; return false; } public static boolean rechercheBinaire(int[] tab, int val) { int g = 0, d = tab.length - 1; while (g \u003c= d) { int m = (g + d) / 2; if (tab[m] == val) return true; if (tab[m] \u003c val) g = m + 1; else d = m - 1; } return false; } }\rOn peut dire que :\nUn algorithme linÃ©aire, qui met une seconde Ã  traiter un tableau Ã  100 Ã©lÃ©ments, mettra 100 secondes Ã  traiter un tableau Ã  10 000 Ã©lÃ©ments. Un algorithme quadratique qui met Ã©galement une seconde Ã  traiter le cas dâ€™un tableau Ã  100 Ã©lÃ©ments mettra 10 000 secondes (soit prÃ¨s de trois heures) Ã  traiter le cas du tableau Ã  10 000 Ã©lÃ©ments. Un algorithme en O(2n) qui mettrait aussi une seconde avec 100 Ã©lÃ©ments qui mettrait 2100 secondes Ã  traiter ne serait-ce que 200 Ã©lÃ©ments, soit environ 4.1022 annÃ©es (4000 milliards de milliards dâ€™annÃ©es). Analyse de boucles Boucle simple for (int i=0; i\u003cn; i++) â†’ O(n). Boucles imbriquÃ©es for i, for j â†’ O(nÂ²). Boucle divisant par 2 while (n \u003e 1) n/=2 â†’ O(log n). ComplexitÃ© spatiale (mÃ©moire) La complexitÃ© spatiale (ou complexitÃ© mÃ©moire) mesure la quantitÃ© de mÃ©moire nÃ©cessaire pour exÃ©cuter un algorithme en fonction de la taille de lâ€™entrÃ©e (n).\nğŸ’¡ On ne parle pas seulement de la mÃ©moire des donnÃ©es initiales, mais aussi :\nde la mÃ©moire supplÃ©mentaire utilisÃ©e par lâ€™algorithme (variables, structures temporaires, pile dâ€™appels).\nO(1) : pile, file, liste chaÃ®nÃ©e â†’ mÃ©moire proportionnelle aux donnÃ©es. O(n) : tableau de n Ã©lÃ©ments. O(nÂ²) : matrice dâ€™adjacence pour un graphe. Exemple 1 : ComplexitÃ© spatiale O(1)\npublic static void afficheTableau(int[] tab) { // O(1) space for (int num : tab) { System.out.println(num); } }\rExemple 2 : ComplexitÃ© spatiale O(n)\npublic static void afficheTableau(int[] tab) { // O(n) space (c'est l'espace qu'on a allouÃ© Ã  l'iterieur de cette mÃ©thode) int[] tabCopy = new int[tab.length]; for (int num : tab) { System.out.println(num); } }\rExemple 3 : ComplexitÃ© spatiale O(n) (rÃ©cursion)\npublic static int factoriel(int n) { // O(n) space if (n == 0) return 1; return n * factoriel(n - 1); }\rExercices Quelle est la complexitÃ© de :\nfor (int i=0; i\u003cn; i++) for (int j=0; j\u003cn; j++) System.out.println(i + \",\" + j);\rQuelle est la complexitÃ© de :\nfor (int i=0; i\u003cn; i*=2) System.out.println(i);\rQuelle est la complexitÃ© spatiale dâ€™un tableau int[1000][1000] ?\nFiche synthÃ¨se ComplexitÃ© temporelle â†’ combien de temps Ã§a prend.\nComplexitÃ© spatiale â†’ combien de mÃ©moire Ã§a utilise.\nParfois, il faut choisir :\nMoins de temps mais plus de mÃ©moire (ex. table de hachage).\nMoins de mÃ©moire mais plus de temps (ex. recherche linÃ©aire dans une liste).\nOn utilise la notion grand O (Big O) pour mesurer la complexitÃ© :\nO(1) : accÃ¨s direct. O(log n) : recherche dichotomique, arbres Ã©quilibrÃ©s. O(n) : parcours dâ€™une collection. O(n log n) : tris efficaces. O(nÂ²) : algorithmes naÃ¯fs Ã  doubles boucles. O(2^n) : problÃ¨mes combinatoires â†’ Ã  Ã©viter.",
    "description": "Quâ€™est-ce que la complexitÃ© algorithmique ? La complexitÃ© algorithmique dÃ©signe en informatique la quantitÃ© de ressources quâ€™un algorithme consomme lors de son exÃ©cution (On utilise Grand O pour dÃ©crire la performance dâ€™une algorithme). Elle se dÃ©cline en deux dimensions principales :\nLa complexitÃ© temporelle, qui mesure le temps dâ€™exÃ©cution. La complexitÃ© spatiale, qui Ã©value la mÃ©moire supplÃ©mentaire requise en dehors des donnÃ©es dâ€™entrÃ©e. Ces deux aspects sont indÃ©pendants : un algorithme peut Ãªtre trÃ¨s rapide mais consommer beaucoup de mÃ©moire, ou inversement.",
    "tags": [],
    "title": "ComplexitÃ© algorithmique",
    "uri": "/420-311/complexalgo/complexalgo/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Algorithmes de recherche et de tri",
    "content": "1. Notion de recherche dans un tableau La recherche consiste Ã  trouver la position dâ€™un Ã©lÃ©ment dans une collection de donnÃ©es (tableau, liste, etc.). On peut la classer en deux grandes familles :\nType de recherche Condition prÃ©alable ComplexitÃ© moyenne Exemple LinÃ©aire (sÃ©quentielle) Aucune (tableau non triÃ©) O(n) Parcourir un tableau dâ€™Ã©tudiants Binaire (dichotomique) Tableau triÃ© O(log n) Recherche dans un dictionnaire ğŸ”¹ 2. Recherche linÃ©aire La recherche linÃ©aire (sÃ©quentielle) compare les diffÃ©rents Ã©lÃ©ments dâ€™un tableau Ã  lâ€™Ã©lÃ©ment recherchÃ©. Cet algorithme fonctionne bien pour les petits tableaux ou pour les tableaux non triÃ©s. Cet algorithme retourne la position de lâ€™Ã©lÃ©ment.\nPrincipe On parcourt le tableau du dÃ©but Ã  la fin jusquâ€™Ã  trouver la valeur recherchÃ©e. Si elle est trouvÃ©e â†’ on retourne sa position. Sinon â†’ on retourne -1.\nExemple visuel Tableau : [5, 12, 8, 21, 3] Recherche : 8 â†’ Compare 5 â‰  8 â†’ Compare 12 â‰  8 â†’ Compare 8 = 8 âœ… trouvÃ© Ã  lâ€™indice 2\rExemple Java public class RechercheLineaire { public static int rechercheLineaire(int[] tableau, int valeur) { for (int i = 0; i \u003c tableau.length; i++) { if (tableau[i] == valeur) { return i; // trouvÃ© } } return -1; // non trouvÃ© } public static void main(String[] args) { int[] tab = {5, 12, 8, 21, 3}; int resultat = rechercheLineaire(tab, 8); System.out.println(resultat \u003e= 0 ? \"TrouvÃ© Ã  la position \" + resultat : \"Non trouvÃ©\"); } }\râ±ï¸ ComplexitÃ© Meilleur cas : O(1) â†’ si lâ€™Ã©lÃ©ment est au dÃ©but. Pire cas : O(n) â†’ si lâ€™Ã©lÃ©ment est absent. Moyenne : O(n/2) â‰ˆ O(n). ğŸ”¹ 3. Recherche binaire (ou dichotomique) La recherche binaire ou recherche dichotomique nâ€™est applicable que si le tableau a Ã©tÃ© triÃ© auparavant. Cet algorithme commence par lâ€™Ã©lÃ©ment central et le compare Ã  lâ€™Ã©lÃ©ment recherchÃ©.\nSi les deux valeurs sont Ã©gales alors la valeur de lâ€™indice (la position) est retournÃ©e. Si lâ€™Ã©lÃ©ment recherchÃ© est infÃ©rieur, la recherche est poursuivie de maniÃ¨re analogue dans la premiÃ¨re partie du tableau. Sinon elle est supÃ©rieure et la recherche se poursuit dans seconde partie du tableau. La recherche continue jusquâ€™Ã  ce que lâ€™Ã©lÃ©ment recherchÃ© soit Ã©gal Ã  lâ€™Ã©lÃ©ment central dâ€™un sous tableau ou jusquâ€™Ã  ce que le sous-tableau comporte un Ã©lÃ©ment dont la valeur diffÃ¨re de celle de lâ€™Ã©lÃ©ment recherchÃ© câ€™est-Ã -dire que lâ€™Ã©lÃ©ment recherchÃ© nâ€™a pas Ã©tÃ© trouvÃ©. Cet algorithme retourne la position de lâ€™Ã©lÃ©ment.\nPrincipe Applicable uniquement sur un tableau triÃ©. On divise le tableau en deux Ã  chaque Ã©tape :\nOn compare lâ€™Ã©lÃ©ment central Ã  la valeur recherchÃ©e. Si Ã©gal â†’ trouvÃ©. Si plus petit â†’ on cherche dans la moitiÃ© droite. Si plus grand â†’ on cherche dans la moitiÃ© gauche. Exemple visuel Tableau triÃ© : [3, 5, 8, 12, 21, 32] Recherche : 12 â†’ Milieu = 8 â†’ trop petit â†’ Nouvelle zone : [12, 21, 32] â†’ Milieu = 21 â†’ trop grand â†’ Nouvelle zone : [12] â†’ TrouvÃ© âœ…\rPseudo-code :\nProcÃ©dure rechercheBinaire (tableau dâ€™entiers, entier elementARechercher) { On dÃ©clare un entier premier = 0 ; On dÃ©clare un entier position = la taille du tableau passÃ© en paramÃ¨tre Tant que (premier \u003c position) { Entier milieu = (premier + taille) / 2 Si (elementARechercher \u003c (tableau [milieu])) { position = milieu ; } Sinon Si (elementARechercher \u003e (tableau [milieu])) { premier = milieu + 1 ; } Sinon { Retourner milieu ; } } Retourner â€“ (premier + 1) ; }\rExemple Java public class RechercheBinaire { public static int rechercheBinaire(int[] tab, int valeur) { int debut = 0; int fin = tab.length - 1; while (debut \u003c= fin) { int milieu = (debut + fin) / 2; if (tab[milieu] == valeur) return milieu; else if (tab[milieu] \u003c valeur) debut = milieu + 1; else fin = milieu - 1; } return -1; } public static void main(String[] args) { int[] tab = {3, 5, 8, 12, 21, 32}; int resultat = rechercheBinaire(tab, 12); System.out.println(resultat \u003e= 0 ? \"TrouvÃ© Ã  la position \" + resultat : \"Non trouvÃ©\"); } }\râ±ï¸ ComplexitÃ© Meilleur cas : O(1) Pire cas : O(logâ‚‚ n) Avantage : beaucoup plus rapide pour les grands ensembles triÃ©s. ğŸ” 4. Comparaison entre les deux algorithmes CritÃ¨re Recherche linÃ©aire Recherche binaire NÃ©cessite un tri prÃ©alable Non Oui Temps moyen O(n) O(log n) FacilitÃ© dâ€™implÃ©mentation TrÃ¨s simple Moyenne Efficace pour grands tableaux triÃ©s âŒ Non âœ… Oui Fonctionne pour tableaux non triÃ©s âœ… Oui âŒ Non",
    "description": "1. Notion de recherche dans un tableau La recherche consiste Ã  trouver la position dâ€™un Ã©lÃ©ment dans une collection de donnÃ©es (tableau, liste, etc.). On peut la classer en deux grandes familles :\nType de recherche Condition prÃ©alable ComplexitÃ© moyenne Exemple LinÃ©aire (sÃ©quentielle) Aucune (tableau non triÃ©) O(n) Parcourir un tableau dâ€™Ã©tudiants Binaire (dichotomique) Tableau triÃ© O(log n) Recherche dans un dictionnaire ğŸ”¹ 2. Recherche linÃ©aire La recherche linÃ©aire (sÃ©quentielle) compare les diffÃ©rents Ã©lÃ©ments dâ€™un tableau Ã  lâ€™Ã©lÃ©ment recherchÃ©. Cet algorithme fonctionne bien pour les petits tableaux ou pour les tableaux non triÃ©s. Cet algorithme retourne la position de lâ€™Ã©lÃ©ment.",
    "tags": [],
    "title": "ğŸ“˜ Chapitre : Les algorithmes de recherche",
    "uri": "/420-311/algosearchsort/algosearch/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Algorithmes de recherche et de tri",
    "content": "Capsule dâ€™introduction aux algorithmes de tri Les Algorithmes de Tri Simples (ComplexitÃ© Quadratique) Ce groupe dâ€™algorithmes, bien que souvent moins performants avec une complexitÃ© de O(nÂ²), est fondamental pour comprendre les principes de base du tri. Leur simplicitÃ© conceptuelle en fait un excellent point de dÃ©part pour quiconque sâ€™initie aux structures de donnÃ©es et aux algorithmes.\nTri Ã  bulles (Bubble Sort) Le tri Ã  bulles ou tri par propagation ou permutation est un algorithme de tri qui consiste Ã  faire remonter progressivement les plus grands Ã©lÃ©ments dâ€™un tableau, comme les bulles dâ€™air remontent Ã  la surface dâ€™un liquide.\nLe tri Ã  bulles est souvent enseignÃ© en tant quâ€™exemple algorithmique. Cependant, sa complexitÃ© est de lâ€™ordre de nÂ² en moyenne (oÃ¹ n est la taille du tableau), ce qui le classe parmi les mauvais algorithmes de tri. Il nâ€™est donc quasiment pas utilisÃ© en pratique.\nPrincipe : Comparer chaque paire dâ€™Ã©lÃ©ments consÃ©cutifs et les Ã©changer si nÃ©cessaire. Les plus grands â€œremontentâ€ vers la fin du tableau.\nExemple de Fonctionnement: Prenons lâ€™exemple du tableau [8, 2, 4, 1, 3].\nPremier Passage : Compare 8 et 2. 2 \u003c 8, donc on permute : [2, 8, 4, 1, 3] Compare 8 et 4. 4 \u003c 8, donc on permute : [2, 4, 8, 1, 3] Compare 8 et 1. 1 \u003c 8, donc on permute : [2, 4, 1, 8, 3] Compare 8 et 3. 3 \u003c 8, donc on permute : [2, 4, 1, 3, 8] Ã€ la fin de ce passage, le plus grand Ã©lÃ©ment, 8, est Ã  sa position correcte. DeuxiÃ¨me Passage : Compare 2 et 4. Pas de permutation. [2, 4, 1, 3, 8] Compare 4 et 1. 1 \u003c 4, donc on permute : [2, 1, 4, 3, 8] Compare 4 et 3. 3 \u003c 4, donc on permute : [2, 1, 3, 4, 8] Ã€ la fin de ce passage, le deuxiÃ¨me plus grand Ã©lÃ©ment, 4, est Ã  sa position correcte. ComplexitÃ© :\nPire cas : O(nÂ²) Meilleur cas (dÃ©jÃ  triÃ©) : O(n) Exemple Java :\npublic class TriBulle { public static void trier(int[] tab) { boolean echange; do { echange = false; for (int i = 0; i \u003c tab.length - 1; i++) { if (tab[i] \u003e tab[i + 1]) { int tmp = tab[i]; tab[i] = tab[i + 1]; tab[i + 1] = tmp; echange = true; } } } while (echange); } }\rTri par sÃ©lection (Selection Sort) Le tri par sÃ©lection (ou tri par extraction) est un algorithme de tri par comparaison. Il est particuliÃ¨rement simple, mais inefficace sur de grandes entrÃ©es, car il sâ€™exÃ©cute en temps quadratique en le nombre dâ€™Ã©lÃ©ments Ã  trier.\nSur un tableau de n Ã©lÃ©ments (numÃ©rotÃ©s de 1 Ã  n), le principe du tri par sÃ©lection est le suivant :\nRechercher le plus petit Ã©lÃ©ment du tableau, et lâ€™Ã©changer avec lâ€™Ã©lÃ©ment dâ€™indice 1 ; Rechercher le second plus petit Ã©lÃ©ment du tableau, et lâ€™Ã©changer avec lâ€™Ã©lÃ©ment dâ€™indice 2 ; Continuer de cette faÃ§on jusquâ€™Ã  ce que le tableau soit entiÃ¨rement triÃ©. si t[j] \u003c t [min], alors min â† j si min â‰  i, alors Ã©changer t[i] et t [min] Principe : Trouver le plus petit Ã©lÃ©ment du tableau et le placer au dÃ©but. RÃ©pÃ©ter pour le reste du tableau.\nComplexitÃ© :\nTous les cas : O(nÂ²) Mais peu dâ€™Ã©changes (nâˆ’1 au total). Exemple Java :\npublic class TriSelection { public static void trier(int[] tab) { for (int i = 0; i \u003c tab.length - 1; i++) { int min = i; for (int j = i + 1; j \u003c tab.length; j++) { if (tab[j] \u003c tab[min]) { min = j; } } int tmp = tab[i]; tab[i] = tab[min]; tab[min] = tmp; } } }\rTri par insertion (Insertion Sort) Le tri par insertion est un algorithme de tri classique dont le principe est trÃ¨s simple. Câ€™est le tri que la plupart des personnes utilisent naturellement pour trier des cartes : prendre les cartes mÃ©langÃ©es une Ã  une sur la table, et former une main en insÃ©rant chaque carte Ã  sa place.\nEn gÃ©nÃ©ral, le tri par insertion est beaucoup plus lent que dâ€™autres, car sa complexitÃ© asymptotique est quadratique.\nLe tri par insertion est cependant considÃ©rÃ© comme le tri le plus efficace sur des entrÃ©es de petite taille. Il est aussi trÃ¨s rapide lorsque les donnÃ©es sont dÃ©jÃ  presque triÃ©es. Pour ces raisons, il est utilisÃ© en pratique en combinaison avec dâ€™autres mÃ©thodes comme le tri rapide (ou Quick sort).\nEn programmation informatique, on applique le plus souvent ce tri Ã  des tableaux.\nPrincipe : On insÃ¨re progressivement chaque Ã©lÃ©ment Ã  sa place dans la partie dÃ©jÃ  triÃ©e.\nComplexitÃ© :\nPire cas : O(nÂ²) (tableau inversÃ©) Meilleur cas : O(n) (tableau dÃ©jÃ  triÃ©) Exemple Java :\npublic class TriInsertion { public static void trier(int[] tab) { for (int i = 1; i \u003c tab.length; i++) { int x = tab[i]; int j = i - 1; while (j \u003e= 0 \u0026\u0026 tab[j] \u003e x) { tab[j + 1] = tab[j]; j--; } tab[j + 1] = x; } } }\rBien que ces algorithmes simples offrent une base solide, leur complexitÃ© quadratique les rend peu pratiques pour les grands ensembles de donnÃ©es. Cela nous amÃ¨ne Ã  explorer une classe dâ€™algorithmes plus efficaces, conÃ§us pour gÃ©rer de plus grands volumes dâ€™informations.\nLes Algorithmes de tri efficaces (complexitÃ© logarithmique) Les algorithmes de cette catÃ©gorie, tels que le tri par fusion et le tri rapide, utilisent des stratÃ©gies plus avancÃ©es comme lâ€™approche â€œdiviser pour rÃ©gnerâ€ pour atteindre une complexitÃ© temporelle de O(n log n). Cette performance les rend nettement plus rapides et plus Ã©volutifs que les algorithmes quadratiques, en particulier pour les grands ensembles de donnÃ©es.\nTri par fusion (Merge Sort) Le tri par fusion est un exemple classique de lâ€™approche â€œdiviser pour rÃ©gnerâ€. Il est rÃ©cursif et garantit une performance stable.\nPrincipe\nLâ€™algorithme fonctionne en deux phases distinctes :\nPhase de Division : Le tableau est divisÃ© rÃ©cursivement en deux moitiÃ©s jusquâ€™Ã  ce que lâ€™on obtienne des sous-tableaux ne contenant quâ€™un seul Ã©lÃ©ment. Un tableau dâ€™un seul Ã©lÃ©ment est, par dÃ©finition, dÃ©jÃ  triÃ©. Phase de fusion : Les sous-tableaux triÃ©s sont ensuite fusionnÃ©s deux par deux de maniÃ¨re ordonnÃ©e. Lors de la fusion, les Ã©lÃ©ments des deux sous-tableaux sont comparÃ©s et placÃ©s dans un nouveau tableau dans le bon ordre, crÃ©ant ainsi un tableau plus grand qui est Ã©galement triÃ©. Ce processus se poursuit jusquâ€™Ã  ce que tous les sous-tableaux aient Ã©tÃ© fusionnÃ©s en un seul tableau final triÃ©. ComplexitÃ© temporelle et spatiale\nComplexitÃ© temporelle : O(n log n). La division rÃ©cursive du tableau en moitiÃ©s produit log n niveaux de division. Ã€ chaque niveau, la phase de fusion nÃ©cessite de parcourir tous les n Ã©lÃ©ments pour les combiner en sous-tableaux triÃ©s. Le travail n effectuÃ© log n fois donne une complexitÃ© temporelle de O(n log n) dans tous les cas. ComplexitÃ© spatiale : O(n). Le principal inconvÃ©nient du tri par fusion est sa consommation de mÃ©moire. Des tableaux temporaires sont nÃ©cessaires pour stocker les sous-tableaux pendant les phases de division et de fusion. Ce coÃ»t en mÃ©moire est le compromis nÃ©cessaire pour garantir la vitesse et la stabilitÃ© de lâ€™algorithme. Tri rapide (Quicksort) Le tri rapide est lâ€™un des algorithmes de tri les plus utilisÃ©s en pratique et constitue la base des fonctions de tri intÃ©grÃ©es dans de nombreux langages et frameworks, comme Arrays.sort en Java.\nPrincipe\nLe tri rapide est Ã©galement un algorithme de type â€œdiviser pour rÃ©gnerâ€. Son mÃ©canisme central repose sur les Ã©tapes suivantes :\nChoix du pivot : Un Ã©lÃ©ment du tableau est sÃ©lectionnÃ© comme â€œpivotâ€. Le choix du pivot peut varier (premier, dernier ou un Ã©lÃ©ment alÃ©atoire). Partitionnement : Le tableau est rÃ©organisÃ© de telle sorte que tous les Ã©lÃ©ments plus petits que le pivot se retrouvent Ã  sa gauche, et tous les Ã©lÃ©ments plus grands se retrouvent Ã  sa droite. AprÃ¨s cette Ã©tape, le pivot se trouve Ã  sa position finale correcte dans le tableau triÃ©. RÃ©cursion : Le processus de partitionnement est rÃ©pÃ©tÃ© rÃ©cursivement sur les deux sous-tableaux (celui Ã  gauche du pivot et celui Ã  droite). Il est important de noter que le tri rapide est un algorithme instable, car les permutations dâ€™Ã©lÃ©ments Ã©loignÃ©s peuvent modifier lâ€™ordre relatif des Ã©lÃ©ments de mÃªme valeur.\nComplexitÃ© temporelle et spatiale\nComplexitÃ© temporelle : O(n log n). En moyenne et dans le meilleur des cas, le tri rapide atteint cette complexitÃ© quasi-linÃ©aire trÃ¨s efficace. ComplexitÃ© spatiale : O(log n). Un avantage clÃ© du tri rapide est quâ€™il trie â€œen placeâ€, sans nÃ©cessiter de tableau auxiliaire pour les donnÃ©es. Cependant, il nâ€™a pas une complexitÃ© spatiale de O(1). Lâ€™espace est requis par la pile dâ€™appels rÃ©cursifs, dont la profondeur est en moyenne de O(log n), ce qui le rend trÃ¨s efficace en termes de mÃ©moire. Les algorithmes abordÃ©s jusquâ€™Ã  prÃ©sent reposent tous sur la comparaison directe des Ã©lÃ©ments pour dÃ©terminer leur ordre. Cependant, une autre catÃ©gorie dâ€™algorithmes adopte une approche fondamentalement diffÃ©rente, qui peut sâ€™avÃ©rer encore plus rapide dans des conditions spÃ©cifiques.\nLes Algorithmes de tri non basÃ©s sur la comparaison Contrairement aux algorithmes prÃ©cÃ©dents, cette catÃ©gorie ne compare pas les Ã©lÃ©ments entre eux. Ils exploitent plutÃ´t des propriÃ©tÃ©s mathÃ©matiques des donnÃ©es, comme leur valeur numÃ©rique, pour les classer. Sous certaines conditions, ces algorithmes peuvent atteindre une complexitÃ© linÃ©aire, surpassant ainsi les algorithmes basÃ©s sur la comparaison.\nTri par comptage (Counting Sort) Cet algorithme est particuliÃ¨rement efficace pour trier des entiers dans une plage de valeurs limitÃ©e.\nPrincipe\nLe tri par comptage fonctionne en dÃ©terminant le nombre dâ€™occurrences de chaque Ã©lÃ©ment dans le tableau dâ€™entrÃ©e. Ce dÃ©compte est stockÃ© dans un tableau auxiliaire, souvent appelÃ© tableau de â€œcomptesâ€. Lâ€™index de ce tableau correspond Ã  la valeur de lâ€™Ã©lÃ©ment, et la valeur Ã  cet index correspond Ã  sa frÃ©quence. Ensuite, ce tableau de comptes est utilisÃ© pour reconstruire le tableau original en plaÃ§ant chaque Ã©lÃ©ment le bon nombre de fois dans lâ€™ordre croissant.\nContraintes et cas dâ€™usage\nHypothÃ¨se clÃ© : Les valeurs dâ€™entrÃ©e doivent Ãªtre des entiers positifs dans une plage connue et relativement petite (de 0 Ã  k). Gaspillage de mÃ©moire : Lâ€™algorithme devient inefficace si la plage des valeurs (k) est trÃ¨s grande par rapport au nombre dâ€™Ã©lÃ©ments (n). Par exemple, trier quelques nombres dont lâ€™un est 1 000 000 nÃ©cessiterait un tableau de comptes dâ€™un million dâ€™Ã©lÃ©ments, ce qui gaspillerait beaucoup de mÃ©moire. Cas dâ€™usage idÃ©al : Il est le plus adaptÃ© lorsque la plupart des valeurs de la plage sont prÃ©sentes dans le tableau dâ€™entrÃ©e, minimisant ainsi les â€œtrousâ€ (valeurs nulles) dans le tableau de comptes. ComplexitÃ© et compromis temps-mÃ©moire\nComplexitÃ© temporelle : O(n + k). Si la plage k nâ€™est pas significativement plus grande que le nombre dâ€™Ã©lÃ©ments n, la complexitÃ© se simplifie en O(n), soit un temps linÃ©aire. ComplexitÃ© spatiale : O(k). Lâ€™algorithme nÃ©cessite un espace mÃ©moire supplÃ©mentaire pour le tableau de comptes, dont la taille dÃ©pend de la valeur maximale k. Ceci illustre un concept clÃ© en informatique : le compromis temps-mÃ©moire. Le tri par comptage atteint sa vitesse exceptionnelle en utilisant de la mÃ©moire supplÃ©mentaire. Tri par paquets (Bucket Sort) Le tri par paquets gÃ©nÃ©ralise lâ€™idÃ©e du tri par comptage en distribuant les Ã©lÃ©ments dans plusieurs â€œpaquetsâ€.\nPrincipe\nLe processus se dÃ©roule en trois Ã©tapes :\nDistribution : Les Ã©lÃ©ments du tableau dâ€™entrÃ©e sont rÃ©partis dans un nombre prÃ©dÃ©fini de â€œpaquetsâ€ (buckets). Pour dÃ©terminer dans quel paquet un Ã©lÃ©ment doit aller, on peut utiliser une formule simple, comme diviser la valeur de lâ€™Ã©lÃ©ment par le nombre de paquets. Tri : Chaque paquet est ensuite triÃ© individuellement. Un autre algorithme de tri, comme le tri par insertion, est gÃ©nÃ©ralement utilisÃ© pour cette Ã©tape, car il est efficace sur de petits ensembles de donnÃ©es. Combinaison : Enfin, les Ã©lÃ©ments des paquets triÃ©s sont concatÃ©nÃ©s pour former le tableau final triÃ©. Impact du nombre de paquets\nLa performance du tri par paquets est directement liÃ©e au nombre de paquets utilisÃ©s. Plus il y a de paquets, plus chaque paquet contient peu dâ€™Ã©lÃ©ments, ce qui rend leur tri individuel plus rapide. Cependant, un grand nombre de paquets augmente la consommation de mÃ©moire.\nComplexitÃ© et compromis temps-mÃ©moire\nComplexitÃ© temporelle : O(n) Ã  O(nÂ²). Dans le meilleur des cas, si les Ã©lÃ©ments sont rÃ©partis de maniÃ¨re uniforme dans les paquets, la complexitÃ© peut Ãªtre linÃ©aire, soit O(n). Dans le pire des cas, si tous les Ã©lÃ©ments tombent dans le mÃªme paquet, la complexitÃ© devient celle de lâ€™algorithme de tri sous-jacent (par exemple, O(nÂ²) si le tri par insertion est utilisÃ©). ComplexitÃ© spatiale : O(n + k), oÃ¹ n est le nombre dâ€™Ã©lÃ©ments et k le nombre de paquets. Cet algorithme est un autre exemple clair du compromis temps-mÃ©moire, oÃ¹ lâ€™on sacrifie de la mÃ©moire pour obtenir une exÃ©cution plus rapide. âš™ï¸ Exemple de fonctionnement ğŸ§© 1. Tri par fusion (Merge Sort) ğŸ”¹ Ã‰tapes 1ï¸âƒ£ Diviser le tableau :\n[8, 2, 4, 1, 3] â†’ [8, 2] et [4, 1, 3]\r2ï¸âƒ£ Diviser Ã  nouveau :\n[8, 2] â†’ [8] et [2] [4, 1, 3] â†’ [4] et [1, 3] â†’ [1] et [3]\r3ï¸âƒ£ Fusionner en triant :\nFusion [8] et [2] â†’ [2, 8] Fusion [1] et [3] â†’ [1, 3] Fusion [4] et [1, 3] â†’ [1, 3, 4] Fusion [2, 8] et [1, 3, 4] â†’ [1, 2, 3, 4, 8]\râœ… RÃ©sultat final : [1, 2, 3, 4, 8]\nğŸ’¡ Visualisation [8, 2, 4, 1, 3] / \\ [8, 2] [4, 1, 3] / \\ / \\ [8] [2] [4] [1, 3] \\ / [1, 3, 4] â†’ Fusion finale â†’ [1, 2, 3, 4, 8]\râš¡ 2. Tri rapide (Quick Sort) ğŸ”¹ Ã‰tapes 1ï¸âƒ£ Choisir un pivot (dernier Ã©lÃ©ment, ici 3) â†’ Partitionner : Ã©lÃ©ments \u003c 3 Ã  gauche, \u003e 3 Ã  droite\n[8, 2, 4, 1, 3] â†’ [2, 1] [3] [8, 4]\r2ï¸âƒ£ Appliquer rÃ©cursivement :\n[2, 1] pivot 1 â†’ [1] [2] [8, 4] pivot 4 â†’ [4] [8] 3ï¸âƒ£ Combiner :\n[1, 2] + [3] + [4, 8] = [1, 2, 3, 4, 8]\râœ… RÃ©sultat final : [1, 2, 3, 4, 8]\nğŸ’¡ Visualisation Pivot = 3 [8, 2, 4, 1, 3] â†’ [2, 1] [3] [8, 4] [2, 1] â†’ [1, 2] [8, 4] â†’ [4, 8] RÃ©sultat : [1, 2, 3, 4, 8]\rğŸ”¢ 3. Tri par comptage (Counting Sort) ğŸ”¹ Ã‰tapes 1ï¸âƒ£ Trouver la valeur max â†’ 8 2ï¸âƒ£ CrÃ©er un tableau de comptage de 0 Ã  8 :\ncompte = [0,0,0,0,0,0,0,0,0]\r3ï¸âƒ£ Compter les occurrences :\n[8, 2, 4, 1, 3] â†’ compte = [0,1,1,1,1,0,0,0,1]\r4ï¸âƒ£ Reconstruire le tableau triÃ© :\nâ†’ [1, 2, 3, 4, 8]\râœ… RÃ©sultat final : [1, 2, 3, 4, 8]\nğŸ’¡ Visualisation Valeur : 0 1 2 3 4 5 6 7 8 Occurrences : 0 1 1 1 1 0 0 0 1 RÃ©sultat : [1, 2, 3, 4, 8]\rğŸª£ 4. Tri par paquets (Bucket Sort) (exemple simplifiÃ© avec 5 seaux pour des entiers entre 1 et 8)\nğŸ”¹ Ã‰tapes 1ï¸âƒ£ CrÃ©er des seaux (buckets) :\n[8, 2, 4, 1, 3] â†’ 5 seaux : [ ] [ ] [ ] [ ] [ ]\r2ï¸âƒ£ Distribuer selon la valeur :\n1 â†’ seau 0 2 â†’ seau 0 3 â†’ seau 1 4 â†’ seau 2 8 â†’ seau 4 Buckets :\n[1,2] [3] [4] [] [8]\r3ï¸âƒ£ Trier chaque seau (dÃ©jÃ  petit, donc insertion sort ou rien)\n4ï¸âƒ£ Fusionner :\n[1, 2] + [3] + [4] + [] + [8] = [1, 2, 3, 4, 8]\râœ… RÃ©sultat final : [1, 2, 3, 4, 8]\nğŸ’¡ Visualisation Seau 0 : [1, 2] Seau 1 : [3] Seau 2 : [4] Seau 3 : [] Seau 4 : [8] â†’ Fusion : [1, 2, 3, 4, 8]\rRÃ©sumÃ© du fonctionnement global Algorithme MÃ©thode Ã‰tapes clÃ©s RÃ©sultat final MergeSort Diviser + Fusionner DÃ©couper et recombiner triÃ© [1, 2, 3, 4, 8] QuickSort Pivot + Partition Trier rÃ©cursivement autour du pivot [1, 2, 3, 4, 8] CountingSort Compter les occurrences Tableau de comptage [1, 2, 3, 4, 8] BucketSort Classer dans des seaux Distribution + tri local [1, 2, 3, 4, 8] Tableau rÃ©capitulatif et Conclusion SynthÃ¨se des algorithmes Le tableau ci-dessous rÃ©sume les caractÃ©ristiques clÃ©s des algorithmes de tri abordÃ©s.\nAlgorithme ComplexitÃ© Temporelle (Pire Cas) ComplexitÃ© Temporelle (Meilleur Cas) ComplexitÃ© spatiale StabilitÃ© Tri Ã  Bulles O(nÂ²) O(n) En place (O(1)) Tri par SÃ©lection O(nÂ²) O(nÂ²) En place (O(1)) Instable Tri par Insertion O(nÂ²) O(n) En place (O(1)) Stable Tri par Fusion O(n log n) O(n log n) O(n) Tri Rapide O(n log n) O(n log n) O(log n) Instable Tri par Comptage O(n + k) O(n + k) O(k) Tri par Paquets O(nÂ²) O(n) O(n + k) Conclusion Comprendre les diffÃ©rents algorithmes de tri est une compÃ©tence essentielle pour tout informaticien. Comme nous lâ€™avons vu, il nâ€™existe pas dâ€™algorithme â€œparfaitâ€ pour toutes les situations. Le choix optimal dÃ©pend des contraintes spÃ©cifiques du problÃ¨me. Ce guide a mis en lumiÃ¨re le compromis fondamental entre le temps et la mÃ©moire : des algorithmes comme le tri par fusion ou le tri par comptage garantissent une grande vitesse au prix dâ€™une consommation mÃ©moire plus Ã©levÃ©e, tandis que le tri rapide offre une excellente performance moyenne tout en opÃ©rant en place. De mÃªme, le choix dÃ©pend des garanties de performance requises. Le tri par fusion offre une complexitÃ© prÃ©visible de O(n log n), tandis que la performance du tri rapide et du tri par paquets peut se dÃ©grader considÃ©rablement dans le pire des cas, en fonction des donnÃ©es dâ€™entrÃ©e. MaÃ®triser ces nuances permet de concevoir des solutions logicielles non seulement correctes, mais aussi vÃ©ritablement efficaces et adaptÃ©es au contexte dâ€™exÃ©cution.",
    "description": "Capsule dâ€™introduction aux algorithmes de tri Les Algorithmes de Tri Simples (ComplexitÃ© Quadratique) Ce groupe dâ€™algorithmes, bien que souvent moins performants avec une complexitÃ© de O(nÂ²), est fondamental pour comprendre les principes de base du tri. Leur simplicitÃ© conceptuelle en fait un excellent point de dÃ©part pour quiconque sâ€™initie aux structures de donnÃ©es et aux algorithmes.\nTri Ã  bulles (Bubble Sort) Le tri Ã  bulles ou tri par propagation ou permutation est un algorithme de tri qui consiste Ã  faire remonter progressivement les plus grands Ã©lÃ©ments dâ€™un tableau, comme les bulles dâ€™air remontent Ã  la surface dâ€™un liquide.",
    "tags": [],
    "title": "ğŸ“˜ Chapitre : Les algorithmes de tri",
    "uri": "/420-311/algosearchsort/algosort/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Threads",
    "content": "1) De la machine au programme : processeur, multitÃ¢che, multithread 1.1 Processeur, mono-cÅ“ur vs multi-cÅ“urs Monoprocesseur (mono-cÅ“ur) : Ã  un instant donnÃ©, un seul programme tourne sur lâ€™unitÃ© centrale. Lâ€™illusion de simultanÃ©itÃ© vient du systÃ¨me dâ€™exploitation (OS) qui passe la main trÃ¨s vite dâ€™un programme Ã  lâ€™autre (prÃ©emption + quantum de temps). Multiprocesseur / multicÅ“ur : une mÃªme puce contient plusieurs cÅ“urs indÃ©pendants. On peut exÃ©cuter plusieurs threads rÃ©ellement en parallÃ¨le (un par cÅ“ur), ce quâ€™on appelle TLP â€“ Thread Level Parallelism. 1.2 MultitÃ¢che (au niveau OS) Le multitÃ¢che dÃ©signe la capacitÃ© de lâ€™OS Ã  exÃ©cuter (ou donner lâ€™illusion dâ€™exÃ©cuter) plusieurs processus â€œen mÃªme tempsâ€ en partageant le CPU. Sur I/O (clavier, disque, rÃ©seauâ€¦), lâ€™OS profite des attentes dâ€™un programme pour planifier un autre. 1.3 Multithreading (Ã  lâ€™intÃ©rieur dâ€™un processus) Le multithread Ã©tend le multitÃ¢che Ã  lâ€™Ã©chelle dâ€™une application : un processus peut contenir plusieurs threads, chacun Ã©tant un flux dâ€™exÃ©cution. Sur multi-cÅ“urs, des threads peuvent avancer vraiment en parallÃ¨le (TLP). Sur mono-cÅ“ur, on retrouve lâ€™illusion via le time-slicing de lâ€™OS/JVM. 2) Threads, sections critiques, exclusion mutuelle 2.1 DÃ©finitions essentielles Objet critique : ressource non rÃ©entrante/non simultanÃ©ment accessible (imprimante, fichier, structure mÃ©moireâ€¦). Section critique : code qui manipule un objet critique. Sans protection, lâ€™exÃ©cution concurrente peut produire des rÃ©sultats imprÃ©visibles. Exclusion mutuelle : garantir quâ€™au plus un thread exÃ©cute la section critique Ã  un instant donnÃ©. 2.2 ProblÃ¨mes classiques Condition de course (race) : deux threads lisent/modifient un Ã©tat partagÃ© sans coordination â†’ incohÃ©rences. Interblocage (deadlock) : t1 tient le verrou A et attend B, t2 tient B et attend A â†’ attente circulaire infinie. Famine (starvation) / livelock : un thread nâ€™obtient jamais les ressources / tout le monde bouge mais rien nâ€™avance. 3) Le modÃ¨le mÃ©moire Java (JMM) en pratique VisibilitÃ© : quand une Ã©criture par t1 devient visible par t2 ?\nAtomicitÃ© : une opÃ©ration se fait-elle â€œdâ€™un seul coupâ€ ?\nOutils :\nvolatile â‡’ visibilitÃ© garantie (pas dâ€™atomicitÃ©). synchronized / verrous (ReentrantLock) â‡’ exclusion + publication (visibilitÃ©). Types atomiques (AtomicInteger, LongAdder) â‡’ opÃ©rations atomiques sans verrou explicite. 4) Les threads en Java : API, cycle de vie, prioritÃ©s 4.1 CrÃ©er un thread Deux approches idiomatiques :\n// 1) Runnable class Tache implements Runnable { @Override public void run() { /* travail */ } } Thread t = new Thread(new Tache(), \"T1\"); t.start(); // 2) Ã‰tendre Thread class Worker extends Thread { public Worker(String name) { super(name); } @Override public void run() { /* travail */ } } new Worker(\"W1\").start();\rImportant : on nâ€™appelle jamais run() directement pour dÃ©marrer un thread â€” on appelle start() qui confie lâ€™exÃ©cution Ã  la JVM/OS. start() ne peut Ãªtre appelÃ© quâ€™une fois par instance, sinon IllegalThreadStateException.\n4.2 MÃ©thodes essentielles de Thread start() : demande Ã  la JVM dâ€™exÃ©cuter run() dans un nouveau thread. sleep(ms[, ns]) (statique) : endort le thread courant. interrupt() / isInterrupted() / interrupted() : signal dâ€™arrÃªt non violent (coopÃ©ratif). join() / join(timeout) : attendre la fin dâ€™un autre thread. setPriority(1..10) : Ã  Ã©viter en pratique (portabilitÃ©/Ã©quitÃ© non garanties). yield() : propose de laisser la main (effet non garanti â†’ diagnostique/dÃ©mo). MÃ©thodes historiques comme stop(), suspend(), resume(), destroy() sont dangereuses/dÃ©conseillÃ©es (incohÃ©rences dâ€™Ã©tat). On privilÃ©gie lâ€™interruption et un arrÃªt gracieux.\n4.3 Cycle de vie (Ã©tats) stateDiagram-v2\r[*] --\u003e NEW\rNEW --\u003e RUNNABLE: start()\rRUNNABLE --\u003e BLOCKED: verrou occupÃ©\rRUNNABLE --\u003e WAITING: wait()/join()\rRUNNABLE --\u003e TIMED_WAITING: sleep()/wait(ms)/join(ms)\rWAITING --\u003e RUNNABLE: notify()/notifyAll()\rTIMED_WAITING --\u003e RUNNABLE: timeout\rBLOCKED --\u003e RUNNABLE: verrou acquis\rRUNNABLE --\u003e TERMINATED: fin run()/exception\rPrÃªt (RUNNABLE) : Ã©ligible CPU. Lâ€™OS/Horaireur choisit qui tourne. BloquÃ©/Attente : sommeil, I/O, attente de verrou ou de signal (wait/notify). TerminÃ© : run() a fini ou a levÃ© une exception non rattrapÃ©e. 5) Synchronisation et coordination 5.1 synchronized : verrou intrinsÃ¨que (moniteur) class Compteur { private int v = 0; public synchronized void inc() { v++; } public synchronized int get() { return v; } }\rVariante bloc (pour rÃ©duire la zone critique) : synchronized (verrou) { // section critique }\rRappel : le verrou est liÃ© Ã  lâ€™objet (ou Ã  la Class pour static). 5.2 wait/notify/notifyAll : coordination bas-niveau Ã€ nâ€™utiliser que dans un bloc/mÃ©thode synchronized sur le mÃªme objet. wait() libÃ¨re le verrou et met le thread en attente. notifyAll() rÃ©veille tous les threads en attente (prÃ©fÃ©rÃ© Ã  notify()). Exemple (file 1-Ã©lÃ©ment) :\nclass Boite { private Integer item = null; public synchronized void produire(int x) throws InterruptedException { while (item != null) wait(); item = x; notifyAll(); } public synchronized int consommer() throws InterruptedException { while (item == null) wait(); int x = item; item = null; notifyAll(); return x; } }\r5.3 Alternatives modernes (recommandÃ©) Collections concurrentes : ConcurrentHashMap, CopyOnWriteArrayList. Queues bloquantes : BlockingQueue (Array/LinkedBlockingQueue, SynchronousQueue) pour producteur/consommateur. Synchronisateurs : CountDownLatch, CyclicBarrier, Phaser, Semaphore. Producteurs/Consommateurs avec BlockingQueue import java.util.concurrent.*; public class PC { public static void main(String[] args) throws Exception { BlockingQueue\u003cString\u003e q = new ArrayBlockingQueue\u003c\u003e(100); ExecutorService pool = Executors.newFixedThreadPool(3); var prod = pool.submit(() -\u003e { for (int i=0;i\u003c1_000;i++) q.put(\"msg-\"+i); return null; }); var cons1 = pool.submit(() -\u003e { while (!Thread.currentThread().isInterrupted()) System.out.println(q.take()); }); var cons2 = pool.submit(() -\u003e { while (!Thread.currentThread().isInterrupted()) System.out.println(q.take()); }); prod.get(); pool.shutdownNow(); pool.awaitTermination(2, TimeUnit.SECONDS); } }\rSÃ©maphore (java.util.concurrent.Semaphore) ContrÃ´le dâ€™accÃ¨s Ã  N ressources identiques. import java.util.concurrent.Semaphore; class PoolRessources { private final Semaphore sem = new Semaphore(3); // 3 accÃ¨s simultanÃ©s void utiliser() throws InterruptedException { sem.acquire(); try { /* section utilisant la ressource */ } finally { sem.release(); } } }\rtryAcquire() pour Ã©viter les blocages, acquireUninterruptibly() pour ignorer lâ€™interruption (rarement conseillÃ©). 5.4 Verrous explicites (ReentrantLock) Avantages : tryLock(), plusieurs conditions (newCondition()), diagnostic Ã©quitable. import java.util.concurrent.locks.*; class CompteurLock { private int v = 0; private final ReentrantLock lock = new ReentrantLock(); int incEtGet() { lock.lock(); try { return ++v; } finally { lock.unlock(); } } }\r6) ExÃ©cution asynchrone : pools, futures, composition 6.1 ExecutorService : dÃ©lÃ©guer lâ€™exÃ©cution Ã  un pool import java.util.concurrent.*; public class DemoExecutor { public static void main(String[] args) throws Exception { ExecutorService pool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); try { Future\u003cLong\u003e f = pool.submit(() -\u003e { long s=0; for (int i=0;i\u003c5_000_000;i++) s += i; return s; }); System.out.println(\"Somme = \" + f.get()); // bloquant } finally { pool.shutdown(); pool.awaitTermination(5, TimeUnit.SECONDS); } } }\rTailles de pool : proche du nombre de cÅ“urs pour tÃ¢ches CPU-bound; newCachedThreadPool() pour I/O-bound. 6.2 CompletableFuture : pipelines non bloquants import java.util.concurrent.*; public class DemoCF { public static void main(String[] args) { CompletableFuture.supplyAsync(() -\u003e 21) .thenApply(x -\u003e x * 2) // 42 .thenCombine(CompletableFuture.supplyAsync(() -\u003e 1), Integer::sum) // 43 .orTimeout(500, TimeUnit.MILLISECONDS) .exceptionally(ex -\u003e -1) .thenAccept(System.out::println) .join(); // attendre la fin sans try/catch } }\rOpÃ©rateurs : thenApply/Compose, thenCombine, allOf/anyOf, handle, exceptionally, orTimeout/completeOnTimeout. 7) Interruption et arrÃªt gracieux 7.1 Patron dâ€™interruption class TacheLongue implements Runnable { @Override public void run() { while (!Thread.currentThread().isInterrupted()) { try { // travailâ€¦ Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); // rÃ©tablir le flag et sortir } } } }\r7.2 ArrÃªter un pool proprement pool.shutdown(); // plus de nouvelles tÃ¢ches if (!pool.awaitTermination(5, SECONDS)) { pool.shutdownNow(); // interrompre les tÃ¢ches en cours }\r8) Deadlocks : comprendre, reproduire, corriger 8.1 Exemple de deadlock public class Deadlock { static final Object A = new Object(); static final Object B = new Object(); public static void main(String[] args) throws Exception { Thread t1 = new Thread(() -\u003e { synchronized (A) { dormir(100); synchronized (B) { /* ... */ } } }, \"T1\"); Thread t2 = new Thread(() -\u003e { synchronized (B) { dormir(100); synchronized (A) { /* ... */ } } }, \"T2\"); t1.start(); t2.start(); t1.join(); t2.join(); } static void dormir(long ms) { try { Thread.sleep(ms); } catch (InterruptedException ignored) {} } }\râ†’ t1 garde A et attend B, t2 garde B et attend A : boucle dâ€™attente.\n8.2 StratÃ©gies dâ€™Ã©vitement Ordonnancement global des verrous : toujours les acquÃ©rir dans le mÃªme ordre. void travail(Object first, Object second) { Object a = first.hashCode() \u003c second.hashCode() ? first : second; Object b = (a == first) ? second : first; synchronized (a) { synchronized (b) { /* section critique */ } } }\rtryLock(timeout) + backoff (avec ReentrantLock). RÃ©duire la granularitÃ© et la durÃ©e des sections critiques. 9) Bonnes pratiques (robustesse, performance, portabilitÃ©) ImmuabilitÃ© dâ€™abord : partager des objets immuables Ã©vite des verrous. Confinement de thread : chaque thread possÃ¨de son Ã©tat (ou ThreadLocal). Toujours limiter la section critique au strict nÃ©cessaire. Ã‰viter wait/notify bruts si une BlockingQueue ou un synchronisateur convient. Timeouts partout : get(timeout), orTimeout, tryLock(timeout). Journalisation et mÃ©triques (dÃ©bit, latences, longueurs de files). Ne pas compter sur les prioritÃ©s de threads pour la logique mÃ©tier. Tester sous charge (courses, contention, interblocages). SÃ©parer CPU-bound / I/O-bound en pools dÃ©diÃ©s (Ã©vite la famine). 10) Exemples rapides â€œprÃªts Ã  exÃ©cuterâ€ 10.1 Mesurer une course (race) puis corriger // Non thread-safe class Counter { int v=0; void inc(){ v++; } } public class Race { public static void main(String[] a) throws Exception { var c = new Counter(); var t1 = new Thread(() -\u003e { for(int i=0;i\u003c1_000_000;i++) c.inc(); }); var t2 = new Thread(() -\u003e { for(int i=0;i\u003c1_000_000;i++) c.inc(); }); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Attendu=2000000, Obtenu=\"+c.v); } }\r// Correction atomique import java.util.concurrent.atomic.AtomicInteger; public class Atomic { public static void main(String[] a) throws Exception { var v = new AtomicInteger(); var t1 = new Thread(() -\u003e { for(int i=0;i\u003c1_000_000;i++) v.incrementAndGet(); }); var t2 = new Thread(() -\u003e { for(int i=0;i\u003c1_000_000;i++) v.incrementAndGet(); }); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"RÃ©sultat=\"+v.get()); } }\r10.2 invokeAny / invokeAll (meilleur et tous les rÃ©sultats) import java.util.*; import java.util.concurrent.*; public class Invoke { public static void main(String[] args) throws Exception { ExecutorService pool = Executors.newFixedThreadPool(4); try { List\u003cCallable\u003cString\u003e\u003e taches = List.of( () -\u003e { Thread.sleep(300); return \"A\"; }, () -\u003e { Thread.sleep(100); return \"B\"; }, () -\u003e { Thread.sleep(200); return \"C\"; } ); String fastest = pool.invokeAny(taches); // le plus rapide System.out.println(\"Plus rapide = \" + fastest); for (Future\u003cString\u003e f : pool.invokeAll(taches)) System.out.println(f.get()); } finally { pool.shutdown(); } } }\r10.3 SÃ©maphore pour limiter lâ€™accÃ¨s concurrent Ã  une ressource import java.util.concurrent.Semaphore; public class Limiteur { static final Semaphore SEM = new Semaphore(2); // 2 en parallÃ¨le static void tache(String nom) { try { if (SEM.tryAcquire()) { System.out.println(nom+\" entre\"); Thread.sleep(200); } else { System.out.println(nom+\" refuse (limite atteinte)\"); } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } finally { if (SEM.availablePermits()\u003c2) SEM.release(); } } public static void main(String[] args) { for (int i=0;i\u003c5;i++) new Thread(() -\u003e tache(Thread.currentThread().getName())).start(); } }\r11) RÃ©sumÃ© Concevoir le parallÃ©lisme : CPU-bound â‰  I/O-bound, taillez vos pools. ProtÃ©ger lâ€™Ã©tat partagÃ© : immuabilitÃ© â†’ atomiques â†’ synchronized/locks. Coordonner avec BlockingQueue, CountDownLatch, Semaphore, plutÃ´t que wait/notify brut. GÃ©rer lâ€™arrÃªt : interrupt + shutdown/awaitTermination. Ã‰viter les deadlocks : ordre de verrous, tryLock(timeout), petites sections. Observer : logs, mÃ©triques, profils de contention, noms de threads (ThreadFactory). Tester sous charge et avec timeouts.",
    "description": "1) De la machine au programme : processeur, multitÃ¢che, multithread 1.1 Processeur, mono-cÅ“ur vs multi-cÅ“urs Monoprocesseur (mono-cÅ“ur) : Ã  un instant donnÃ©, un seul programme tourne sur lâ€™unitÃ© centrale. Lâ€™illusion de simultanÃ©itÃ© vient du systÃ¨me dâ€™exploitation (OS) qui passe la main trÃ¨s vite dâ€™un programme Ã  lâ€™autre (prÃ©emption + quantum de temps). Multiprocesseur / multicÅ“ur : une mÃªme puce contient plusieurs cÅ“urs indÃ©pendants. On peut exÃ©cuter plusieurs threads rÃ©ellement en parallÃ¨le (un par cÅ“ur), ce quâ€™on appelle TLP â€“ Thread Level Parallelism. 1.2 MultitÃ¢che (au niveau OS) Le multitÃ¢che dÃ©signe la capacitÃ© de lâ€™OS Ã  exÃ©cuter (ou donner lâ€™illusion dâ€™exÃ©cuter) plusieurs processus â€œen mÃªme tempsâ€ en partageant le CPU. Sur I/O (clavier, disque, rÃ©seauâ€¦), lâ€™OS profite des attentes dâ€™un programme pour planifier un autre. 1.3 Multithreading (Ã  lâ€™intÃ©rieur dâ€™un processus) Le multithread Ã©tend le multitÃ¢che Ã  lâ€™Ã©chelle dâ€™une application : un processus peut contenir plusieurs threads, chacun Ã©tant un flux dâ€™exÃ©cution. Sur multi-cÅ“urs, des threads peuvent avancer vraiment en parallÃ¨le (TLP). Sur mono-cÅ“ur, on retrouve lâ€™illusion via le time-slicing de lâ€™OS/JVM. 2) Threads, sections critiques, exclusion mutuelle 2.1 DÃ©finitions essentielles Objet critique : ressource non rÃ©entrante/non simultanÃ©ment accessible (imprimante, fichier, structure mÃ©moireâ€¦). Section critique : code qui manipule un objet critique. Sans protection, lâ€™exÃ©cution concurrente peut produire des rÃ©sultats imprÃ©visibles. Exclusion mutuelle : garantir quâ€™au plus un thread exÃ©cute la section critique Ã  un instant donnÃ©. 2.2 ProblÃ¨mes classiques Condition de course (race) : deux threads lisent/modifient un Ã©tat partagÃ© sans coordination â†’ incohÃ©rences. Interblocage (deadlock) : t1 tient le verrou A et attend B, t2 tient B et attend A â†’ attente circulaire infinie. Famine (starvation) / livelock : un thread nâ€™obtient jamais les ressources / tout le monde bouge mais rien nâ€™avance. 3) Le modÃ¨le mÃ©moire Java (JMM) en pratique VisibilitÃ© : quand une Ã©criture par t1 devient visible par t2 ?",
    "tags": [],
    "title": "Treads en Java",
    "uri": "/420-311/threads/concepts/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Ressources utiles",
    "content": "Introduction Ã  Git Git est un logiciel de contrÃ´le de version. Il permet de gÃ©rer des fichiers et leur Ã©volution dans le temps.\nIl permet de retracer lâ€™origine de chaque modification, de rÃ©tablir des versions prÃ©cÃ©dentes et permet lâ€™intÃ©gration de modifications effectuÃ©es en parallÃ¨le.\nConcept Le principe dâ€™un gestionnaire de version est quâ€™il gÃ¨re un document comme â€œune baseâ€ Ã  laquelle est ajoutÃ© une suite de modifications.\nIl y a un dÃ©pÃ´t commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsquâ€™un contributeur a rÃ©alisÃ© une modification qui est prÃªte Ã  lâ€™envoyer, il pousse (push) celle-ci vers le dÃ©pÃ´t. Le dÃ©pÃ´t garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version dÃ©centralisÃ©. Il y a 2 dÃ©pÃ´ts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez rÃ©cupÃ©rer le code de votre repository (dÃ©pÃ´t remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configurÃ© la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de dÃ©poser les modifications sur une dÃ©pÃ´t local. Il faut Ã©galement Ãªtre vigilant au niveau de la branche utilisÃ© pour le commit. De plus, il est important de mettre souvent Ã  jour la branche avant de procÃ©der Ã  un commit.\nLorsquâ€™on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour rÃ©fÃ©rer Ã  la tÃ¢che en cours. AprÃ¨s cet identifiant, on peut y mettre une description. Par exemple:\nâ€œPRJ-3428: Ajout de tests unitaires sur la mÃ©thode du service getClientsâ€\nLorsquâ€™on relie lâ€™identifiant et les commits, on peut alors connaÃ®tre le travail effectuÃ© dans le code pour une tÃ¢che donnÃ©e dans le systÃ¨me de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandÃ© de faire un git fetch / pull avant de procÃ©der Ã  celui-ci. Ã€ moins dâ€™Ãªtre seul dans ce repository et/ou la branche visÃ©e.\nGit Fetch, checkout, pull La commande git fetch permet de mettre Ã  jour notre dÃ©pÃ´t local en rÃ©cupÃ©rant lâ€™ Ã©tat courant qui remote. La commande git checkout permet de les appliquer Ã  la copie de travail (et donc de les voir).\nLa commande git pull fait les deux Ã  la fois.\nPensez Ã  vous mettre Ã  jour avant chaque session de travail !\nCâ€™est la premiÃ¨re chose quâ€™un dÃ©veloppeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaÃ®tre lâ€™Ã©tat courant de vos copies locales (les modifications ont-elles Ã©tÃ© commitÃ©es, les fichiers ajoutÃ©s, les commit pushÃ©).\nLes interface graphiques (dont intelliJ) vous lâ€™indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectuÃ©. Ces commit peuvent Ãªtre fort utili pour faire dâ€™autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet dâ€™appliquer les changements (fusionner) dâ€™une autre branche Ã  votre branche sÃ©lectionnÃ©e dans votre repository locale. Il y a souvent des conflits lors dâ€™une fusion. Surtout si vous avez travailler dans un mÃªme fichier quâ€™un ou une de vos collÃ¨gues.\nVous devez tenter de rÃ©soudre les conflits avec des outils en ligne de commande ou Ã  lâ€™aide dâ€™un interface graphique. Câ€™est une habilitÃ© Ã  acquÃ©rir avec le temps. Câ€™est parfois trÃ¨s complexe et si lâ€™opÃ©ration nâ€™est pas effectÃ©e avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste Ã  changer la base de votre branche dâ€™un commit vers un autre, donnant lâ€™illusion que vous avez crÃ©Ã© votre branche Ã  partir dâ€™un commit diffÃ©rent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder lâ€™Ã©tat actuel de votre rÃ©pertoire de travail. Câ€™est possible de le faire avec git stash et de revenir Ã  un rÃ©pertoire de travail propre sans ces modifications. Vous pourrez ensuite rÃ©cupÃ©rer ce travail en utilisant le nom que vous lui aurez donnÃ©. Vous pouvez en avoir plusieurs sauvegardÃ©s dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// RÃ©cupÃ©rer les changements prÃ©cÃ©dents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalitÃ© si vous avez terminÃ©.\nNe pas prendre les branches pour plusieurs fonctionnalitÃ©s. SÃ©parez vos tÃ¢ches en plus petites et faites des commits plus souvent.\nRÃ©cupÃ©rer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre Ã©quipe vos intentions! Ne travaillez pas sur les mÃªmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillÃ© sur une fonctionnalitÃ© ou un fix.\nAvant le jour de la mise en production. Vous devriez crÃ©er une branche Ã  partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visÃ©e vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les Ã©lÃ©ments. Testez que votre branche fonctionne et quâ€™elle est bien compilÃ©e. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront dÃ©jÃ  Ã©tÃ© rÃ©solus! Bingo.\nGitflow Pour maintenir une certain cohÃ©sion en entreprise, un modÃ¨le de branche a Ã©tÃ© proposÃ©. Il implique de sÃ©parer les branches de dÃ©veloppement et les branches primaires qui sont dÃ©ployÃ©s dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRÃ©fÃ©rence Richard E. Silverman (2013), Git Pocket Guide, Oâ€™Reilly\nAlice Jacquot, Introduction Ã  Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction Ã  Git Git est un logiciel de contrÃ´le de version. Il permet de gÃ©rer des fichiers et leur Ã©volution dans le temps.\nIl permet de retracer lâ€™origine de chaque modification, de rÃ©tablir des versions prÃ©cÃ©dentes et permet lâ€™intÃ©gration de modifications effectuÃ©es en parallÃ¨le.\nConcept Le principe dâ€™un gestionnaire de version est quâ€™il gÃ¨re un document comme â€œune baseâ€ Ã  laquelle est ajoutÃ© une suite de modifications.\nIl y a un dÃ©pÃ´t commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-311/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ UnitTests",
    "content": "Pourquoi des tests unitaires ? FiabilitÃ© : on dÃ©tecte les rÃ©gressions dÃ¨s quâ€™on modifie le code. Confiance : on peut refactorer sans crainte si la suite de tests reste verte. Conception : Ã©crire un test oblige Ã  clarifier lâ€™API (entrÃ©es/sorties, cas limites). Documentation vivante : les tests montrent comment utiliser la classe. Quâ€™est-ce que JUnit 5 ? JUnit 5 = Plateforme + API de tests modernes pour Java.\nJUnit Platform : lanceur, intÃ©gration IDE/CI. JUnit Jupiter : API et moteur de tests (ce quâ€™on utilise au quotidien). JUnit Vintage : compatibilitÃ© JUnit 3/4 (optionnel). Vocabulaire utile :\nTest : mÃ©thode annotÃ©e @Test. Fixture : Ã©tat/configuration nÃ©cessaire avant un test (ex. objets crÃ©Ã©s dans @BeforeEach). Assertions : vÃ©rifications (assertEquals, assertThrows, etc.). Cycle de vie : @BeforeAll, @BeforeEach, @AfterEach, @AfterAll. Tags : Ã©tiquettes pour filtrer des tests (@Tag(\"integration\")). ParamÃ©trÃ©s : un mÃªme test avec plusieurs jeux de donnÃ©es (@ParameterizedTest). Installer JUnit 5 dans un projet Maven (minimum viable) \u003c!-- pom.xml (extrait minimal) --\u003e \u003cproperties\u003e \u003cmaven.compiler.release\u003e17\u003c/maven.compiler.release\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cjunit.jupiter.version\u003e5.11.0\u003c/junit.jupiter.version\u003e \u003csurefire.version\u003e3.5.0\u003c/surefire.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e${junit.jupiter.version}\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cversion\u003e${surefire.version}\u003c/version\u003e \u003cconfiguration\u003e \u003cuseModulePath\u003efalse\u003c/useModulePath\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e\rArborescence standard :\nsrc\râ”œâ”€ main/java/... (code applicatif)\râ””â”€ test/java/... (tests unitaires)\rÃ‰crire son premier test Classe Ã  tester (trÃ¨s simple) // src/main/java/com/exemple/Calculator.java package com.exemple; public class Calculator { public int add(int a, int b) { return a + b; } public int div(int a, int b) { if (b == 0) throw new ArithmeticException(\"division by zero\"); return a / b; } }\rTest JUnit 5 // src/test/java/com/example/CalculatorTest.java package com.example; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class CalculatorTest { @Test void addReturnsSum() { Calculator calculator = new Calculator(); assertEquals(5, calculator.add(2, 3)); } @Test void divideThrowsWhenDividingByZero() { Calculator calculator = new Calculator(); ArithmeticException ex = assertThrows( ArithmeticException.class, () -\u003e calculator.divide(1, 0)); assertEquals(\"division by zero\", ex.getMessage()); } }\rExÃ©cuter :\nmvn test\rCycle de vie (fixtures) // src/test/java/com/exemple/LifecycleIntroTest.java package com.exemple; import org.junit.jupiter.api.*; import static org.junit.jupiter.api.Assertions.*; class LifecycleIntroTest { Calculator calc; @BeforeAll static void beforeAllSuite() { // ExÃ©cutÃ© une fois avant tous les tests de la classe (static par dÃ©faut) } @BeforeEach void setUp() { calc = new Calculator(); // fixture : Ã©tat prÃªt avant chaque test } @Test void addition() { assertEquals(7, calc.add(3, 4)); } @AfterEach void tearDown() { // Nettoyage aprÃ¨s chaque test si nÃ©cessaire } @AfterAll static void afterAllSuite() { // ExÃ©cutÃ© une fois aprÃ¨s tous les tests de la classe } }\rPoints clÃ©s :\n@BeforeEach prÃ©pare un contexte propre par test (pas de fuite dâ€™Ã©tat). @BeforeAll/@AfterAll conviennent pour des ressources globales (ex. dÃ©marrer un serveur embarquÃ©). Assertions de base import static org.junit.jupiter.api.Assertions.*; import java.time.Duration; @Test void assertionsBase() { assertEquals(42, 40 + 2, \"Somme incorrecte\"); assertTrue(\"abc\".startsWith(\"a\")); assertNotNull(new Object()); // GroupÃ©es (exÃ©cute tout, reporte toutes les erreurs) assertAll(\"utilisateur\", () -\u003e assertEquals(\"Ada\", \"Ada\"), () -\u003e assertTrue(3 \u003e 1), () -\u003e assertThrows(IllegalArgumentException.class, () -\u003e { throw new IllegalArgumentException(); }) ); // Timeout (dÃ©tecter une dÃ©rive de performance) assertTimeout(Duration.ofMillis(200), () -\u003e { // opÃ©ration censÃ©e Ãªtre rapide }); }\rNoms, structure et style Nommer clairement : ClasseTest et mÃ©thodes shouldDoXWhenY() ou en franÃ§ais explicite. 1 idÃ©e = 1 test : garder les tests courts et lisibles. Cas limites : penser null, collections vides, bornes min/max, division par zÃ©ro, etc. IndÃ©pendance : chaque test doit pouvoir sâ€™exÃ©cuter seul, dans nâ€™importe quel ordre. TDD (Tests Driven Development) : cycle rouge â†’ vert â†’ refactor Rouge : Ã©crire un test qui Ã©choue (fonctionnalitÃ© absente). Vert : implÃ©menter le minimum pour le faire passer. Refactor : amÃ©liorer le code en sâ€™appuyant sur le filet de sÃ©curitÃ© des tests. Mini-exercices Edge cases : ajouter des tests pour Calculator.add avec des nombres nÃ©gatifs et Integer.MAX_VALUE. ChaÃ®nes : Ã©crire un utilitaire StringUtil.capitalize(String) et tester null, vide, espaces, accents. Collections : crÃ©er un Directory (Map) qui refuse les doublons et tester lâ€™exception. Erreurs frÃ©quentes (et solutions) Les tests ne sâ€™exÃ©cutent pas : vÃ©rifier maven-surefire-plugin (â‰¥ 2.22.0) et la dÃ©pendance junit-jupiter. @BeforeAll non statique : soit rendre la mÃ©thode static, soit annoter la classe avec @TestInstance(PER_CLASS). Flaky tests (alÃ©atoires/temps) : isoler lâ€™heure/le hasard (injecter une Clock, fixer une seed). Tests avec diffÃ©rents types Types primitifs et chaÃ®nes // src/test/java/com/exemple/PrimitivesEtChainesTest.java package com.exemple; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class PrimitivesEtChainesTest { @Test void entiersEtBooleens() { int a = 2, b = 3; assertEquals(5, a + b); assertTrue((a + b) \u003e 0); assertFalse((a - b) \u003e 0); } @Test void doublesEtDelta() { double x = 0.1 + 0.2; // prÃ©cision binaire assertEquals(0.3, x, 1e-9); // tolÃ©rance } @Test void caracteres() { char c = 'A'; assertEquals(65, (int) c); assertTrue(Character.isLetter(c)); } @Test void chainesCaracteres() { String s = \" Bonjour \"; assertEquals(\"BONJOUR\", s.trim().toUpperCase()); assertTrue(s.contains(\"Bon\")); assertEquals(10, s.trim().length()); } }\rTableaux (arrays) et Arrays // src/test/java/com/exemple/ArraysTest.java package com.exemple; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; import java.util.Arrays; class ArraysTest { @Test void comparaisonTableaux() { int[] a = {1, 2, 3}; int[] b = {1, 2, 3}; // Pour les tableaux, utiliser Arrays.equals assertTrue(Arrays.equals(a, b)); } @Test void triEtRecherche() { int[] data = {5, 1, 4, 2}; Arrays.sort(data); assertArrayEquals(new int[]{1, 2, 4, 5}, data); assertTrue(Arrays.binarySearch(data, 4) \u003e= 0); } }\rCollections de base : List, Set, Map // src/test/java/com/exemple/CollectionsTest.java package com.exemple; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; import java.util.*; class CollectionsTest { @Test void listMutableEtLecture() { List\u003cString\u003e fruits = new ArrayList\u003c\u003e(List.of(\"pomme\", \"banane\")); fruits.add(\"poire\"); assertEquals(3, fruits.size()); assertEquals(\"banane\", fruits.get(1)); assertIterableEquals(List.of(\"pomme\", \"banane\", \"poire\"), fruits); } @Test void setUniciteEtOrdre() { Set\u003cString\u003e tags = new HashSet\u003c\u003e(); tags.add(\"java\"); tags.add(\"java\"); tags.add(\"junit\"); assertEquals(2, tags.size()); // unicitÃ© assertTrue(tags.contains(\"java\")); } @Test void mapInsertionLectureValeurs() { Map\u003cString, Integer\u003e ages = new HashMap\u003c\u003e(); ages.put(\"Alice\", 30); ages.put(\"Bob\", 25); assertEquals(2, ages.size()); assertEquals(30, ages.get(\"Alice\")); assertTrue(ages.containsKey(\"Bob\")); assertTrue(ages.containsValue(25)); } @Test void collectionsImmatEtVue() { var nonModifiable = List.of(\"a\", \"b\"); assertThrows(UnsupportedOperationException.class, () -\u003e nonModifiable.add(\"c\")); var vue = Arrays.asList(\"x\", \"y\"); // taille fixe assertThrows(UnsupportedOperationException.class, () -\u003e vue.add(\"z\")); vue.set(0, \"X\"); // mais remplaÃ§able assertEquals(List.of(\"X\", \"y\"), vue); } }\rDates \u0026 temps (API java.time) // src/test/java/com/exemple/DateTimeTest.java package com.exemple; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; import java.time.*; class DateTimeTest { @Test void localdateOperations() { LocalDate d = LocalDate.of(2025, 1, 15); assertEquals(DayOfWeek.WEDNESDAY, d.getDayOfWeek()); assertEquals(LocalDate.of(2025,1,22), d.plusWeeks(1)); } @Test void durationEtInstant() { Instant start = Instant.now(); Instant end = start.plusSeconds(2); Duration dur = Duration.between(start, end); assertEquals(2, dur.getSeconds()); } }\rObjets : equals, hashCode, getters simples Code de production // src/main/java/com/exemple/Person.java package com.exemple; import java.util.Objects; public class Person { private final String firstName; private final String lastName; private final int age; public Person(String firstName, String lastName, int age) { if (firstName == null || firstName.isBlank()) throw new IllegalArgumentException(\"firstName\"); if (lastName == null || lastName.isBlank()) throw new IllegalArgumentException(\"lastName\"); if (age \u003c 0) throw new IllegalArgumentException(\"age\"); this.firstName = firstName; this.lastName = lastName; this.age = age; } public String getFirstName(){ return firstName; } public String getLastName(){ return lastName; } public int getAge(){ return age; } @Override public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof Person p)) return false; return age == p.age \u0026\u0026 Objects.equals(firstName, p.firstName) \u0026\u0026 Objects.equals(lastName, p.lastName); } @Override public int hashCode() { return Objects.hash(firstName, lastName, age); } @Override public String toString() { return \"%s %s (%d)\".formatted(firstName, lastName, age); } }\rTests unitaires simples sur lâ€™objet // src/test/java/com/example/PersonTest.java package com.example; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class PersonTest { @Test void gettersReturnExpectedValues() { Person person = new Person(\"Ada\", \"Lovelace\", 36); assertEquals(\"Ada\", person.getFirstName()); assertEquals(\"Lovelace\", person.getLastName()); assertEquals(36, person.getAge()); assertTrue(person.toString().contains(\"Ada\")); } @Test void equalsAndHashCodeAreConsistent() { Person p1 = new Person(\"Alan\", \"Turing\", 41); Person p2 = new Person(\"Alan\", \"Turing\", 41); Person p3 = new Person(\"Grace\", \"Hopper\", 40); assertEquals(p1, p2); assertEquals(p1.hashCode(), p2.hashCode()); assertNotEquals(p1, p3); } @Test void constructorValidatesArguments() { assertThrows(IllegalArgumentException.class, () -\u003e new Person(null, \"X\", 1)); assertThrows(IllegalArgumentException.class, () -\u003e new Person(\"X\", \" \", 1)); assertThrows(IllegalArgumentException.class, () -\u003e new Person(\"X\", \"Y\", -1)); } }\rMini-service + test simple Code de production // src/main/java/com/exemple/Directory.java package com.exemple; import java.util.*; public class Directory { private final Map\u003cString, Person\u003e people = new HashMap\u003c\u003e(); public void add(Person p) { if (p == null) throw new IllegalArgumentException(\"person null\"); people.put(p.getFirstName() + \":\" + p.getLastName(), p); } public Optional\u003cPerson\u003e find(String firstName, String lastName) { return Optional.ofNullable(people.get(firstName + \":\" + lastName)); } public int size() { return people.size(); } }\rOptional Test unitaire // src/test/java/com/exemple/DirectoryTest.java package com.exemple; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class DirectoryTest { @Test void ajoutEtRecherche() { var d = new Directory(); d.add(new Person(\"Alan\", \"Turing\", 41)); d.add(new Person(\"Grace\", \"Hopper\", 40)); assertEquals(2, d.size()); assertTrue(d.find(\"Grace\", \"Hopper\").isPresent()); assertTrue(d.find(\"Alan\", \"Turing\").isPresent()); assertTrue(d.find(\"Ada\", \"Lovelace\").isEmpty()); } }\rCommandes utiles # Lancer tous les tests de la Partie 1 mvn test # Lancer un test spÃ©cifique mvn -Dtest=PersonTest test # Lancer une mÃ©thode spÃ©cifique mvn -Dtest=PersonTest#equalsHashCodeCoherents test\rRessources Documentation JUnit 5\nTutoriel JUnit 5",
    "description": "Pourquoi des tests unitaires ? FiabilitÃ© : on dÃ©tecte les rÃ©gressions dÃ¨s quâ€™on modifie le code. Confiance : on peut refactorer sans crainte si la suite de tests reste verte. Conception : Ã©crire un test oblige Ã  clarifier lâ€™API (entrÃ©es/sorties, cas limites). Documentation vivante : les tests montrent comment utiliser la classe. Quâ€™est-ce que JUnit 5 ? JUnit 5 = Plateforme + API de tests modernes pour Java.\nJUnit Platform : lanceur, intÃ©gration IDE/CI. JUnit Jupiter : API et moteur de tests (ce quâ€™on utilise au quotidien). JUnit Vintage : compatibilitÃ© JUnit 3/4 (optionnel). Vocabulaire utile :",
    "tags": [],
    "title": "Introduction Ã  JUnit",
    "uri": "/420-311/unittests/intojunit/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Objectifs gÃ©nÃ©raux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de donnÃ©es.\nÃ‰valuer et comparer la complexitÃ© algorithmique des opÃ©rations (temps et mÃ©moire).\nUtiliser des fils dâ€™exÃ©cution (threads) pour exÃ©cuter plusieurs tÃ¢ches en parallÃ¨le.\nDÃ©velopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi Ã©tudier les structures de donnÃ©es ? Parce quâ€™elles sont au cÅ“ur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de donnÃ©es.\nParce quâ€™elles permettent de rÃ©duire le temps dâ€™exÃ©cution et Ã©conomiser de la mÃ©moire.\nParce quâ€™elles dÃ©veloppent la capacitÃ© Ã  choisir la bonne approche selon un problÃ¨me donnÃ©.\nParce quâ€™elles forment une base solide pour les cours ultÃ©rieurs et pour travailler dans des projets dâ€™envergure.\nCitation classique : Â« Un bon algorithme mal implantÃ© dans une mauvaise structure de donnÃ©es sera inefficace. Une bonne structure de donnÃ©es peut transformer un problÃ¨me complexe en une solution Ã©lÃ©gante. Â»\nğŸŒ¼ Notion de structure de donnÃ©es Le principe de base dâ€™une structure de donnÃ©es, câ€™est de stocker des Ã©lÃ©ments auxquels le programmeur veut pouvoir accÃ©der plus tard. On appelle les diffÃ©rentes utilisations possibles de la structure de donnÃ©es des opÃ©rations.\nğŸŒ¼ Les structures de donnÃ©es en Java Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util).\nOn y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nNous commencerons par examiner les concepts communs quâ€™elles (structures de donnÃ©es) exploitent ainsi : gÃ©nÃ©ricitÃ©, itÃ©rateur, ordonnancement et relation dâ€™ordre.\nNous verrons Ã©galement quelles sont les opÃ©rations qui leur sont communes : ajout ou suppression dâ€™Ã©lÃ©ments, construction Ã  partir des Ã©lÃ©ments dâ€™une autre collectionâ€¦\nNous Ã©tudierons ensuite en dÃ©tail chacune de ces structures, Ã  savoir :\nğŸ— Les listes, implÃ©mentÃ©es par la classe LinkedList;\rğŸ— Les vecteurs dynamiques, implÃ©mentÃ©s par les classes ArrayList et Vector;\rğŸ— Les ensembles, implÃ©mentÃ©s par les classes HashSet et TreeSet;\rğŸ— Les queues avec prioritÃ©, implÃ©mentÃ©es par la classe PriorityQueue (introduite par le JDK 5.0) ;\rğŸ— Les queues Ã  double entrÃ©e, implÃ©mentÃ©es par la classe ArrayDeque (introduite par Java6).",
    "description": "Objectifs gÃ©nÃ©raux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de donnÃ©es.\nÃ‰valuer et comparer la complexitÃ© algorithmique des opÃ©rations (temps et mÃ©moire).\nUtiliser des fils dâ€™exÃ©cution (threads) pour exÃ©cuter plusieurs tÃ¢ches en parallÃ¨le.\nDÃ©velopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi Ã©tudier les structures de donnÃ©es ? Parce quâ€™elles sont au cÅ“ur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de donnÃ©es.",
    "tags": [],
    "title": "Structures de donnÃ©e",
    "uri": "/420-311/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ IO",
    "content": "ğŸ“– Le format JSON 1. DÃ©finition JSON est un format de texte standardisÃ© pour reprÃ©senter et Ã©changer des donnÃ©es. InspirÃ© de JavaScript, mais indÃ©pendant du langage : tous les langages modernes (Java, Python, C#, PHP, etc.) peuvent le lire et lâ€™Ã©crire. Lisible par les humains, facile Ã  traiter par les machines. 2. Structure du JSON Le JSON est composÃ© de deux structures principales :\nObjet (Object) â†’ une collection de paires clÃ©â€“valeur\n{ \"nom\": \"Alice\", \"age\": 23, \"etudiant\": true }\rTableau (Array) â†’ une liste ordonnÃ©e de valeurs\n[\"Java\", \"Python\", \"C++\"]\r3. Types de valeurs autorisÃ©s String : chaÃ®ne de caractÃ¨res Number : entier ou dÃ©cimal Boolean : true ou false Null : valeur nulle Object : { ... } Array : [ ... ] Exemple combinant plusieurs types :\n{ \"nom\": \"Bob\", \"age\": 25, \"competences\": [\"Java\", \"SQL\", \"Git\"], \"actif\": true, \"adresse\": { \"ville\": \"MontrÃ©al\", \"codePostal\": \"H2X 1Y4\" } }\rExemple avec Jackson En Java, on peut manipuler JSON avec des bibliothÃ¨ques comme Jackson ou Gson.\nExemple Objet Java â†’ JSON et JSON â†’ Objet Java import com.fasterxml.jackson.databind.ObjectMapper; public class ExempleJackson1 { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); Client client = new Client(12345, \"Dupont\", \"Alice\", 2500.75); // Conversion Objet â†’ JSON String json = mapper.writeValueAsString(client); System.out.println(\"Objet vers JSON : \" + json); } }\rRÃ©sultat attendu :\n{\"numCompte\":12345,\"nom\":\"Dupont\",\"prenom\":\"Alice\",\"solde\":2500.75}\rString donnees = \"{\\\"numCompte\\\":98765,\\\"nom\\\":\\\"Martin\\\",\\\"prenom\\\":\\\"Bob\\\",\\\"solde\\\":1500.0}\"; // Conversion JSON â†’ Objet Client client1 = mapper.readValue(donnees, client.class); System.out.println(\"Client : \" + client1.getNom() + \" \" + client1.getPrenom() + \", Compte : \" + client1.getNumCompte() + \", Solde : \" + client1.getSolde());\rRÃ©sultat attendu :\nClient : Martin Bob, Compte : 98765, Solde : 1500.0\rLecture/Ã©criture de fichier JSON // Ã‰criture dans un fichier mapper.writeValue(new FileInputStream(\"client.json\"), client); // Lecture depuis un fichier Client client2 = mapper.readValue(new FileInputStream(\"client.json\"), Client.class); System.out.println(\"Nom lu depuis fichier : \" + client2.getNom());\rtableau JSON String jsonArray = \"[{\\\"numCompte\\\":111,\\\"nom\\\":\\\"Durand\\\",\\\"prenom\\\":\\\"Paul\\\",\\\"solde\\\":3000.0},\" + \"{\\\"numCompte\\\":222,\\\"nom\\\":\\\"Moreau\\\",\\\"prenom\\\":\\\"Sophie\\\",\\\"solde\\\":4500.5}]\"; Client[] clients = mapper.readValue(jsonArray, Client[].class); for (Client c : clients) { System.out.println(c.getNumCompte() + \" - \" + c.getNom() + \" \" + c.getPrenom() + \" : \" + c.getSolde()); } // crÃ©er un fichier json avec liste de clients List\u003cClient\u003e listeClients = Arrays.asList(clients); // crÃ©er un fichier json avec liste de clients mapper.writeValue(new FileOutputStream(\"clients.json\"), listeClients); List\u003cClient\u003e clientsLus = mapper.readValue(new FileInputStream(\"clients.json\"), new TypeReference\u003cList\u003cClient\u003e\u003e() {});\rRÃ©sultat attendu :\n111 - Durand Paul : 3000.0\r222 - Moreau Sophie : 4500.5\r5. Avantages du JSON âœ… Lisible et lÃ©ger âœ… Standard universel (API, configuration, Ã©changes de donnÃ©es) âœ… Facile Ã  convertir en objet dans la plupart des langages âœ… Support natif dans JavaScript (et simple en Java avec des bibliothÃ¨ques) 6. Comparaison JSON vs XML Aspect JSON XML LisibilitÃ© Plus simple, lÃ©ger Verbeux, balises lourdes Types natifs String, Number, Boolean, etc. Tout est texte Usage APIs REST, stockage lÃ©ger DonnÃ©es hiÃ©rarchiques complexes 7. Cas dâ€™utilisation typiques Communication entre client (front-end) et serveur (back-end) â†’ APIs REST Stockage lÃ©ger de configurations (config.json, package.json) Bases de donnÃ©es NoSQL (MongoDB utilise JSON comme format natif â†’ BSON) RÃ©sumÃ© JSON = format texte universel pour reprÃ©senter des objets et des tableaux. ClÃ©s toujours entre guillemets (\"clÃ©\"). Valeurs : string, number, boolean, null, object, array. TrÃ¨s utilisÃ© dans les APIs web et les bases NoSQL. En Java â†’ bibliothÃ¨ques populaires : Gson, Jackson.",
    "description": "ğŸ“– Le format JSON 1. DÃ©finition JSON est un format de texte standardisÃ© pour reprÃ©senter et Ã©changer des donnÃ©es. InspirÃ© de JavaScript, mais indÃ©pendant du langage : tous les langages modernes (Java, Python, C#, PHP, etc.) peuvent le lire et lâ€™Ã©crire. Lisible par les humains, facile Ã  traiter par les machines. 2. Structure du JSON Le JSON est composÃ© de deux structures principales :\nObjet (Object) â†’ une collection de paires clÃ©â€“valeur",
    "tags": [],
    "title": "Format JSON",
    "uri": "/420-311/io/jsonformat/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ IO",
    "content": "DÃ©finition Lâ€™API I/O (Input/Output) de Java permet de gÃ©rer les flux de donnÃ©es (streams), câ€™est-Ã -dire la lecture (Input) et lâ€™Ã©criture (Output) de donnÃ©es vers :\nle clavier et lâ€™Ã©cran (console), les fichiers (texte ou binaire), le rÃ©seau, la mÃ©moire. Tout en Java I/O est basÃ© sur la notion de flux.\nLes flux (Streams) Un flux est une sÃ©quence dâ€™octets ou de caractÃ¨res qui circule entre une source (input) et une destination (output).\nTypes de flux Flux de bytes (8 bits) â†’ pour les fichiers binaires (images, sons, etc.)\nInputStream (lecture) OutputStream (Ã©criture) Flux de caractÃ¨res (16 bits) â†’ pour les fichiers texte (compatibles Unicode)\nReader (lecture) Writer (Ã©criture) Les classes de lecture et dâ€™Ã©criture HiÃ©rarchie principale Pour les bytes : FileInputStream / FileOutputStream BufferedInputStream / BufferedOutputStream Pour les caractÃ¨res : FileReader / FileWriter BufferedReader / BufferedWriter PrintWriter Les classes de lecture : Reader, InputStreamReader, FileReader et BufferedReader Reader est la classe abstraite pour la lecture des flux de caractÃ¨res.\nElle met en Å“uvre les mÃ©thodes fondamentales suivantes :\nread() : lit un caractÃ¨re unique. read(char[]) : lit un tableau de caractÃ¨res. skip(long) : ignore certains caractÃ¨res. close() : ferme le flux. InputStreamReader est un pont entre les flux dâ€™octets et les flux de caractÃ¨res.\nIl convertit des octets en caractÃ¨res Ã  lâ€™aide dâ€™un jeu de caractÃ¨res spÃ©cifiÃ© (charset).\nLe jeu de caractÃ¨res peut Ãªtre celui par dÃ©faut du systÃ¨me dâ€™exploitation,\nou Ãªtre spÃ©cifiÃ© explicitement lors de la crÃ©ation dâ€™un InputStreamReader. FileReader est une classe pratique pour lire des fichiers texte en utilisant\nle codage de caractÃ¨res par dÃ©faut du systÃ¨me dâ€™exploitation.\nBufferedReader lit le texte dâ€™un flux de caractÃ¨res avec efficacitÃ©\n(les caractÃ¨res sont mis en mÃ©moire tampon pour Ã©viter de lire frÃ©quemment le flux sous-jacent).\nFournit une mÃ©thode pratique pour lire une ligne de texte : readLine(). Le diagramme suivant montre la relation de ces classes de lecture dans le package java.io.\nReader\r|_ InputStreamReader\r| |_ FileReader\r|_ BufferedReader Les classes dâ€™Ã©criture : Writer, OutputStreamWriter, FileWriter et BufferedWriter Writer est la classe abstraite pour lâ€™Ã©criture de flux de caractÃ¨res.\nElle met en Å“uvre les mÃ©thodes fondamentales suivantes :\nğŸ‘ write(int) : Ã©crit un seul caractÃ¨re. ğŸ‘ write(char[]) : Ã©crit un tableau de caractÃ¨res. ğŸ‘ write(String) : Ã©crit une chaÃ®ne de caractÃ¨res. ğŸ‘ close() : ferme le flux. OutputStreamWriter est un pont entre les flux dâ€™octets et les flux de caractÃ¨res.\nLes caractÃ¨res sont codÃ©s en octets Ã  lâ€™aide dâ€™un jeu de caractÃ¨res spÃ©cifiÃ©.\nğŸ‘ Le jeu de caractÃ¨res peut Ãªtre celui par dÃ©faut du systÃ¨me dâ€™exploitation,\nou Ãªtre spÃ©cifiÃ© explicitement lors de la crÃ©ation dâ€™un OutputStreamWriter. FileWriter est une classe pratique pour Ã©crire des fichiers texte\nen utilisant le codage de caractÃ¨res par dÃ©faut du systÃ¨me dâ€™exploitation.\nBufferedWriter Ã©crit du texte dans un flux de caractÃ¨res avec efficacitÃ©\n(les caractÃ¨res, tableaux et chaÃ®nes sont mis en mÃ©moire tampon pour Ã©viter dâ€™Ã©crire trop souvent sur le flux sous-jacent).\nğŸ‘ Fournit une mÃ©thode pratique pour Ã©crire un sÃ©parateur de ligne : newLine(). Le diagramme suivant montre la relation de ces classes dâ€™Ã©criture dans le package java.io.\nWriter\r|_ OutputStreamWriter\r| |_ FileWriter\r|_ BufferedWriter Exemples Exepmle de lecture dâ€™un fichier texte import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; public class LectureFichier { public static void main(String[] args) { try (BufferedReader br = new BufferedReader(new FileReader(\"test.txt\"))) { String ligne; while ((ligne = br.readLine()) != null) { System.out.println(ligne); } } catch (IOException e) { e.printStackTrace(); } } }\rDans cet exemple, BufferedReader lit un fichier texte ligne par ligne.\nExepmle dâ€™Ã©criture dans un fichier texte import java.io.BufferedWriter; import java.io.FileWriter; import java.io.IOException; public class EcritureFichier { public static void main(String[] args) { try (BufferedWriter bw = new BufferedWriter(new FileWriter(\"sortie.txt\"))) { bw.write(\"Bonjour, monde !\"); bw.newLine(); bw.write(\"DeuxiÃ¨me ligne.\"); } catch (IOException e) { e.printStackTrace(); } } }\rDans cet exemple, BufferedWriter permet dâ€™Ã©crire efficacement dans un fichier.\n6. Exemple : copier un fichier binaire (image) import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class CopierFichier { public static void main(String[] args) { try (FileInputStream in = new FileInputStream(\"image.png\"); FileOutputStream out = new FileOutputStream(\"copie.png\")) { byte[] buffer = new byte[1024]; int bytesLus; while ((bytesLus = in.read(buffer)) != -1) { out.write(buffer, 0, bytesLus); } } catch (IOException e) { e.printStackTrace(); } } }\râ¡ï¸ Utilise un buffer pour optimiser la lecture/Ã©criture dâ€™un fichier binaire.\n7. EntrÃ©es/sorties standard System.in â†’ flux dâ€™entrÃ©e standard (clavier). System.out â†’ flux de sortie standard (console). System.err â†’ flux dâ€™erreurs. Exemple :\nimport java.util.Scanner; public class ExempleIO { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\"Entrez votre nom : \"); String nom = sc.nextLine(); System.out.println(\"Bonjour \" + nom); } }\r8. SÃ©rialisation dâ€™objets Lâ€™API I/O permet aussi de sauvegarder des objets avec ObjectOutputStream et ObjectInputStream.\nimport java.io.*; import java.util.ArrayList; public class SauvegardeObjets { public static void main(String[] args) { try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"data.ser\"))) { ArrayList\u003cString\u003e liste = new ArrayList\u003c\u003e(); liste.add(\"Alice\"); liste.add(\"Bob\"); out.writeObject(liste); } catch (IOException e) { e.printStackTrace(); } } }\r9. RÃ©sumÃ© Input/Output = gestion des flux (bytes ou caractÃ¨res). Lecteurs/Ã‰crivains (Reader/Writer) â†’ texte. InputStream/OutputStream â†’ donnÃ©es binaires. Toujours utiliser des buffers pour optimiser les performances. Penser Ã  fermer les flux (close() ou try-with-resources).",
    "description": "DÃ©finition Lâ€™API I/O (Input/Output) de Java permet de gÃ©rer les flux de donnÃ©es (streams), câ€™est-Ã -dire la lecture (Input) et lâ€™Ã©criture (Output) de donnÃ©es vers :\nle clavier et lâ€™Ã©cran (console), les fichiers (texte ou binaire), le rÃ©seau, la mÃ©moire. Tout en Java I/O est basÃ© sur la notion de flux.\nLes flux (Streams) Un flux est une sÃ©quence dâ€™octets ou de caractÃ¨res qui circule entre une source (input) et une destination (output).",
    "tags": [],
    "title": "ğŸ“– Lâ€™API Java I/O (Input / Output)",
    "uri": "/420-311/io/javaapi/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Ressources utiles",
    "content": "Maven (Project Managment Tool) Creation dâ€™un projet maven: Pour crÃ©er un projet maven on suit les Ã©tape suivantes :\nDans IntelliJ cliquer sur create new project. Cette fois-ci ne pas choisir java mais maven. Vous pouvez cocher la case Create from archetype. Vous pouvez choisir maven-archetype-quickstart (dans notre cas pas besoin on va configurer notre projet par nous mÃªme). cliquez sur next. Vous pouvez spÃ©cifier le nom de votre projet, Ã§a location. Vous pouves cliquer sur la flÃ¨che vers le bas pour afficher les champs qui permettent dâ€™identifier notre programme de faÃ§on unique (comme un UID). Il est conseiller de les garder comme suggÃ¨rer sauf si vous voulez un nom diffÃ©rent pour votre application. Cliquez sur next. cliquez sur finish. Un projet avec la structure suivante sera crÃ©Ã©. Il faut respecter cette structure pour vos prochains projets avec maven. Affichier la fenÃªtre maven Ici vous pouvez observer les .jar (dÃ©pendances tÃ©lechargÃ©s) dans la section dependencies (une fois que vous avez ajouter au moins une dÃ©pendance, la section apparait).\nVous pouvez forcer le tÃ©lÃ©chargement des dÃ©pendances comme suit : Configurer lâ€™exÃ©cution avec maven Dans edit configuration ajouter une configuration et choisir au lieu application cette fois-ci maven. Lâ€™onglet runner vous permet de spÃ©cifier la version SDK au runtime, vous pouvez la changer si ce nâ€™est pas celle Ã  laquelle que vous avez besoin.\nAssuerz vous que votre version de compilateur dans pom.xml est compatible avec votre version au runtime.\nVisualisation des dÃ©pendences (graphique) Visulaliser le dÃ©pendances de votre projet maven\nLes liens Maven 1. ModÃ¨le du projet Maven pour la recherche dans Eclipse ou IntelliJ maven-archetype-quickstart\rorg.apache.maven.archetypes:maven-archetype-quickstart\r2. Lien vers maven repository 3. Comment crÃ©er un projet Maven dans Eclipse 4. Les dÃ©pendances utiles ğŸŒ¼ DÃ©pendance FasterXml pour les Jsons\n\u003cdependency\u003e\r\u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e\r\u003cartifactId\u003ejackson-core\u003c/artifactId\u003e\r\u003cversion\u003e2.15.2\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e\r\u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e\r\u003cversion\u003e2.15.2\u003c/version\u003e\r\u003c/dependency\u003e\rjackson-core : gÃ¨re la lecture et lâ€™Ã©criture de flux JSON (bas niveau).\njackson-databind : permet de convertir automatiquement un objet Java en JSON (sÃ©rialisation) et un JSON en objet Java (dÃ©sÃ©rialisation). ğŸ‘‰ Exemple :\nObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(monObjet); // Objet â†’ JSON MonObjet obj = mapper.readValue(json, MonObjet.class); // JSON â†’ Objet\rğŸŒ¼ DÃ©pendance JUNIT 5 â€“ Tests unitaires\n\u003cdependency\u003e\r\u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e\r\u003cartifactId\u003ejunit-jupiter-api\u003c/artifactId\u003e\r\u003cversion\u003e5.11.0\u003c/version\u003e\r\u003cscope\u003etest\u003c/scope\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e\r\u003cartifactId\u003ejunit-jupiter-params\u003c/artifactId\u003e\r\u003cversion\u003e5.11.0\u003c/version\u003e\r\u003cscope\u003etest\u003c/scope\u003e\r\u003c/dependency\u003e\rjunit-jupiter-api : fournit les annotations et lâ€™API pour Ã©crire des tests (@Test, @BeforeEach, etc.).\njunit-jupiter-params : permet de crÃ©er des tests paramÃ©trÃ©s (tester plusieurs valeurs dâ€™entrÃ©e avec un seul test). ğŸ‘‰ Exemple :\n@Test void additionTest() { assertEquals(4, 2 + 2); }\rğŸŒ¼ DÃ©pendance Apache Commons Lang \u003cdependency\u003e\r\u003cgroupId\u003eorg.apache.commons\u003c/groupId\u003e\r\u003cartifactId\u003ecommons-lang3\u003c/artifactId\u003e\r\u003cversion\u003e3.17.0\u003c/version\u003e\r\u003c/dependency\u003e\rAjoute des utilitaires pour manipuler les chaÃ®nes de caractÃ¨res, nombres, dates et objets.\nFacilite des opÃ©rations rÃ©pÃ©titives comme StringUtils.isEmpty() ou RandomStringUtils.randomAlphanumeric().\nğŸ‘‰ Exemple :\nif (StringUtils.isBlank(nom)) { throw new IllegalArgumentException(\"Le nom ne peut pas Ãªtre vide\"); }\rğŸŒ¼ DÃ©pendance Apache Commons IO\n\u003cdependency\u003e\r\u003cgroupId\u003ecommons-io\u003c/groupId\u003e\r\u003cartifactId\u003ecommons-io\u003c/artifactId\u003e\r\u003cversion\u003e2.16.1\u003c/version\u003e\r\u003c/dependency\u003e\rFournit des utilitaires pour travailler avec les fichiers, flux et chemins.\nSimplifie les lectures/Ã©critures et la copie de fichiers.\nğŸ‘‰ Exemple :\nString contenu = FileUtils.readFileToString(new File(\"data.txt\"), StandardCharsets.UTF_8);\rğŸŒ¼ DÃ©pendance Project Lombok\n\u003cdependency\u003e\r\u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e\r\u003cartifactId\u003elombok\u003c/artifactId\u003e\r\u003cversion\u003e1.18.34\u003c/version\u003e\r\u003cscope\u003eprovided\u003c/scope\u003e\r\u003c/dependency\u003e\rGÃ©nÃ©re automatiquement du code rÃ©pÃ©titif (getters, setters, constructeurs, toStringâ€¦) grÃ¢ce Ã  des annotations.\nRÃ©duit la verbositÃ© dans les classes Java. ğŸ‘‰ Exemple :\n@Data // gÃ©nÃ¨re getters, setters, equals, hashCode, toString @AllArgsConstructor public class Etudiant { private int id; private String nom; }\rğŸŒ¼ DÃ©pendance Driver MariaDB\n\u003cdependency\u003e\r\u003cgroupId\u003eorg.mariadb.jdbc\u003c/groupId\u003e\r\u003cartifactId\u003emariadb-java-client\u003c/artifactId\u003e\r\u003cversion\u003e3.4.1\u003c/version\u003e\r\u003c/dependency\u003e\rPermet de connecter une application Java Ã  une base MariaDB/MySQL via JDBC.\nğŸ‘‰ Exemple :\nConnection conn = DriverManager.getConnection( \"jdbc:mariadb://localhost:3306/maBase\", \"user\", \"password\" );\rğŸŒ¼ DÃ©pendance Itext pdf\n\u003cdependency\u003e\r\u003cgroupId\u003ecom.itextpdf\u003c/groupId\u003e\r\u003cartifactId\u003eitextpdf\u003c/artifactId\u003e\r\u003cversion\u003e5.5.13.3\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003ecom.lowagie\u003c/groupId\u003e\r\u003cartifactId\u003eitext\u003c/artifactId\u003e\r\u003cversion\u003e2.1.7\u003c/version\u003e\r\u003c/dependency\u003e\ritextpdf : crÃ©er et manipuler des fichiers PDF.\ncom.lowagie:itext : ancienne version, encore utilisÃ©e dans certains projets pour la compatibilitÃ©.\nğŸ‘‰ Exemple :\nDocument doc = new Document(); PdfWriter.getInstance(doc, new FileOutputStream(\"fichier.pdf\")); doc.open(); doc.add(new Paragraph(\"Bonjour PDF !\")); doc.close();\rğŸŒ¼ DÃ©pendance Java MAIL\n\u003cdependency\u003e\r\u003cgroupId\u003ecom.sun.mail\u003c/groupId\u003e\r\u003cartifactId\u003ejavax.mail\u003c/artifactId\u003e\r\u003cversion\u003e1.6.0\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003ejavax.activation\u003c/groupId\u003e\r\u003cartifactId\u003eactivation\u003c/artifactId\u003e\r\u003cversion\u003e1.1.1\u003c/version\u003e\r\u003c/dependency\u003e\rjavax.mail : envoi et rÃ©ception de mails via SMTP, POP3, IMAP.\nactivation : permet de gÃ©rer les piÃ¨ces jointes (MIME types).\nğŸ‘‰ Exemple :\nMimeMessage message = new MimeMessage(session); message.setSubject(\"Bonjour\"); message.setText(\"Ceci est un test !\"); Transport.send(message);\rğŸŒ¼ DÃ©pendance Google ZXing â€“ Code-barres / QR codes\n\u003cdependency\u003e\r\u003cgroupId\u003ecom.google.zxing\u003c/groupId\u003e\r\u003cartifactId\u003ecore\u003c/artifactId\u003e\r\u003cversion\u003e3.5.2\u003c/version\u003e\r\u003c/dependency\u003e\r\u003cdependency\u003e\r\u003cgroupId\u003ecom.google.zxing\u003c/groupId\u003e\r\u003cartifactId\u003ejavase\u003c/artifactId\u003e\r\u003cversion\u003e3.5.2\u003c/version\u003e\r\u003c/dependency\u003e\rcore : librairie principale pour gÃ©nÃ©rer et lire des codes-barres/QR codes.\njavase : intÃ©gration avec Java standard (Image I/O, BufferedImage).\nğŸ‘‰ Exemple :\nQRCodeWriter qrCodeWriter = new QRCodeWriter(); BitMatrix matrix = qrCodeWriter.encode(\"Hello\", BarcodeFormat.QR_CODE, 200, 200); MatrixToImageWriter.writeToPath(matrix, \"PNG\", Path.of(\"qr.png\"));\rğŸŒ¼ Fix to slf4j (Simple Logger)\n\u003cdependency\u003e\r\u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e\r\u003cartifactId\u003eslf4j-simple\u003c/artifactId\u003e\r\u003cversion\u003e1.7.21\u003c/version\u003e\r\u003c/dependency\u003e\rslf4j-simple : fournit une implÃ©mentation simple de SLF4J (Simple Logging Facade for Java).\nSert Ã  afficher des logs dans la console sans config lourde (utile en dev).\nğŸ‘‰ Exemple :\nprivate static final Logger logger = LoggerFactory.getLogger(MaClasse.class); logger.info(\"Application dÃ©marrÃ©e\"); logger.error(\"Une erreur est survenue\");",
    "description": "Maven (Project Managment Tool) Creation dâ€™un projet maven: Pour crÃ©er un projet maven on suit les Ã©tape suivantes :\nDans IntelliJ cliquer sur create new project. Cette fois-ci ne pas choisir java mais maven. Vous pouvez cocher la case Create from archetype. Vous pouvez choisir maven-archetype-quickstart (dans notre cas pas besoin on va configurer notre projet par nous mÃªme). cliquez sur next.",
    "tags": [],
    "title": "Maven",
    "uri": "/420-311/ressourcesutiles/maven/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ ComplexitÃ© algorithmique",
    "content": "ğŸ”¹ Exercice 1 : for (int i = 0; i \u003c n; i++) { System.out.println(i); }\rğŸ‘‰ Quelle est la complexitÃ© temporelle en fonction de n ?\nğŸ”¹ Exercice 2 while (n \u003e 1) { n = n / 2; }\rğŸ‘‰ Quelle est la complexitÃ© temporelle ?\nğŸ”¹ Exercice 3 public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) { if (x == val) return true; } return false; }\rğŸ‘‰ Quelle est la complexitÃ© temporelle dans le pire cas ?\nğŸ”¹Exercice 4 public static void insertionSort(int[] tab) { for (int i = 1; i \u003c tab.length; i++) { int cle = tab[i]; int j = i - 1; while (j \u003e= 0 \u0026\u0026 tab[j] \u003e cle) { tab[j+1] = tab[j]; j--; } tab[j+1] = cle; } }\rğŸ‘‰ Quelle est la complexitÃ© dans le meilleur cas et dans le pire cas ?\nğŸ”¹Exercice 5 Classez les algorithmes suivants du plus rapide au plus lent quand n devient trÃ¨s grand :\nO(nÂ²) O(n log n) O(n) O(log n) ğŸ”¹Exercice 6 Vous avez ce code :\nfor (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j *= 2) { System.out.println(i + \",\" + j); } }\rğŸ‘‰ Quelle est la complexitÃ© de cet algorithme ? Expliquez.\nğŸ”¹Exercice 7 public static int somme(int[] tab) { int total = 0; for (int n : tab) { total += n; } return total; }\rğŸ‘‰ Question : Quelle est la complexitÃ© spatiale de cette mÃ©thode ? Justifiez votre rÃ©ponse.\nğŸ”¹Exercice 8 public static int[] doubleTableau(int[] tab) { int[] resultat = new int[tab.length]; for (int i = 0; i \u003c tab.length; i++) { resultat[i] = tab[i] * 2; } return resultat; }\rğŸ‘‰ Question : Combien de mÃ©moire supplÃ©mentaire est utilisÃ©e par rapport Ã  la taille de lâ€™entrÃ©e n ?\nğŸ”¹Exercice 9 int[][] matrice = new int[n][n];\rğŸ‘‰ Question : Quelle est la complexitÃ© spatiale de cette structure ?\nğŸ”¹Exercice 10 On veut calculer la suite de Fibonacci :\nVersion rÃ©cursive simple :\npublic static int fib(int n) { if (n \u003c= 1) return n; return fib(n - 1) + fib(n - 2); }\rVersion avec mÃ©moÃ¯sation :\npublic static int fibMemo(int n, int[] memo) { if (memo[n] != 0) return memo[n]; if (n \u003c= 1) return n; memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo); return memo[n]; }\rğŸ‘‰ Questions :\nQuelle est la complexitÃ© spatiale des deux versions ? Pourquoi la version avec mÃ©moÃ¯sation consomme plus de mÃ©moire mais gagne en temps ? ğŸ”¹Exercice 11 : Ã‰crivez un programme qui :\nCrÃ©ez un tableau de 1 million dâ€™entiers. CrÃ©ez une LinkedList et un ArrayList chacun contenant 1 million dâ€™entiers. Comparez la mÃ©moire consommÃ©e (avec Runtime.getRuntime().totalMemory() - freeMemory()) pour chaque structure. Observer concrÃ¨tement lâ€™impact de la structure choisie sur la mÃ©moire. Que remarquez vous ?",
    "description": "ğŸ”¹ Exercice 1 : for (int i = 0; i \u003c n; i++) { System.out.println(i); }\rğŸ‘‰ Quelle est la complexitÃ© temporelle en fonction de n ?\nğŸ”¹ Exercice 2 while (n \u003e 1) { n = n / 2; }\rğŸ‘‰ Quelle est la complexitÃ© temporelle ?\nğŸ”¹ Exercice 3 public static boolean rechercheLineaire(int[] tab, int val) { for (int x : tab) { if (x == val) return true; } return false; }\rğŸ‘‰ Quelle est la complexitÃ© temporelle dans le pire cas ?",
    "tags": [],
    "title": "ğŸ“ Exercices sur complexitÃ© algorithmique",
    "uri": "/420-311/complexalgo/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Ressources utiles",
    "content": "Les algorithmes de tri",
    "description": "Les algorithmes de tri",
    "tags": [],
    "title": "Cartes mentales",
    "uri": "/420-311/ressourcesutiles/cartesmentales/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-311/categories/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Ressources utiles",
    "content": "Nommage des Packages Le nom dâ€™un package doit respecter les conventions suivantes :\nTout en minuscule. Utiliser seulement [a-z], [0-9] et le point â€˜.â€™ *Ne pas utiliser de tiret â€˜-â€™, dâ€™Under score â€˜_â€™, dâ€™espace, ou dâ€™autres caractÃ¨res ($, , accents, â€¦). Remarque :\nLa convention dâ€™Oracle indique que tout package doit avoir comme root un des packages suivants : com, edu, gov, mil, net, org. ExÂ : com.monprojet.bean\nNommage des Classes et Interfaces Le nom dâ€™une classe doit respecter les conventions suivantes :\n1re lettre en majuscule. MÃ©lange de minuscules, majuscule avec la premiÃ¨re lettre de chaque mot en majuscule. Donner des noms simples et descriptifs. Ã‰viter les acronymes. Remarque :\nNâ€™utiliser que les lettres [a-z] et [A-Z] et [0-9] *Ne pas utiliser de tiret â€˜-â€™, dâ€™Under score â€˜_â€™, ou dâ€™autres caractÃ¨res ($, , accents, â€¦). Nommage des Variables Le nom dâ€™une variable doit respecter les conventions suivantes :\n1re lettre en minuscule. MÃ©lange de minuscules, majuscule avec la premiÃ¨re lettre de chaque mot en majuscule. Donner des noms simples et descriptifs. Ne pas commencer les noms avec â€˜$â€™ ou â€˜_â€™ bien que ce soit possible. Variable dâ€™une seule lettre (pour un usage localÂ : variable de mÃ©thode) int : i, j, k, m, et n char : c, d, et e Remarque :\nNâ€™utiliser que les lettres [a-z] et [A-Z] et [0-9] *Ne pas utiliser de tiret â€˜-â€™, dâ€™Under score â€˜_â€™, ou dâ€™autres caractÃ¨res ($, , accents â€¦). Nommage des Constantes Le nom dâ€™une constante doit respecter les conventions suivantes :\nTout en majuscule. SÃ©parer les mots par Under score â€˜_â€™. Donner des noms simples et descriptifs. Remarque :\nNâ€™utiliser que les lettres [A-Z], [0-9] et â€˜_â€™ : *Ne pas utiliser de tiret â€˜-â€™ ou dâ€™autres caractÃ¨res ($, , accents â€¦).",
    "description": "Nommage des Packages Le nom dâ€™un package doit respecter les conventions suivantes :\nTout en minuscule. Utiliser seulement [a-z], [0-9] et le point â€˜.â€™ *Ne pas utiliser de tiret â€˜-â€™, dâ€™Under score â€˜_â€™, dâ€™espace, ou dâ€™autres caractÃ¨res ($, , accents, â€¦). Remarque :\nLa convention dâ€™Oracle indique que tout package doit avoir comme root un des packages suivants : com, edu, gov, mil, net, org. ExÂ : com.monprojet.bean\nNommage des Classes et Interfaces Le nom dâ€™une classe doit respecter les conventions suivantes :",
    "tags": [],
    "title": "Convention de programmation et de nommage",
    "uri": "/420-311/ressourcesutiles/javaconv/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Genericity",
    "content": "ğŸ”¹ Introduction ğŸŒ¼ Le terme gÃ©nÃ©rique est un concept introduit dans Java depuis la version 5.\nLa gÃ©nÃ©ricitÃ© (ou generics) en Java permet de crÃ©er des classes, interfaces et mÃ©thodes paramÃ©trÃ©es par des types.\nğŸ‘‰ Cela signifie quâ€™on peut Ã©crire du code rÃ©utilisable et indÃ©pendant du type exact des objets manipulÃ©s.\nğŸŒ¼ Lâ€™ensemble de la famille Collection est basÃ© sur les gÃ©nÃ©riques pour la sÃ©curitÃ© de type.\nğŸŒ¼ Les gÃ©nÃ©riques permettent aux types (classes et interfaces) dâ€™Ãªtre des paramÃ¨tres lors de la dÃ©finition de classes, dâ€™interfaces et de mÃ©thodes.\nSans gÃ©nÃ©ricitÃ© : on manipule souvent des Object et on doit faire du casting.\nAvec gÃ©nÃ©ricitÃ© : on prÃ©cise le type attendu, et le compilateur assure la sÃ©curitÃ© des types.\nğŸŒ¼ Les paramÃ¨tres de type gÃ©nÃ©rique vous permettent de rÃ©utiliser le mÃªme code avec des entrÃ©es diffÃ©rentes.\nğŸ”¹ Type gÃ©nÃ©rique ğŸŒ¼ Un type gÃ©nÃ©rique est une classe ou une interface paramÃ©trÃ©e sur des types.\nğŸŒ¼ Nous utilisons des crochets angulaires (\u003c\u003e) pour spÃ©cifier le paramÃ¨tre type. Nous pouvons dÃ©finir nos propres classes avec le type gÃ©nÃ©rique.\nclass NomClasse\u003cT1, T2, T3, ... , Tn\u003e { /* ... */ }\rğŸŒ¼ La section de paramÃ¨tre type, dÃ©limitÃ©e par des crochets (\u003c\u003e), suit le nom de la classe. Cela spÃ©cifie les paramÃ¨tres de type (Ã©galement appelÃ©s variables de type) T1, T2, â€¦ et Tn.\nğŸ”¹ Exemple simple : une boÃ®te (Box) Sans gÃ©nÃ©ricitÃ© class Box { private Object contenu; public void setContenu(Object contenu) { this.contenu = contenu; } public Object getContenu() { return contenu; } } // Utilisation Box b = new Box(); b.setContenu(\"Bonjour\"); String texte = (String) b.getContenu(); // âš ï¸ Il faut caster\râš ï¸ ProblÃ¨me : si on met un Integer mais quâ€™on cast en String, cela provoque une ClassCastException.\nAvec gÃ©nÃ©ricitÃ© class Box\u003cT\u003e { private T contenu; public void setContenu(T contenu) { this.contenu = contenu; } public T getContenu() { return contenu; } } // Utilisation Box\u003cString\u003e b = new Box\u003c\u003e(); b.setContenu(\"Bonjour\"); String texte = b.getContenu(); // âœ… Pas de cast nÃ©cessaire\rDans cete exemple, T est un paramÃ¨tre de type. Lors de lâ€™utilisation, on prÃ©cise Box\u003cString\u003e, donc T = String.\nğŸ”¹ Conventions de nommage des paramÃ¨tres de type ğŸŒ¼ Par convention, les noms de paramÃ¨tre de type sont des lettres simples majuscules.\nğŸŒ¼ Les conventions de dÃ©nomination des paramÃ¨tres de type sont importantes pour apprendre les gÃ©nÃ©riques de maniÃ¨re approfondie.\nğŸŒ¼ Les noms de paramÃ¨tre de type les plus couramment utilisÃ©s sont :\nE : Element ( largement utilisÃ© par les collections Java) K: Key N: Number T: Type V : Value S, U, V etc. 2nd, 3rd, 4th types ğŸ”¹ Les collections et la gÃ©nÃ©ricitÃ© En Java, toutes les collections (List, Set, Map, etc.) utilisent la gÃ©nÃ©ricitÃ©.\nList\u003cString\u003e noms = new ArrayList\u003c\u003e(); noms.add(\"Alice\"); noms.add(\"Bob\"); String premier = noms.get(0); // âœ… pas besoin de cast\rSans gÃ©nÃ©ricitÃ©, List stockait des Object et obligeait au cast. Avec gÃ©nÃ©ricitÃ©, on gagne en sÃ©curitÃ© et en lisibilitÃ©.\nğŸ”¹ MÃ©thodes gÃ©nÃ©riques ğŸŒ¼ Les mÃ©thodes gÃ©nÃ©riques sont des mÃ©thodes qui introduisent leurs propres paramÃ¨tres de type.\nğŸŒ¼ Ceci est similaire Ã  la dÃ©claration dâ€™un type gÃ©nÃ©rique, mais la portÃ©e du paramÃ¨tre type est limitÃ©e Ã  la mÃ©thode oÃ¹ il est dÃ©clarÃ©.\nğŸŒ¼ Les mÃ©thodes gÃ©nÃ©riques statiques et non statiques sont autorisÃ©es, ainsi que les constructeurs de classes gÃ©nÃ©riques.\npublic class Util { public static \u003cT\u003e void afficher(T element) { System.out.println(element); } } // Utilisation Util.afficher(\"Hello\"); // String Util.afficher(123); // Integer Util.afficher(3.14); // Double\rDans cet exemple, \u003cT\u003e indique que la mÃ©thode est gÃ©nÃ©rique et peut recevoir nâ€™importe quel type.\nğŸ”¹ Les bornes (extends / super) On peut restreindre les types autorisÃ©s.\nExemple : extends class BoiteNombre\u003cT extends Number\u003e { private T valeur; public BoiteNombre(T valeur) { this.valeur = valeur; } public double doubleValue() { return valeur.doubleValue(); } } // Utilisation BoiteNombre\u003cInteger\u003e b1 = new BoiteNombre\u003c\u003e(5); BoiteNombre\u003cDouble\u003e b2 = new BoiteNombre\u003c\u003e(3.14); // BoiteNombre\u003cString\u003e b3 = new BoiteNombre\u003c\u003e(\"texte\"); âŒ Erreur\rExemple : super Permet de travailler avec des super-types. Utile dans les mÃ©thodes avec collections (principe PECS : Producer Extends, Consumer Super) : Si la collection produit des Ã©lÃ©ments â†’ on utilise extends. Si la collection consomme des Ã©lÃ©ments â†’ on utilise super.\nimport java.util.*; public class DemoPECS { public static void afficherNombres(List\u003c? extends Number\u003e nombres) { for (Number n : nombres) { System.out.println(n); } } public static void main(String[] args) { List\u003cInteger\u003e entiers = Arrays.asList(1, 2, 3); List\u003cDouble\u003e doubles = Arrays.asList(3.14, 2.71); afficherNombres(entiers); // OK afficherNombres(doubles); // OK } }\rDans cet exemple, List\u003c? extends Number\u003e accepte une liste de Integer, Double, etc. Mais âš ï¸ on ne peut pas ajouter dâ€™Ã©lÃ©ments dans la liste (sauf null) car on ne connaÃ®t pas le type exact.\nimport java.util.*; public class DemoPECS { public static void ajouterEntiers(List\u003c? super Integer\u003e liste) { liste.add(10); liste.add(20); // liste.add(3.14); // âŒ impossible car pas sÃ»r que ce soit acceptÃ© } public static void main(String[] args) { List\u003cInteger\u003e entiers = new ArrayList\u003c\u003e(); List\u003cNumber\u003e nombres = new ArrayList\u003c\u003e(); List\u003cObject\u003e objets = new ArrayList\u003c\u003e(); ajouterEntiers(entiers); // OK ajouterEntiers(nombres); // OK ajouterEntiers(objets); // OK } }\rDans cet exemple, List\u003c? super Integer\u003e accepte une List, List ou List. On peut donc y insÃ©rer des Integer en toute sÃ©curitÃ©.\nğŸ”¹ Avantages de la gÃ©nÃ©ricitÃ© 1. SÃ©curitÃ© des types (ContrÃ´les de type au moment de la compilation) â–¶ï¸ Un compilateur Java applique une vÃ©rification de type stricte au code gÃ©nÃ©rique et gÃ©nÃ¨re des erreurs si le code viole la sÃ©curitÃ© du type â†’ plus de ClassCastException au runtime. â–¶ï¸ Il est plus facile de corriger les erreurs de compilation que de rÃ©parer les erreurs dâ€™exÃ©cution, qui peuvent Ãªtre difficiles Ã  trouver.\n2. RÃ©utilisabilitÃ© â–¶ï¸ On Ã©crit une seule classe ou mÃ©thode pour plusieurs types.\n3. LisibilitÃ© â–¶ï¸ on sait immÃ©diatement quel type est attendu.\nğŸ”¹ InconvÃ©nients des gÃ©nÃ©riques â—€ï¸ Impossible dâ€™instancier des types gÃ©nÃ©riques avec des types primitifs Les gÃ©nÃ©riques ne fonctionnent quâ€™avec des types objets, pas avec les types primitifs (int, double, char, etc.) -\u003e Solution : utiliser les classes enveloppes (Integer, Double, Character, etc.).\nâ—€ï¸ Impossible de crÃ©er des instances de paramÃ¨tres de type On ne peut pas Ã©crire :\nclass Box\u003cT\u003e { private T contenu; public Box() { contenu = new T(); // âŒ Erreur } }\râ—€ï¸ Impossible de dÃ©clarer des champs statiques dont les types sont des paramÃ¨tres de type Le paramÃ¨tre gÃ©nÃ©rique T nâ€™existe quâ€™au niveau instance, pas au niveau classe statique.\nâŒ Exemple invalide :\nclass Box\u003cT\u003e { private static T contenu; // âŒ Erreur }\râ—€ï¸ Impossible dâ€™utiliser des casts ou des instancesof avec des types paramÃ©trÃ©s Java utilise lâ€™effacement de types (type erasure). Cela signifie que List et List deviennent la mÃªme chose Ã  lâ€™exÃ©cution : juste List.\nâŒ Exemple invalide :\nList\u003cString\u003e liste = new ArrayList\u003c\u003e(); if (liste instanceof List\u003cString\u003e) { // âŒ Erreur ... }\rOn peut tester uniquement la forme brute (raw type).\nif (liste instanceof List) { // âœ… System.out.println(\"C'est bien une liste !\"); }\râ—€ï¸ Impossible de crÃ©er des tableaux de types paramÃ©trÃ©s âŒ Exemple invalide :\nList\u003cString\u003e[] tableau = new ArrayList\u003cString\u003e[10]; // âŒ Erreur\rCar cela provoquerait des problÃ¨mes de compatibilitÃ© (ex. : insÃ©rer un List par erreur) -\u003e Solution : utiliser des collections (List\u003cList\u003e) ou faire un cast avec prÃ©caution.\nList\u003cList\u003cString\u003e\u003e tableau = new ArrayList\u003c\u003e(); tableau.add(new ArrayList\u003c\u003e()); tableau.get(0).add(\"Bonjour\");\rIci, au lieu dâ€™un tableau, on utilise une collection de collections.\nâ—€ï¸ Impossible de crÃ©er, dâ€™attraper ou de lancer des objets de types paramÃ©trÃ©s On ne peut pas utiliser un type paramÃ©trÃ© dans une exception, car les exceptions doivent Ãªtre dÃ©terminÃ©es au moment de la compilation.\nâŒ Exemple invalide :\nclass MyException\u003cT\u003e extends Exception { } // âŒ Erreur\rEt on ne peut pas non plus :\ntry { // ... } catch (T e) { // âŒ Impossible ... }\rLien vers la documentation Oracle\nğŸ¯ Exemple rÃ©capitulatif // MÃ©thode gÃ©nÃ©rique qui retourne le plus grand Ã©lÃ©ment d'une liste public static \u003cT extends Comparable\u003cT\u003e\u003e T max(List\u003cT\u003e liste) { T max = liste.get(0); for (T elem : liste) { if (elem.compareTo(max) \u003e 0) { max = elem; } } return max; } // Utilisation List\u003cInteger\u003e entiers = Arrays.asList(3, 7, 2, 9, 5); System.out.println(max(entiers)); // 9\rRÃ©flexions sur les gÃ©nÃ©riques ğŸŒ¼ Le code gÃ©nÃ©rique nous permet de crÃ©er du code polyvalent et rÃ©utilisable qui peut fonctionner avec nâ€™importe quel type en fonction de nos contraintes spÃ©cifiÃ©es. Cela minimise la duplication de code et transmet son objectif de maniÃ¨re plus abstraite.\nğŸŒ¼ Cependant, les gÃ©nÃ©riques ne sont pas sans dÃ©fauts. En Java, les gÃ©nÃ©riques sont dÃ©finitivement une fonctionnalitÃ© essentielle. Mais pour Ãªtre honnÃªte, leur mise en Å“uvre peut parfois sembler alambiquÃ©e et insuffisante, surtout par rapport Ã  dâ€™autres langages.\nğŸŒ¼ Pour les dÃ©veloppeurs utilisant des API gÃ©nÃ©riques, celles-ci sont gÃ©nÃ©ralement simples Ã  utiliser et offrent des fonctionnalitÃ©s substantielles.\nğŸŒ¼ En revanche, lâ€™Ã©criture dâ€™API gÃ©nÃ©riques peut sâ€™avÃ©rer plus difficile. Personnellement, jâ€™apprÃ©cie lâ€™idÃ©e de crÃ©er des outils puissants, mais complexes pour Ã©crire du code sans imposer le mÃªme niveau de complexitÃ© Ã  ceux qui utilisent le code.\nğŸŒ¼ Les concepteurs de langage doivent toujours faire des compromis et dÃ©cider de leur prioritÃ© absolue. Et dans la bonne tradition Java, la rÃ©trocompatibilitÃ© Ã©tait une prioritÃ© absolue.\nLien vers statistiques langages de programmation 2024\nRessources Documentation : Generic Types\nDocumentation : Restrictions on Generics",
    "description": "ğŸ”¹ Introduction ğŸŒ¼ Le terme gÃ©nÃ©rique est un concept introduit dans Java depuis la version 5.\nLa gÃ©nÃ©ricitÃ© (ou generics) en Java permet de crÃ©er des classes, interfaces et mÃ©thodes paramÃ©trÃ©es par des types.\nğŸ‘‰ Cela signifie quâ€™on peut Ã©crire du code rÃ©utilisable et indÃ©pendant du type exact des objets manipulÃ©s.\nğŸŒ¼ Lâ€™ensemble de la famille Collection est basÃ© sur les gÃ©nÃ©riques pour la sÃ©curitÃ© de type.\nğŸŒ¼ Les gÃ©nÃ©riques permettent aux types (classes et interfaces) dâ€™Ãªtre des paramÃ¨tres lors de la dÃ©finition de classes, dâ€™interfaces et de mÃ©thodes.",
    "tags": [],
    "title": "La gÃ©nÃ©ricitÃ© en Java",
    "uri": "/420-311/genericity/javagen/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-311/tags/index.html"
  }
]
