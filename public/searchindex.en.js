var relearn_searchindex = [
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Dans ce chapitre nous allons dÃ©couvrir quelques structures de donnÃ©es et apprendre Ã  choisir la bonne structure selon le problÃ¨me.\nâ“‚ï¸ Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util).\nâ“‚ï¸ On y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nâ“‚ï¸ Nous commencerons par examiner les concepts communs quâ€™elles (structures de donnÃ©es) exploitent ainsi : gÃ©nÃ©ricitÃ©, itÃ©rateur, ordonnancement et relation dâ€™ordre.\nâ“‚ï¸ Nous verrons Ã©galement quelles sont les opÃ©rations qui leur sont communes : ajout ou suppression dâ€™Ã©lÃ©ments, construction Ã  partir des Ã©lÃ©ments dâ€™une autre collectionâ€¦\nâ“‚ï¸ Nous Ã©tudierons ensuite en dÃ©tail chacune de ces structures, Ã  savoir :\nğŸŒ± Les listes, implÃ©mentÃ©es par la classe LinkedList;\rğŸŒ± Les vecteurs dynamiques, implÃ©mentÃ©s par les classes ArrayList et Vector;\rğŸŒ± Les ensembles, implÃ©mentÃ©s par les classes HashSet et TreeSet;\rğŸŒ± Les queues avec prioritÃ©, implÃ©mentÃ©es par la classe PriorityQueue (introduite par le JDK 5.0) ;\rğŸŒ± Les queues Ã  double entrÃ©e, implÃ©mentÃ©es par la classe ArrayDeque (introduite par Java6).",
    "description": "Dans ce chapitre nous allons dÃ©couvrir quelques structures de donnÃ©es et apprendre Ã  choisir la bonne structure selon le problÃ¨me.\nâ“‚ï¸ Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util).\nâ“‚ï¸ On y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nâ“‚ï¸ Nous commencerons par examiner les concepts communs quâ€™elles (structures de donnÃ©es) exploitent ainsi : gÃ©nÃ©ricitÃ©, itÃ©rateur, ordonnancement et relation dâ€™ordre.",
    "tags": [],
    "title": "SDD",
    "uri": "/420-311/sdd/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "Dans ce module nous ferons une courte rÃ©vision des notions essentielles au cours.",
    "description": "Dans ce module nous ferons une courte rÃ©vision des notions essentielles au cours.",
    "tags": [],
    "title": "PrÃ©alables",
    "uri": "/420-311/intro/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Rappel : Concepts de base Classe : ModÃ¨le dÃ©finissant les attributs (variables) et comportements (mÃ©thodes).\nObjet : Instance concrÃ¨te dâ€™une classe.\nEncapsulation : ProtÃ©ger les donnÃ©es via des modificateurs dâ€™accÃ¨s (private, public, protected) et exposer des mÃ©thodes dâ€™accÃ¨s (getters/setters).\nAbstraction : Masquer les dÃ©tails dâ€™implÃ©mentation et ne montrer que les fonctionnalitÃ©s essentielles (via classes abstraites et interfaces).\nHÃ©ritage : Une classe peut hÃ©riter des attributs et mÃ©thodes dâ€™une autre (mot-clÃ© extends).\nPolymorphisme :\nSurcharge (overloading) : mÃªme nom de mÃ©thode, signatures diffÃ©rentes. RedÃ©finition (overriding) : une sous-classe redÃ©finit le comportement dâ€™une mÃ©thode hÃ©ritÃ©e. Constructeur : MÃ©thode spÃ©ciale exÃ©cutÃ©e lors de la crÃ©ation dâ€™un objet (new).\nModificateurs dâ€™accÃ¨s Modificateur MÃªme classe MÃªme package Sous-classe Partout public âœ… âœ… âœ… âœ… protected âœ… âœ… âœ… âŒ (default) âœ… âœ… âŒ âŒ private âœ… âŒ âŒ âŒ Syntaxe essentielle DÃ©finir une classe public class Voiture { private String marque; private int annee; public Voiture(String marque, int annee) { this.marque = marque; this.annee = annee; } public void demarrer() { System.out.println(marque + \" dÃ©marre !\"); } }\rCrÃ©er un objet Voiture v1 = new Voiture(\"Toyota\", 2022); v1.demarrer();\rHÃ©ritage et polymorphisme class Animal { public void parler() { System.out.println(\"??\"); } } class Chien extends Animal { @Override public void parler() { System.out.println(\"Woof\"); } } Animal a = new Chien(); // polymorphisme a.parler(); // \"Woof\"\rAbstraction et interfaces abstract class Forme { abstract double aire(); } class Cercle extends Forme { private double r; Cercle(double r) { this.r = r; } @Override double aire() { return Math.PI * r * r; } } interface Volant { void voler(); } class Avion implements Volant { public void voler() { System.out.println(\"En vol âœˆï¸\"); } }\rClasses utiles Object : classe racine de toutes les classes Java. MÃ©thodes importantes : toString(), equals(), hashCode(), clone().\nfinal :\nfinal class : non-hÃ©ritÃ©e. final method : non-redÃ©finissable. final variable : constante. Gestion mÃ©moire Les objets sont crÃ©Ã©s sur le tas (heap) via new. Le garbage collector libÃ¨re automatiquement la mÃ©moire des objets non rÃ©fÃ©rencÃ©s. Bonnes pratiques Utiliser private pour protÃ©ger les donnÃ©es. Toujours redÃ©finir toString() pour reprÃ©senter un objet. Respecter la cohÃ©rence equals() / hashCode(). Favoriser la composition plutÃ´t que lâ€™hÃ©ritage trop profond. Documenter avec JavaDoc (/** â€¦ */). Exemple : package s01; class Etudiant { private String nom; private int age; public Etudiant(String nom, int age) { this.nom = nom; this.age = age; } public void afficherInfos() { System.out.println(\"Nom : \" + nom + \", Ã‚ge : \" + age); } } class EtudiantRegulier extends Etudiant { private String programme; public EtudiantRegulier(String nom, int age, String programme) { super(nom, age); this.programme = programme; } @Override public void afficherInfos() { super.afficherInfos(); System.out.println(\"Programme : \" + programme); } } public class RappelPOO { public static void main(String[] args) { EtudiantRegulier e = new EtudiantRegulier(\"Alice\", 20, \"Informatique\"); e.afficherInfos(); } }\rğŸ“˜ RÃ©sumÃ© de rÃ©vision â€“ POO ğŸ”¹ 1. Classes Une classe public est accessible depuis nâ€™importe quel package. Une classe abstract sert de modÃ¨le, ne peut pas Ãªtre instanciÃ©e et peut contenir des mÃ©thodes abstraites. Une classe final ne peut pas Ãªtre hÃ©ritÃ©e. Une classe private nâ€™est possible quâ€™en classe interne (nested class). Toute classe hÃ©rite implicitement de Object â†’ possÃ¨de donc les mÃ©thodes toString(), equals(), hashCode(), etc. ğŸ”¹ 2. Constructeurs Si aucune dÃ©claration â†’ le compilateur gÃ©nÃ¨re un constructeur par dÃ©faut (sans paramÃ¨tres). Un constructeur peut Ãªtre private (utilisÃ© dans le pattern Singleton ou classes utilitaires). ğŸ”¹ 3. MÃ©thodes Les mÃ©thodes peuvent Ãªtre surchargÃ©es (overloading) â†’ mÃªme nom, paramÃ¨tres diffÃ©rents. Les mÃ©thodes peuvent Ãªtre surdÃ©finies (overriding) â†’ mÃªme signature, dans une sous-classe. Une mÃ©thode final ne peut pas Ãªtre redÃ©finie dans une sous-classe. Une mÃ©thode abstract est dÃ©clarÃ©e sans corps et doit Ãªtre implÃ©mentÃ©e dans une sous-classe. abstract et final sont incompatibles (contradiction). ğŸ”¹ 4. Attributs Un attribut final est une constante : doit Ãªtre initialisÃ© une seule fois (dÃ©claration ou constructeur). ğŸ”¹ 5. Interfaces Une interface ne peut pas Ãªtre instanciÃ©e.\nUne interface nâ€™est pas un objet, câ€™est un contrat.\nUne interface nâ€™hÃ©rite pas dâ€™Object, mais les classes qui lâ€™implÃ©mentent hÃ©ritent dâ€™Object.\nUne interface peut hÃ©riter dâ€™une ou plusieurs autres interfaces avec extends.\nUne interface ne peut pas hÃ©riter dâ€™une classe.\nMÃ©thodes dans une interface :\nAvant Java 8 â†’ uniquement public abstract. Depuis Java 8 â†’ mÃ©thodes default et static avec implÃ©mentation. Depuis Java 9 â†’ mÃ©thodes private pour factoriser du code interne. ğŸ”¹ 6. Comparable vs Comparator Comparable : dÃ©finit lâ€™ordre naturel dâ€™une classe (mÃ©thode compareTo). Comparator : dÃ©finit un ordre externe, peut Ãªtre multiple et personnalisÃ© (mÃ©thode compare). ğŸ”¹ 7. Mots-clÃ©s spÃ©ciaux null â†’ valeur littÃ©rale spÃ©ciale, pas un mot-clÃ©. this â†’ rÃ©fÃ©rence Ã  lâ€™instance courante. super â†’ rÃ©fÃ©rence Ã  la classe parente. RÃ©sumÃ© Ã‰lÃ©ment Description Exemple Classe abstract Non instanciable, modÃ¨le pour hÃ©ritage abstract class Forme { abstract double aire(); } Classe final Ne peut pas Ãªtre hÃ©ritÃ©e final class Utilitaire {} MÃ©thode final Ne peut pas Ãªtre redÃ©finie public final void calcul() {} MÃ©thode abstract Sans corps, Ã  implÃ©menter abstract void afficher(); Attribut final Constante, valeur fixÃ©e une seule fois final double PI = 3.14; Interface Contrat, non instanciable interface Vehicule { void rouler(); } Comparable Ordre naturel, compareTo class Etudiant implements Comparable\u003cEtudiant\u003e Comparator Ordre externe, compare Comparator\u003cEtudiant\u003e parNom = ...;",
    "description": "Rappel : Concepts de base Classe : ModÃ¨le dÃ©finissant les attributs (variables) et comportements (mÃ©thodes).\nObjet : Instance concrÃ¨te dâ€™une classe.\nEncapsulation : ProtÃ©ger les donnÃ©es via des modificateurs dâ€™accÃ¨s (private, public, protected) et exposer des mÃ©thodes dâ€™accÃ¨s (getters/setters).\nAbstraction : Masquer les dÃ©tails dâ€™implÃ©mentation et ne montrer que les fonctionnalitÃ©s essentielles (via classes abstraites et interfaces).\nHÃ©ritage : Une classe peut hÃ©riter des attributs et mÃ©thodes dâ€™une autre (mot-clÃ© extends).",
    "tags": [],
    "title": "RÃ©vision",
    "uri": "/420-311/intro/revisionpoo/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Questions thÃ©oriques Question 1 : Quel est le rÃ©sultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le rÃ©sultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le rÃ©sultat du code suivant:\npublic class Question3 { public static void main(String[]args) { int val1 = 9; int val2 = 9; String str = \"9\"; System.out.println(val1 + val2 + str);\t} }\rQuestion 4 : Quel est le rÃ©sultat du code suivant:\npublic class Question4 { public static void main(String[]args) { try { int a, b; b = 0; a = 5 / b; System.out.print(\"A\"); } catch (Exception e) { System.out.print(\"B\"); } finally { System.out.print(\"C\"); }\t} }\rQuestion 5 : Quel est le rÃ©sultat du code suivant:\npublic class Question5 { public static void main(String[]args) { String obj = \"Bonjour\"; String obj1 = \"Bonsoir\"; String obj2 = \"Bonjour\"; System.out.println(obj.equals(obj1) + \" \" + obj.equals(obj2)); } }\rQuestion 6 : Quel est le rÃ©sultat du code suivant:\npublic class ClasseA { public int i; public int j; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.j = 3; System.out.println(i + \" \" + j); } } public class Question6 { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 7 : Quel est le rÃ©sultat du code suivant:\npublic class ClasseA { public int i; } public class ClasseB extends ClasseA { public int j; public void afficheToi() { super.i = j + 1; System.out.println ( j + \" \" + i); } } public class Main { public static void main(String[] args) { ClasseB obj = new ClasseB(); obj.i = 1; obj.j = 2; obj.afficheToi(); } }\rQuestion 8 : Quel est le rÃ©sultat du code suivant:\npublic class Question8{ public static void main(String[] args) { String s = \"Hello World\"; int A = s.indexOf('o'); int B = s.lastIndexOf('l'); System.out.println(A + \" \" + B); } }\rQuestion 9 : Quel est le rÃ©sultat du code suivant:\npublic class Question9{ public static void main(String[] args) { char ch; ch = \"hello\".charAt(1); System.out.println(ch); } }\rQuestion 10 : Quel est le rÃ©sultat du code suivant:\npublic class Question10{ public static void main(String[] args) { String chars[] = {\"a\", \"b\", \"c\", \"a\", \"c\"}; for (int i = 0; i \u003c chars.length; ++i) for (int j = i + 1; j \u003c chars.length; ++j) if(chars[i].compareTo(chars[j]) == 0) System.out.print(chars[j]); } }\rQuestion 11 : Quel est le rÃ©sultat du code suivant:\npublic class Question11{ public static void main(String[] args) { int a1[] = new int[10]; int a2[] = { 1, 2, 3, 4, 5 }; System.out.println(a1.length + \" \" + a2.length); } }\rQuestion 12 : Quel est le rÃ©sultat du code suivant:\npublic class Question12{ public static void main(String[] args) { int arr[] = { 1, 2, 3, 4, 5 }; for (int i = 0; i \u003c arr.length - 2; ++i) System.out.print(arr[i] + \" \"); } }\rQuestion 13 : Quel est le rÃ©sultat du code suivant:\npublic class Question13{ public static int param1; public static int param2; public void add(int a, int b) { param1 = a + b; param2 = param1 + b; } public static void main(String args[]) { Question13 obj1 = new Question13(); Question13 obj2 = new Question13(); int a = 2; obj1.add(a, a + 1); obj2.add(5, a); System.out.println(obj1.param1 + \" \" + obj2.param2); } }\rQuestion 14 : Quel est le rÃ©sultat du code suivant:\nimport java.util.Arrays; public class Question14{ public static void main(String[] args) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 15 : Quel est le rÃ©sultat du code suivant:\npublic class Question15{ public static int param1; public void increment() { param1++; } public static void main(String args[]) { Question15 obj1 = new Question15(); Question15 obj2 = new Question15(); obj1.param1 = 0; obj1.increment(); obj2.increment(); System.out.println(obj1.param1 + \" \" + obj2.param1); } }\rQuestion 16 : Quel est le rÃ©sultat du code suivant:\nimport java.util.Arrays; public class Question16 { public static void main(String args[]) { int tab[] = new int[5]; for (int i = 5; i \u003e 0; i--) { tab[5 - i] = i; } Arrays.sort(tab); for (int i = 0; i \u003c 5; ++i) { System.out.print(tab[i]); } } }\rQuestion 17 : Quel est le rÃ©sultat du code suivant:\npublic class Question17 { public static void main(String[] args) { ClasseB classeB = new ClasseB(); System.out.println(\"Valeur = \" + classeB.calculer(3, 6)); } } class ClassA { final public int calculer(int a, int b) { return 0; } } class ClasseB extends ClasseA { public int calculer(int a, int b) { return 1; } }\rQuestion 18 : Quel est le rÃ©sultat du code suivant:\npublic class Question18 { public static void main (String args[]) { int param1, param2= 1; param1= 10; if (param1!= 10 \u0026\u0026 param1/ 0 == 0) { System.out.println(param2); } else { System.out.println(++param2); } } }\rQuestion 19 : Quel est le rÃ©sultat du code suivant:\npublic class Question19 { public static int param1; public static int param2; public void add(int val1, int val2) { param1 = val1 + val2; param2 = param1 + val2; } public static void main(String[] args) { Question19 instance1 = new Question19 (); Question19 instance2 = new Question19 (); Question19 instance3 = new Question19 (); int abc = 2;\tinstance1.add(abc, abc-1); instance3.add(6, 6/abc); instance2.add(5, abc/2); System.out.println(instance1.param1); System.out.println(instance2.param2); } }\rQuestion 20 : Quel est le rÃ©sultat du code suivant:\nimport java.util.Arrays; public class Question20 { public static void main(String args[]) { int array[] = new int [5]; for (int i = 5; i \u003e 0; i--) { array[5 - i] = i; } Arrays.sort(array); System.out.print(Arrays.toString(array)); } }\rQuestion 21 : Quel est le rÃ©sultat du code suivant:\npublic class Question21 { public static void main(String [] args) { Question21 instance = new Question21(); instance.myMethod(); } public void myMethod(){ long [] tab1 = {6,8,9}; long []tab2 = affectation(tab1); System.out.print(tab1[0] + tab1[1] + tab1[2] + \" \"); System.out.println(tab2[0] + tab2[1] + tab2[2]); } public long[] affectation(long[] tab3){ tab3[1] = 7; return tab3; } }\rExercices pratiques Exercice 1 : Soit la String suivante: A-b-C-d-E-f-1234-***///-\u003e , Ã©crire un programme en Java qui:\nğŸ‘ convertit chaque caractÃ¨re alphabÃ©tique majuscule de la String en un caractÃ¨re minuscule; ğŸ‘ Convertis chaque caractÃ¨re alphabÃ©tique minuscule de la String en un caractÃ¨re majuscule; ğŸ‘ Supprime tous les caractÃ¨res spÃ©ciaux de la String; Exercice 2 : Soit le tableau suivant: String [] days = { \"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\", \"Dimanche\"}; Ã‰crire un programme en Java qui:\nğŸ‘ choisi alÃ©atoirement une journÃ©e du tableau et lâ€™affiche; ğŸ‘ Tri le tableau; Exercice 3 : Soit le code Java suivant:\nString str1 = \"Bonjour\"; String str2 = new String (\"Bonjour\"); str1 == str2; //3 str1.equals(str2); //4\rExpliquez la diffÃ©rence entre les 02 lignes de code (ligne 3 et ligne 4)?\nExercice 4 : Soit la classe Compte bancaire avec les attributs suivants:\nidCpte (numÃ©ro unique: donc 2 comptes ne peuvent pas avoir le mÃªme ID); firstName; lastName; solde; En utilisant les collections Java (List, Set et Map) et en vous utilisant lâ€™API Java, vous devez coder les mÃ©thodes suivantes:\nğŸ‘ addCompteToCollection (List | Set | Map)\rğŸ‘ serachCompteInCollection (List | Set | Map)\rğŸ‘ sortCollection (List | Set | Map)\rğŸ‘ removeCompteFromCollection (List | Set | Map)\rğŸ‘ emptyCollectionComptes (List | Set | Map)\rExercice 5 : Ã‰crire un code Java qui convertit un tableau dâ€™entiers (tableau Ã  crochets) en une collection de type List.\nÃ‰crire un code Java qui convertit une collection de type List en un tableau Ã  crochets.\nÃ‰crire un code Java qui convertit une collection de type List en une collection de Type Set.\nÃ‰crire un code Java qui convertit une collection de type Set en une collection de Type List.\nÃ‰crire un code Java qui convertit une collection de type List en une collection de Type Map.\nÃ‰crire un code Java qui convertit une collection de type Map en une collection de Type List.\nExercice 6 : Soit le tableau de conversion des devises suivant :\nDe Vers Taux Dollar canadien (CAD) Euro 1 CAD = 0.74 EURO Dollar canadien (CAD) Dollar amÃ©ricain (USD) 1 CAD = 0.69 USD Euro Dollar canadien (CAD) 1 EURO = 1.45 CAD Dollar amÃ©ricain (USD) Dollar canadien (CAD) 1 USD = 1.36 CAD Ã‰crire un programme Java qui demande Ã  un utilisateur de choisir un type conversion et saisir un montant Ã  convertir. Le programme traitera la conversion et affichera le montant converti.\nCondition:\nLe programme nâ€™acceptera que les montants entre 90 et 6500, cela dans chaque sorte de devises. Le programme ne doit pas sâ€™arrÃªter tant que lâ€™utilisateur nâ€™aura pas choisi de quitter. Exercice 7 : Soit le systÃ¨me de notation universitaire :\nNote numÃ©rique Note littÃ©rale 90 et + A De 80 Ã  89 B De 70 Ã  79 C De 60 Ã  69 D De 50 Ã  59 E \u003c 50 F Ã‰crire un programme Java qui demande Ã  un utilisateur de saisir 4 notes numÃ©riques. Ensuite le programme calculera la moyenne et affichera la note littÃ©rale correspondante.\nCondition:\nLe programme nâ€™acceptera que les notes entre 0 et 100.\nExemple\nLe programme demande les notes Ã  lâ€™utilisateur : Veuillez saisir vos notes Svp : Lâ€™utilisateur saisit les notes suivantes : 59, 72.5, 83.73, 45.5\nLe programme calculera la moyenne et affichera :\nVotre moyenne numÃ©rique est : 65,18 ce qui donnera en littÃ©rale la note de D.\nExercice 8 : Soit la liste des villes suivantes : Ottawa, Paris, Berne, Washington, Berlin, Madrid, Mexico.\nğŸŒ¼ Ã‰crire un programme Java qui gÃ©nÃ¨re alÃ©atoirement 2 villes parmi la liste des villes et demandera Ã  un utilisateur de deviner les 2 villes au bout de 3 tentatives.\nSi lâ€™utilisateur arrive Ã  deviner les 2 villes alÃ©atoires, le programme affichera un message et quittera. Si lâ€™utilisateur nâ€™arrive pas Ã  deviner les 2 villes alÃ©atoires au bout de 3 tentatives, le programme affichera le rÃ©sultat et quittera. Clarification\nModÃ¨le de message en cas de succÃ¨s de devinette Bravo! Vous avez devinÃ© les 2 villes : Ottawa et Paris. ModÃ¨le de message en cas dâ€™Ã©chec de devinette Oups! En 3 tentatives, vous nâ€™Ãªtes pas arrivÃ© Ã  deviner les 2 villes : Ottawa et Paris. Exercice 9 : On souhaite gÃ©rer une liste de prÃ©noms dâ€™Ã©tudiants dans un cours. RÃ©alise un programme Java qui :\nCrÃ©e une liste de type ArrayList. Ajoute les prÃ©noms suivants : â€œAliceâ€, â€œBobâ€, â€œCharlieâ€, â€œDianeâ€. Affiche la taille de la liste et son contenu. Demande Ã  lâ€™utilisateur dâ€™entrer un prÃ©nom, puis : VÃ©rifie sâ€™il est prÃ©sent dans la liste (affiche un message appropriÃ©). Si prÃ©sent, affiche sa position dans la liste. Supprime un prÃ©nom donnÃ© par lâ€™utilisateur et rÃ©affiche la liste. Trie la liste par ordre alphabÃ©tique et affiche le rÃ©sultat. Exercice 10 : Soit le diagramme de classes suivant :\nCrÃ©er les classes Java correspondant aux classes du diagramme. Il vous faudra respecter les attributs et les relations entre les diffÃ©rentes classes. Ã‰crire une mÃ©thode de service qui permet de calculer le prix rÃ©el dâ€™un produit suivant la rÃ¨gle suivante : a.\tSi le produit est biologique, Â« indiceBio Â» et le produit appartiennent Ã  un fournisseur habitant la province du Â« QuÃ©bec Â», alors le prix rÃ©el est :\ni.\tPrix rÃ©el = prix du produit + prix du produit*tps + prix du produit * tvq. b.\tSi le produit est biologique, Â« indiceBio Â» et le produit appartiennent Ã  un fournisseur habitant le Canada (sauf la province du QuÃ©bec) alors le prix rÃ©el est :\ni.\tPrix rÃ©el = prix du produit + prix du produit*tps. c.\tSi le produit est biologique Â« indiceBio Â» et le produit appartient Ã  un fournisseur habitant les USA alors le prix rÃ©el est :\ni.\tPrix rÃ©el = prix du produit + prix du produit*usTax. Ã‰crire une mÃ©thode de service qui permet de calculer le total prix (la somme totale) des produits de tous les fournisseurs amÃ©ricains.",
    "description": "Questions thÃ©oriques Question 1 : Quel est le rÃ©sultat du code suivant:\npublic class Question1 { public static int methode1() { int i = 0; i++; return i; } public static void main(String[] args) { methode1(); int j = 12; j = methode1(); System.out.println(j); } }\rQuestion 2 : Quel est le rÃ©sultat du code suivant:\npublic class Question2 { public static void main (String[] args) { try { int i, sum; sum = 10; for (i = -1; i \u003c 3 ;++i) { sum = (sum / i); System.out.println(i); } } catch(Exception e) { System.out.print(\"Erreur!\"); }\t} }\rQuestion 3 : Quel est le rÃ©sultat du code suivant:",
    "tags": [],
    "title": "Questions et exercices",
    "uri": "/420-311/intro/exercices/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ PrÃ©alables",
    "content": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code dâ€™Ã©vÃ©nement dans le bandeau supÃ©rieur Quiz 2 : mÃ©thodes et interfaces Quiz Wooclap sur les mÃ©thodes et les interfaces",
    "description": "Quiz 1 : classe et interfaces Quiz Wooclap sur les classes et les interfaces\nAllez sur wooclap.com Entrez le code dâ€™Ã©vÃ©nement dans le bandeau supÃ©rieur Quiz 2 : mÃ©thodes et interfaces Quiz Wooclap sur les mÃ©thodes et les interfaces",
    "tags": [],
    "title": "Quiz",
    "uri": "/420-311/intro/quiz/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©eÂ \u003eÂ Ressources utiles",
    "content": "Introduction Ã  Git Git est un logiciel de contrÃ´le de version. Il permet de gÃ©rer des fichiers et leur Ã©volution dans le temps.\nIl permet de retracer lâ€™origine de chaque modification, de rÃ©tablir des versions prÃ©cÃ©dentes et permet lâ€™intÃ©gration de modifications effectuÃ©es en parallÃ¨le.\nConcept Le principe dâ€™un gestionnaire de version est quâ€™il gÃ¨re un document comme â€œune baseâ€ Ã  laquelle est ajoutÃ© une suite de modifications.\nIl y a un dÃ©pÃ´t commun (Remote) et les contributeurs travaillent sur des versions locales.\nLorsquâ€™un contributeur a rÃ©alisÃ© une modification qui est prÃªte Ã  lâ€™envoyer, il pousse (push) celle-ci vers le dÃ©pÃ´t. Le dÃ©pÃ´t garde la trace avec un identifiant unique.\nGit est en fait un gestionnaire de version dÃ©centralisÃ©. Il y a 2 dÃ©pÃ´ts : remote et local. De plus, il maintient une version brouillon (staged, sandbox) sur le poste local.\nGit clone Lorsque vous devez rÃ©cupÃ©rer le code de votre repository (dÃ©pÃ´t remote):\ngit clone https://github.com/420-411-MV/demo-i18n.git\nSi vous avez configurÃ© la clef SSH dans github par exemple:\ngit clone git@github.com:cegepmv/420-411.git\nGit Commit Le principe de la commande commit est de dÃ©poser les modifications sur une dÃ©pÃ´t local. Il faut Ã©galement Ãªtre vigilant au niveau de la branche utilisÃ© pour le commit. De plus, il est important de mettre souvent Ã  jour la branche avant de procÃ©der Ã  un commit.\nLorsquâ€™on fait la commande commit, on doit y ajouter un message. En entreprise, on joint souvent un identifiant pour rÃ©fÃ©rer Ã  la tÃ¢che en cours. AprÃ¨s cet identifiant, on peut y mettre une description. Par exemple:\nâ€œPRJ-3428: Ajout de tests unitaires sur la mÃ©thode du service getClientsâ€\nLorsquâ€™on relie lâ€™identifiant et les commits, on peut alors connaÃ®tre le travail effectuÃ© dans le code pour une tÃ¢che donnÃ©e dans le systÃ¨me de gestion des projets (Jira, Clickup, Zoho, Zenhub, Asana, Monday.com, etc.).\ngit commit -m \"Votre message\"\rGit Push La commande git push permet de pousser (la branche actuelle de) le local vers le remote : git applique alors successivement tous les commit au remote.\nIl est fortement recommandÃ© de faire un git fetch / pull avant de procÃ©der Ã  celui-ci. Ã€ moins dâ€™Ãªtre seul dans ce repository et/ou la branche visÃ©e.\nGit Fetch, checkout, pull La commande git fetch permet de mettre Ã  jour notre dÃ©pÃ´t local en rÃ©cupÃ©rant lâ€™ Ã©tat courant qui remote. La commande git checkout permet de les appliquer Ã  la copie de travail (et donc de les voir).\nLa commande git pull fait les deux Ã  la fois.\nPensez Ã  vous mettre Ã  jour avant chaque session de travail !\nCâ€™est la premiÃ¨re chose quâ€™un dÃ©veloppeur fait chaque matin en se mettant au travail, dans beaucoup de cas.\nGit status La commande git status vous permet de connaÃ®tre lâ€™Ã©tat courant de vos copies locales (les modifications ont-elles Ã©tÃ© commitÃ©es, les fichiers ajoutÃ©s, les commit pushÃ©).\nLes interface graphiques (dont intelliJ) vous lâ€™indique souvent par des couleurs et icones.\nGit logs La commande vous permet de voir tous les commits et tous les identifiants (Commit ID) pour chaque commit effectuÃ©. Ces commit peuvent Ãªtre fort utili pour faire dâ€™autres commandes tel que git revert, git cherry-pick pour ne nommer que celles-ci.\nGit merge Cette commande permet dâ€™appliquer les changements (fusionner) dâ€™une autre branche Ã  votre branche sÃ©lectionnÃ©e dans votre repository locale. Il y a souvent des conflits lors dâ€™une fusion. Surtout si vous avez travailler dans un mÃªme fichier quâ€™un ou une de vos collÃ¨gues.\nVous devez tenter de rÃ©soudre les conflits avec des outils en ligne de commande ou Ã  lâ€™aide dâ€™un interface graphique. Câ€™est une habilitÃ© Ã  acquÃ©rir avec le temps. Câ€™est parfois trÃ¨s complexe et si lâ€™opÃ©ration nâ€™est pas effectÃ©e avec soin, il peut y avoir injection de bug.\n// on va sur la branche master\rgit checkout master\r// on merge hotfix dans master\rgit merge hotfix\rGit Rebase Le rebase consiste Ã  changer la base de votre branche dâ€™un commit vers un autre, donnant lâ€™illusion que vous avez crÃ©Ã© votre branche Ã  partir dâ€™un commit diffÃ©rent.\ngit rebase \u003cbase\u003e\rGit stash Lorsque vous voulez sauvegarder lâ€™Ã©tat actuel de votre rÃ©pertoire de travail. Câ€™est possible de le faire avec git stash et de revenir Ã  un rÃ©pertoire de travail propre sans ces modifications. Vous pourrez ensuite rÃ©cupÃ©rer ce travail en utilisant le nom que vous lui aurez donnÃ©. Vous pouvez en avoir plusieurs sauvegardÃ©s dans une liste.\n// Sauvegarder les changements courrants.\rgit stash\r// RÃ©cupÃ©rer les changements prÃ©cÃ©dents.\rgit stash pop\r// Voir la liste des stash\rgit stash list\rMeilleures pratiques Ne pas laisser les branches inactives. Effacer votre branche de bugfix ou de fonctionnalitÃ© si vous avez terminÃ©.\nNe pas prendre les branches pour plusieurs fonctionnalitÃ©s. SÃ©parez vos tÃ¢ches en plus petites et faites des commits plus souvent.\nRÃ©cupÃ©rer la branche parent le plus souvent possible. Soit en faisant un merge ou en faisant des rebases.\nCommuniquez avec votre Ã©quipe vos intentions! Ne travaillez pas sur les mÃªmes modules si possible.\nDans chaque Pull Request. Vous devriez ajouter des tests unitaires si vous avez travaillÃ© sur une fonctionnalitÃ© ou un fix.\nAvant le jour de la mise en production. Vous devriez crÃ©er une branche Ã  partir du main ou master. Donnez-lui le nom de MEP_4OCT_24 par exemple. Effectuez le merge de la branche RELEASE visÃ©e vers la branche de la copie de la production MEP_4OCT_24. Assurez-vous de bien merger tous les Ã©lÃ©ments. Testez que votre branche fonctionne et quâ€™elle est bien compilÃ©e. Le jour J de la mise en production. Mergez cette branche vers la production. Les conflits auront dÃ©jÃ  Ã©tÃ© rÃ©solus! Bingo.\nGitflow Pour maintenir une certain cohÃ©sion en entreprise, un modÃ¨le de branche a Ã©tÃ© proposÃ©. Il implique de sÃ©parer les branches de dÃ©veloppement et les branches primaires qui sont dÃ©ployÃ©s dans multiples environnements.\nSource:\nhttps://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\nRÃ©fÃ©rence Richard E. Silverman (2013), Git Pocket Guide, Oâ€™Reilly\nAlice Jacquot, Introduction Ã  Git https://www.lri.fr/~jacquot/ipo/introAGit.pdf",
    "description": "Introduction Ã  Git Git est un logiciel de contrÃ´le de version. Il permet de gÃ©rer des fichiers et leur Ã©volution dans le temps.\nIl permet de retracer lâ€™origine de chaque modification, de rÃ©tablir des versions prÃ©cÃ©dentes et permet lâ€™intÃ©gration de modifications effectuÃ©es en parallÃ¨le.\nConcept Le principe dâ€™un gestionnaire de version est quâ€™il gÃ¨re un document comme â€œune baseâ€ Ã  laquelle est ajoutÃ© une suite de modifications.\nIl y a un dÃ©pÃ´t commun (Remote) et les contributeurs travaillent sur des versions locales.",
    "tags": [],
    "title": "Gestionnaire de source",
    "uri": "/420-311/ressourcesutiles/gestioncodesource/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Objectifs gÃ©nÃ©raux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de donnÃ©es.\nÃ‰valuer et comparer la complexitÃ© algorithmique des opÃ©rations (temps et mÃ©moire).\nUtiliser des fils dâ€™exÃ©cution (threads) pour exÃ©cuter plusieurs tÃ¢ches en parallÃ¨le.\nDÃ©velopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi Ã©tudier les structures de donnÃ©es ? Parce quâ€™elles sont au cÅ“ur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de donnÃ©es.\nParce quâ€™elles permettent de rÃ©duire le temps dâ€™exÃ©cution et Ã©conomiser de la mÃ©moire.\nParce quâ€™elles dÃ©veloppent la capacitÃ© Ã  choisir la bonne approche selon un problÃ¨me donnÃ©.\nParce quâ€™elles forment une base solide pour les cours ultÃ©rieurs et pour travailler dans des projets dâ€™envergure.\nCitation classique : Â« Un bon algorithme mal implantÃ© dans une mauvaise structure de donnÃ©es sera inefficace. Une bonne structure de donnÃ©es peut transformer un problÃ¨me complexe en une solution Ã©lÃ©gante. Â»\nğŸŒ¼ Notion de structure de donnÃ©es Le principe de base dâ€™une structure de donnÃ©es, câ€™est de stocker des Ã©lÃ©ments auxquels le programmeur veut pouvoir accÃ©der plus tard. On appelle les diffÃ©rentes utilisations possibles de la structure de donnÃ©es des opÃ©rations.\nğŸŒ¼ Les structures de donnÃ©es en Java Le langage Java a Ã©largi et harmonisÃ© la bibliothÃ¨que de classes utilitaires (java.util).\nOn y trouve dÃ©sormais des classes permettant de manipuler les principales structures de donnÃ©es, câ€™est-Ã -dire les vecteurs dynamiques, les ensembles, les listes chaÃ®nÃ©es, les queues et les tables associatives.\nNous commencerons par examiner les concepts communs quâ€™elles (structures de donnÃ©es) exploitent ainsi : gÃ©nÃ©ricitÃ©, itÃ©rateur, ordonnancement et relation dâ€™ordre.\nNous verrons Ã©galement quelles sont les opÃ©rations qui leur sont communes : ajout ou suppression dâ€™Ã©lÃ©ments, construction Ã  partir des Ã©lÃ©ments dâ€™une autre collectionâ€¦\nNous Ã©tudierons ensuite en dÃ©tail chacune de ces structures, Ã  savoir :\nğŸ— Les listes, implÃ©mentÃ©es par la classe LinkedList;\rğŸ— Les vecteurs dynamiques, implÃ©mentÃ©s par les classes ArrayList et Vector;\rğŸ— Les ensembles, implÃ©mentÃ©s par les classes HashSet et TreeSet;\rğŸ— Les queues avec prioritÃ©, implÃ©mentÃ©es par la classe PriorityQueue (introduite par le JDK 5.0) ;\rğŸ— Les queues Ã  double entrÃ©e, implÃ©mentÃ©es par la classe ArrayDeque (introduite par Java6).",
    "description": "Objectifs gÃ©nÃ©raux du cours Ce cours vous permettra de :\nConcevoir et programmer des applications en Java en utilisant les principales structures de donnÃ©es.\nÃ‰valuer et comparer la complexitÃ© algorithmique des opÃ©rations (temps et mÃ©moire).\nUtiliser des fils dâ€™exÃ©cution (threads) pour exÃ©cuter plusieurs tÃ¢ches en parallÃ¨le.\nDÃ©velopper un esprit critique pour choisir la bonne structure et le bon paradigme selon le contexte.\nPourquoi Ã©tudier les structures de donnÃ©es ? Parce quâ€™elles sont au cÅ“ur de la programmation : tout logiciel, du plus simple au plus complexe, repose sur des structures de donnÃ©es.",
    "tags": [],
    "title": "Structures de donnÃ©e",
    "uri": "/420-311/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-311/categories/index.html"
  },
  {
    "breadcrumb": "Structures de donnÃ©e",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-311/tags/index.html"
  }
]
